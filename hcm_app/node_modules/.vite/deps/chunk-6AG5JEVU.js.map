{
  "version": 3,
  "sources": ["../../../../../node_modules/@datadog/browser-core/src/tools/getGlobalObject.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/display.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/catchUserErrors.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/experimentalFeatures.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/numberUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/timeUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/byteUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/polyfills.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/objectUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/getZoneJsOriginalValue.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/monitor.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/timer.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/observable.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/functionUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/stringUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/sessionConstants.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/cookie.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/storeStrategies/sessionStoreStrategy.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/sessionState.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/oldCookiesMigration.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/storeStrategies/sessionInCookie.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/storeStrategies/sessionInLocalStorage.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/browserDetection.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/sessionStoreOperations.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/sessionStore.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/serialisation/jsonStringify.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/urlPolyfill.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/configuration/intakeSites.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/configuration/endpointBuilder.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/configuration/tags.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/configuration/transportConfiguration.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/configuration/configuration.ts", "../../../../../node_modules/@datadog/browser-core/src/boot/init.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/tracekit/computeStackTrace.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/instrumentMethod.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/tracekit/tracekit.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/serialisation/sanitize.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/error/error.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/error/error.types.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/error/trackRuntimeError.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/addEventListener.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/report/reportObservable.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/sendToExtension.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/typeUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/mergeInto.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/telemetry/rawTelemetryEvent.types.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/telemetry/telemetry.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/valueHistory.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/session/sessionManager.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/responseUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/sendWithRetryStrategy.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/httpRequest.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/pageExitObservable.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/batch.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/eventBridge.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/flushController.ts", "../../../../../node_modules/@datadog/browser-core/src/transport/startBatchWithReplica.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/utils/arrayUtils.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/abstractLifeCycle.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/eventRateLimiter/createEventRateLimiter.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/runOnReadyState.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/xhrObservable.ts", "../../../../../node_modules/@datadog/browser-core/src/browser/fetchObservable.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/console/consoleObservable.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/boundedBuffer.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/serialisation/heavyCustomerDataWarning.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/serialisation/contextManager.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/readBytesFromStream.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/synthetics/syntheticsWorkerValues.ts", "../../../../../node_modules/@datadog/browser-core/src/domain/user/user.ts", "../../../../../node_modules/@datadog/browser-core/src/tools/matchOption.ts"],
  "sourcesContent": ["/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\n\nexport function getGlobalObject<T>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n", "/* eslint-disable local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = (typeof ConsoleApiName)[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\n/**\n * When building JS bundles, some users might use a plugin[1] or configuration[2] to remove\n * \"console.*\" references. This causes some issue as we expect `console.*` to be defined.\n * As a workaround, let's use a variable alias, so those expressions won't be taken into account by\n * simple static analysis.\n *\n * [1]: https://babeljs.io/docs/babel-plugin-transform-remove-console/\n * [2]: https://github.com/terser/terser#compress-options (look for drop_console)\n */\nexport const globalConsole = console\n\ndisplay.debug = globalConsole.debug.bind(globalConsole)\ndisplay.log = globalConsole.log.bind(globalConsole)\ndisplay.info = globalConsole.info.bind(globalConsole)\ndisplay.warn = globalConsole.warn.bind(globalConsole)\ndisplay.error = globalConsole.error.bind(globalConsole)\n", "import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n", "/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n *\n * FORMAT:\n * All feature flags should be snake_cased\n */\n// We want to use a real enum (i.e. not a const enum) here, to be able to check whether an arbitrary\n// string is an expected feature flag\n// eslint-disable-next-line no-restricted-syntax\nexport enum ExperimentalFeature {\n  PAGEHIDE = 'pagehide',\n  FEATURE_FLAGS = 'feature_flags',\n  RESOURCE_PAGE_STATES = 'resource_page_states',\n  PAGE_STATES = 'page_states',\n  COLLECT_FLUSH_REASON = 'collect_flush_reason',\n  NO_RESOURCE_DURATION_FROZEN_STATE = 'no_resource_duration_frozen_state',\n  SCROLLMAP = 'scrollmap',\n  DISABLE_REPLAY_INLINE_CSS = 'disable_replay_inline_css',\n}\n\nconst enabledExperimentalFeatures: Set<ExperimentalFeature> = new Set()\n\nexport function addExperimentalFeatures(enabledFeatures: ExperimentalFeature[]): void {\n  enabledFeatures.forEach((flag) => {\n    enabledExperimentalFeatures.add(flag)\n  })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: ExperimentalFeature): boolean {\n  return enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures.clear()\n}\n\nexport function getExperimentalFeatures(): Set<ExperimentalFeature> {\n  return enabledExperimentalFeatures\n}\n", "/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n", "import { isNumber, round } from './numberUtils'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n", "export const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport function computeBytesCount(candidate: string): number {\n  // Accurate bytes count computations can degrade performances when there is a lot of events to process\n  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n    return candidate.length\n  }\n\n  if (window.TextEncoder !== undefined) {\n    return new TextEncoder().encode(candidate).length\n  }\n\n  return new Blob([candidate]).size\n}\n\nexport function concatBuffers(buffers: Uint8Array[]) {\n  const length = buffers.reduce((total, buffer) => total + buffer.length, 0)\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const buffer of buffers) {\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n", "export function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(\n  array: ArrayLike<unknown>,\n  predicate: (item: unknown, index: number) => boolean\n): unknown | undefined {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectEntries<T = unknown>(object: { [key: string]: T }): Array<[string, T]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n", "import { assign } from './polyfills'\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n", "import { getGlobalObject } from './getGlobalObject'\n\nexport interface BrowserWindowWithZoneJs extends Window {\n  Zone?: {\n    // All Zone.js versions expose the __symbol__ method, but we observed that some website have a\n    // 'Zone' global variable unrelated to Zone.js, so let's consider this method optional\n    // nonetheless.\n    __symbol__?: (name: string) => string\n  }\n}\n\n/**\n * Gets the original value for a DOM API that was potentially patched by Zone.js.\n *\n * Zone.js[1] is a library that patches a bunch of JS and DOM APIs. It usually stores the original\n * value of the patched functions/constructors/methods in a hidden property prefixed by\n * __zone_symbol__.\n *\n * In multiple occasions, we observed that Zone.js is the culprit of important issues leading to\n * browser resource exhaustion (memory leak, high CPU usage). This method is used as a workaround to\n * use the original DOM API instead of the one patched by Zone.js.\n *\n * [1]: https://github.com/angular/angular/tree/main/packages/zone.js\n */\nexport function getZoneJsOriginalValue<Target, Name extends keyof Target & string>(\n  target: Target,\n  name: Name\n): Target[Name] {\n  const browserWindow = getGlobalObject<BrowserWindowWithZoneJs>()\n  let original: Target[Name] | undefined\n  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === 'function') {\n    original = (target as any)[browserWindow.Zone.__symbol__(name)]\n  }\n  if (!original) {\n    original = target[name]\n  }\n  return original\n}\n", "import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n", "import { getZoneJsOriginalValue } from './getZoneJsOriginalValue'\nimport { monitor } from './monitor'\nimport { getGlobalObject } from './getGlobalObject'\n\nexport type TimeoutId = ReturnType<typeof window.setTimeout>\n\nexport function setTimeout(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(getGlobalObject<Window>(), 'setTimeout')(monitor(callback), delay)\n}\n\nexport function clearTimeout(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(getGlobalObject<Window>(), 'clearTimeout')(timeoutId)\n}\n\nexport function setInterval(callback: () => void, delay?: number): TimeoutId {\n  return getZoneJsOriginalValue(window, 'setInterval')(monitor(callback), delay)\n}\n\nexport function clearInterval(timeoutId: TimeoutId | undefined) {\n  getZoneJsOriginalValue(window, 'clearInterval')(timeoutId)\n}\n", "export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n", "import type { TimeoutId } from '../timer'\nimport { setTimeout, clearTimeout } from '../timer'\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\nexport type ListenerHandler = () => void\n", "/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) {\n    return candidate\n  }\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n", "import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils/timeUtils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n", "import { display } from '../tools/display'\nimport { ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { findCommaSeparatedValue, generateUUID } from '../tools/utils/stringUtils'\n\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number, options?: CookieOptions) {\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}`\n}\n\nexport function getCookie(name: string) {\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n", "import type { CookieOptions } from '../../../browser/cookie'\nimport type { SessionState } from '../sessionState'\n\nexport const SESSION_STORE_KEY = '_dd_s'\n\nexport type SessionStoreStrategyType = { type: 'Cookie'; cookieOptions: CookieOptions } | { type: 'LocalStorage' }\n\nexport interface SessionStoreStrategy {\n  persistSession: (session: SessionState) => void\n  retrieveSession: () => SessionState\n  clearSession: () => void\n}\n", "import { isEmptyObject } from '../../tools/utils/objectUtils'\nimport { objectEntries } from '../../tools/utils/polyfills'\nimport { dateNow } from '../../tools/utils/timeUtils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\nexport function isSessionInExpiredState(session: SessionState) {\n  return isEmptyObject(session)\n}\n\nexport function expandSessionState(session: SessionState) {\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n}\n\nexport function toSessionString(session: SessionState) {\n  return objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function toSessionState(sessionString: string | undefined | null) {\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined | null): sessionString is string {\n  return (\n    !!sessionString &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n", "import { getCookie } from '../../browser/cookie'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(cookieStoreStrategy: SessionStoreStrategy) {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  if (!sessionString) {\n    const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n    const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n    const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n    const session: SessionState = {}\n\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n\n    if (!isSessionInExpiredState(session)) {\n      expandSessionState(session)\n      cookieStoreStrategy.persistSession(session)\n    }\n  }\n}\n", "import type { CookieOptions } from '../../../browser/cookie'\nimport { getCurrentSite, areCookiesAuthorized, deleteCookie, getCookie, setCookie } from '../../../browser/cookie'\nimport type { InitConfiguration } from '../../configuration'\nimport { tryOldCookiesMigration } from '../oldCookiesMigration'\nimport { SESSION_EXPIRATION_DELAY } from '../sessionConstants'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nexport function selectCookieStrategy(initConfiguration: InitConfiguration): SessionStoreStrategyType | undefined {\n  const cookieOptions = buildCookieOptions(initConfiguration)\n  return areCookiesAuthorized(cookieOptions) ? { type: 'Cookie', cookieOptions } : undefined\n}\n\nexport function initCookieStrategy(cookieOptions: CookieOptions): SessionStoreStrategy {\n  const cookieStore = {\n    persistSession: persistSessionCookie(cookieOptions),\n    retrieveSession: retrieveSessionCookie,\n    clearSession: deleteSessionCookie(cookieOptions),\n  }\n\n  tryOldCookiesMigration(cookieStore)\n\n  return cookieStore\n}\n\nfunction persistSessionCookie(options: CookieOptions) {\n  return (session: SessionState) => {\n    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n  }\n}\n\nfunction retrieveSessionCookie(): SessionState {\n  const sessionString = getCookie(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction deleteSessionCookie(options: CookieOptions) {\n  return () => {\n    deleteCookie(SESSION_STORE_KEY, options)\n  }\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  cookieOptions.secure = !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n", "import { generateUUID } from '../../../tools/utils/stringUtils'\nimport type { SessionState } from '../sessionState'\nimport { toSessionString, toSessionState } from '../sessionState'\nimport type { SessionStoreStrategy, SessionStoreStrategyType } from './sessionStoreStrategy'\nimport { SESSION_STORE_KEY } from './sessionStoreStrategy'\n\nconst LOCAL_STORAGE_TEST_KEY = '_dd_test_'\n\nexport function selectLocalStorageStrategy(): SessionStoreStrategyType | undefined {\n  try {\n    const id = generateUUID()\n    const testKey = `${LOCAL_STORAGE_TEST_KEY}${id}`\n    localStorage.setItem(testKey, id)\n    const retrievedId = localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n    return id === retrievedId ? { type: 'LocalStorage' } : undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function initLocalStorageStrategy(): SessionStoreStrategy {\n  return {\n    persistSession: persistInLocalStorage,\n    retrieveSession: retrieveSessionFromLocalStorage,\n    clearSession: clearSessionFromLocalStorage,\n  }\n}\n\nfunction persistInLocalStorage(sessionState: SessionState) {\n  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState))\n}\n\nfunction retrieveSessionFromLocalStorage(): SessionState {\n  const sessionString = localStorage.getItem(SESSION_STORE_KEY)\n  return toSessionState(sessionString)\n}\n\nfunction clearSessionFromLocalStorage() {\n  localStorage.removeItem(SESSION_STORE_KEY)\n}\n", "export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n", "import { setTimeout } from '../../tools/timer'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport { isChromium } from '../../tools/utils/browserDetection'\nimport type { SessionStoreStrategy } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { expandSessionState, isSessionInExpiredState } from './sessionState'\n\ntype Operations = {\n  process: (sessionState: SessionState) => SessionState | undefined\n  after?: (sessionState: SessionState) => void\n}\n\nexport const LOCK_RETRY_DELAY = 10\nexport const LOCK_MAX_TRIES = 100\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function processSessionStoreOperations(\n  operations: Operations,\n  sessionStoreStrategy: SessionStoreStrategy,\n  numberOfRetries = 0\n) {\n  const { retrieveSession, persistSession, clearSession } = sessionStoreStrategy\n  const lockEnabled = isLockEnabled()\n\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (lockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {\n    next(sessionStoreStrategy)\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (lockEnabled) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = generateUUID()\n    currentSession.lock = currentLock\n    persistSession(currentSession)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (lockEnabled) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, sessionStoreStrategy, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    if (isSessionInExpiredState(processedSession)) {\n      clearSession()\n    } else {\n      expandSessionState(processedSession)\n      persistSession(processedSession)\n    }\n  }\n  if (lockEnabled) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isSessionInExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, sessionStoreStrategy, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      persistSession(currentSession)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date session state value => the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next(sessionStoreStrategy)\n}\n\n/**\n * Lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increases cookie write failures.\n */\nexport const isLockEnabled = () => isChromium()\n\nfunction retryLater(operations: Operations, sessionStore: SessionStoreStrategy, currentNumberOfRetries: number) {\n  setTimeout(() => {\n    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1)\n  }, LOCK_RETRY_DELAY)\n}\n\nfunction next(sessionStore: SessionStoreStrategy) {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    processSessionStoreOperations(nextOperations, sessionStore)\n  }\n}\n", "import { clearInterval, setInterval } from '../../tools/timer'\nimport { Observable } from '../../tools/observable'\nimport { ONE_SECOND, dateNow } from '../../tools/utils/timeUtils'\nimport { throttle } from '../../tools/utils/functionUtils'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from '../configuration'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { selectCookieStrategy, initCookieStrategy } from './storeStrategies/sessionInCookie'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\nimport type { SessionState } from './sessionState'\nimport { initLocalStorageStrategy, selectLocalStorageStrategy } from './storeStrategies/sessionInLocalStorage'\nimport { processSessionStoreOperations } from './sessionStoreOperations'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n  stop: () => void\n}\n\n/**\n * Every second, the storage will be polled to check for any change that can occur\n * to the session state in another browser tab, or another window.\n * This value has been determined from our previous cookie-only implementation.\n */\nexport const STORAGE_POLL_DELAY = ONE_SECOND\n\n/**\n * Checks if cookies are available as the preferred storage\n * Else, checks if LocalStorage is allowed and available\n */\nexport function selectSessionStoreStrategyType(\n  initConfiguration: InitConfiguration\n): SessionStoreStrategyType | undefined {\n  let sessionStoreStrategyType = selectCookieStrategy(initConfiguration)\n  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {\n    sessionStoreStrategyType = selectLocalStorageStrategy()\n  }\n  return sessionStoreStrategyType\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const sessionStoreStrategy =\n    sessionStoreStrategyType.type === 'Cookie'\n      ? initCookieStrategy(sessionStoreStrategyType.cookieOptions)\n      : initLocalStorageStrategy()\n  const { clearSession, retrieveSession } = sessionStoreStrategy\n\n  const watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => {\n          const synchronizedSession = synchronizeSession(sessionState)\n          isTracked = expandOrRenewSessionState(synchronizedSession)\n          return synchronizedSession\n        },\n        after: (sessionState) => {\n          if (isTracked && !hasSessionInCache()) {\n            renewSessionInCache(sessionState)\n          }\n          sessionCache = sessionState\n        },\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function expandSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (hasSessionInCache() ? synchronizeSession(sessionState) : undefined),\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session store\n   * - if the session is not active, clear the session store and expire the session cache\n   */\n  function watchSession() {\n    processSessionStoreOperations(\n      {\n        process: (sessionState) => (!isActiveSession(sessionState) ? {} : undefined),\n        after: synchronizeSession,\n      },\n      sessionStoreStrategy\n    )\n  }\n\n  function synchronizeSession(sessionState: SessionState) {\n    if (!isActiveSession(sessionState)) {\n      sessionState = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(sessionState)) {\n        expireSessionInCache()\n      } else {\n        sessionCache = sessionState\n      }\n    }\n    return sessionState\n  }\n\n  function expandOrRenewSessionState(sessionState: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(sessionState[productKey])\n    sessionState[productKey] = trackingType\n    if (isTracked && !sessionState.id) {\n      sessionState.id = generateUUID()\n      sessionState.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(sessionState: SessionState) {\n    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey]\n  }\n\n  function expireSessionInCache() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSessionInCache(sessionState: SessionState) {\n    sessionCache = sessionState\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(sessionState: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (sessionState.created === undefined || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) &&\n      (sessionState.expire === undefined || dateNow() < Number(sessionState.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: throttle(expandOrRenewSession, STORAGE_POLL_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    expire: () => {\n      clearSession()\n      synchronizeSession({})\n    },\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n", "import { noop } from '../utils/functionUtils'\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(\n  value: unknown,\n  replacer?: Array<string | number>,\n  space?: string | number\n): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matter here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, replacer, space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\nexport interface ObjectWithToJsonMethod {\n  toJSON?: () => unknown\n}\n\nexport function detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n", "import { jsonStringify } from '../serialisation/jsonStringify'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  const supportedURL = getSupportedUrl()\n  if (supportedURL) {\n    try {\n      return base !== undefined ? new supportedURL(url, base) : new supportedURL(url)\n    } catch (error) {\n      throw new Error(`Failed to construct URL: ${String(error)} ${jsonStringify({ url, base })!}`)\n    }\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nconst originalURL = URL\nlet isURLSupported: boolean | undefined\nfunction getSupportedUrl(): typeof URL | undefined {\n  if (isURLSupported === undefined) {\n    try {\n      const url = new originalURL('http://test/path')\n      isURLSupported = url.href === 'http://test/path'\n    } catch {\n      isURLSupported = false\n    }\n  }\n  return isURLSupported ? originalURL : undefined\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * Fallback\n * On IE HTMLAnchorElement origin is not supported: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n * On Firefox window.location.origin is \"null\" for file: URIs: https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin && element.origin !== 'null') {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n", "export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_EU1 = 'datadoghq.eu'\nexport const INTAKE_SITE_AP1 = 'ap1.datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n", "import type { RetryInfo, FlushReason } from '../../transport'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { normalizeUrl } from '../../tools/utils/urlPolyfill'\nimport { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../tools/experimentalFeatures'\nimport { generateUUID } from '../../tools/utils/stringUtils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_AP1, INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[]\n) {\n  const buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType)\n\n  return {\n    build(api: 'xhr' | 'fetch' | 'beacon', flushReason?: FlushReason, retry?: RetryInfo) {\n      const parameters = buildEndpointParameters(\n        initConfiguration,\n        endpointType,\n        configurationTags,\n        api,\n        flushReason,\n        retry\n      )\n      return buildUrlWithParameters(parameters)\n    },\n    urlPrefix: buildUrlWithParameters(''),\n    endpointType,\n  }\n}\n\n/**\n * Create a function used to build a full endpoint url from provided parameters. The goal of this\n * function is to pre-compute some parts of the URL to avoid re-computing everything on every\n * request, as only parameters are changing.\n */\nfunction createEndpointUrlWithParametersBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType\n): (parameters: string) => string {\n  const path = `/api/v2/${INTAKE_TRACKS[endpointType]}`\n\n  const { proxy, proxyUrl } = initConfiguration\n  if (proxy) {\n    const normalizedProxyUrl = normalizeUrl(proxy)\n    return (parameters) => `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`${path}?${parameters}`)}`\n  }\n\n  const host = buildEndpointHost(initConfiguration, endpointType)\n\n  if (proxy === undefined && proxyUrl) {\n    // TODO: remove this in a future major.\n    const normalizedProxyUrl = normalizeUrl(proxyUrl)\n    return (parameters) =>\n      `${normalizedProxyUrl}?ddforward=${encodeURIComponent(`https://${host}${path}?${parameters}`)}`\n  }\n\n  return (parameters) => `https://${host}${path}?${parameters}`\n}\n\nfunction buildEndpointHost(initConfiguration: InitConfiguration, endpointType: EndpointType) {\n  const { site = INTAKE_SITE_US1, internalAnalyticsSubdomain } = initConfiguration\n\n  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {\n    return `${internalAnalyticsSubdomain}.${INTAKE_SITE_US1}`\n  }\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const subdomain = site !== INTAKE_SITE_AP1 ? `${ENDPOINTS[endpointType]}.` : ''\n  return `${subdomain}browser-intake-${domainParts.join('-')}.${extension!}`\n}\n\n/**\n * Build parameters to be used for an intake request. Parameters should be re-built for each\n * request, as they change randomly.\n */\nfunction buildEndpointParameters(\n  { clientToken, internalAnalyticsSubdomain }: InitConfiguration,\n  endpointType: EndpointType,\n  configurationTags: string[],\n  api: 'xhr' | 'fetch' | 'beacon',\n  flushReason: FlushReason | undefined,\n  retry: RetryInfo | undefined\n) {\n  const tags = [`sdk_version:${__BUILD_ENV__SDK_VERSION__}`, `api:${api}`].concat(configurationTags)\n  if (flushReason && isExperimentalFeatureEnabled(ExperimentalFeature.COLLECT_FLUSH_REASON)) {\n    tags.push(`flush_reason:${flushReason}`)\n  }\n  if (retry) {\n    tags.push(`retry_count:${retry.count}`, `retry_after:${retry.lastFailureStatus}`)\n  }\n  const parameters = [\n    'ddsource=browser',\n    `ddtags=${encodeURIComponent(tags.join(','))}`,\n    `dd-api-key=${clientToken}`,\n    `dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}`,\n    'dd-evp-origin=browser',\n    `dd-request-id=${generateUUID()}`,\n  ]\n\n  if (endpointType === 'rum') {\n    parameters.push(`batch_time=${timeStampNow()}`)\n  }\n  if (internalAnalyticsSubdomain) {\n    parameters.reverse()\n  }\n\n  return parameters.join('&')\n}\n", "import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n", "import { objectValues, assign } from '../../tools/utils/polyfills'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeUrlPrefixes = objectValues(endpointBuilders).map((builder) => builder.urlPrefix)\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeUrlPrefixes.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeUrlPrefixes: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeUrlPrefixes.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.urlPrefix))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n", "import { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { ExperimentalFeature, addExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Duration } from '../../tools/utils/timeUtils'\nimport { ONE_SECOND } from '../../tools/utils/timeUtils'\nimport { isPercentage } from '../../tools/utils/numberUtils'\nimport { ONE_KIBI_BYTE } from '../../tools/utils/byteUtils'\nimport { objectHasValue } from '../../tools/utils/objectUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport { selectSessionStoreStrategyType } from '../session/sessionStore'\nimport type { SessionStoreStrategyType } from '../session/storeStrategies/sessionStoreStrategy'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = (typeof DefaultPrivacyLevel)[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  /**\n   * @deprecated use sessionSampleRate instead\n   */\n  sampleRate?: number | undefined\n  sessionSampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n\n  // transport options\n  proxy?: string | undefined\n  /**\n   * @deprecated use `proxy` instead\n   */\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n\n  // alternate storage option\n  allowFallbackToLocalStorage?: boolean | undefined\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  internalAnalyticsSubdomain?: string\n\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  sessionStoreStrategyType: SessionStoreStrategyType | undefined\n  sessionSampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: Duration\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  const sessionSampleRate = initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate\n  if (sessionSampleRate !== undefined && !isPercentage(sessionSampleRate)) {\n    display.error('Session Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {\n    addExperimentalFeatures(\n      initConfiguration.enableExperimentalFeatures.filter((flag): flag is ExperimentalFeature =>\n        objectHasValue(ExperimentalFeature, flag)\n      )\n    )\n  }\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),\n      sessionSampleRate: sessionSampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: (30 * ONE_SECOND) as Duration,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function serializeConfiguration(initConfiguration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  const proxy = initConfiguration.proxy ?? initConfiguration.proxyUrl\n  return {\n    session_sample_rate: initConfiguration.sessionSampleRate ?? initConfiguration.sampleRate,\n    telemetry_sample_rate: initConfiguration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,\n    use_before_send: !!initConfiguration.beforeSend,\n    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,\n    use_proxy: proxy !== undefined ? !!proxy : undefined,\n    silent_multiple_init: initConfiguration.silentMultipleInit,\n    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,\n    track_resources: initConfiguration.trackResources,\n    track_long_task: initConfiguration.trackLongTasks,\n    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage,\n  }\n}\n", "import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils/polyfills'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable = global[name] as { q?: Array<() => void> } | undefined\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n", "import { startsWith } from '../../tools/utils/polyfills'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n", "import { setTimeout } from './timer'\nimport { callMonitored } from './monitor'\nimport { noop } from './utils/functionUtils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(() => {\n      after(thisObject, value)\n    }, 0)\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n", "import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\\s\\S]*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, messageObj: unknown, url?: string, line?: number, column?: number, errorObj?: unknown) {\n      let stackTrace: StackTrace\n      if (errorObj instanceof Error) {\n        stackTrace = computeStackTrace(errorObj)\n      } else {\n        const stack = [{ url, column, line }]\n        const { name, message } = tryToParseMessage(messageObj)\n        stackTrace = {\n          name,\n          message,\n          stack,\n        }\n      }\n      callback(stackTrace, errorObj ?? messageObj)\n    },\n  })\n}\n\nfunction tryToParseMessage(messageObj: unknown) {\n  let name\n  let message\n  if ({}.toString.call(messageObj) === '[object String]') {\n    ;[, name, message] = ERROR_TYPES_RE.exec(messageObj as string)!\n  }\n  return { name, message }\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n", "import { display } from '../display'\nimport { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport type { Context, ContextArray, ContextValue } from './context'\nimport type { ObjectWithToJsonMethod } from './jsonStringify'\nimport { detachToJsonMethod } from './jsonStringify'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype PrimitivesAndFunctions = string | number | boolean | undefined | null | symbol | bigint | Function\ntype ExtendedContextValue = PrimitivesAndFunctions | object | ExtendedContext | ExtendedContextArray\ntype ExtendedContext = { [key: string]: ExtendedContextValue }\ntype ExtendedContextArray = ExtendedContextValue[]\n\ntype ContainerElementToProcess = {\n  source: ExtendedContextArray | ExtendedContext\n  target: ContextArray | Context\n  path: string\n}\n\n// The maximum size of a single event is 256KiB. By default, we ensure that user-provided data\n// going through sanitize fits inside our events, while leaving room for other contexts, metadata, ...\nconst SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE\n\n// Symbol for the root element of the JSONPath used for visited objects\nconst JSON_PATH_ROOT_ELEMENT = '$'\n\n// When serializing (using JSON.stringify) a key of an object, { key: 42 } gets wrapped in quotes as \"key\".\n// With the separator (:), we need to add 3 characters to the count.\nconst KEY_DECORATION_LENGTH = 3\n\n/**\n * Ensures user-provided data is 'safe' for the SDK\n * - Deep clones data\n * - Removes cyclic references\n * - Transforms unserializable types to a string representation\n *\n * LIMITATIONS:\n * - Size is in characters, not byte count (may differ according to character encoding)\n * - Size does not take into account indentation that can be applied to JSON.stringify\n * - Non-numerical properties of Arrays are ignored. Same behavior as JSON.stringify\n *\n * @param source              User-provided data meant to be serialized using JSON.stringify\n * @param maxCharacterCount   Maximum number of characters allowed in serialized form\n */\nexport function sanitize(source: string, maxCharacterCount?: number): string | undefined\nexport function sanitize(source: Context, maxCharacterCount?: number): Context\nexport function sanitize(source: unknown, maxCharacterCount?: number): ContextValue\nexport function sanitize(source: unknown, maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT) {\n  // Unbind any toJSON function we may have on [] or {} prototypes\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n\n  // Initial call to sanitizeProcessor - will populate containerQueue if source is an Array or a plain Object\n  const containerQueue: ContainerElementToProcess[] = []\n  const visitedObjectsWithPath = new WeakMap<object, string>()\n  const sanitizedData = sanitizeProcessor(\n    source as ExtendedContextValue,\n    JSON_PATH_ROOT_ELEMENT,\n    undefined,\n    containerQueue,\n    visitedObjectsWithPath\n  )\n  let accumulatedCharacterCount = JSON.stringify(sanitizedData)?.length || 0\n  if (accumulatedCharacterCount > maxCharacterCount) {\n    warnOverCharacterLimit(maxCharacterCount, 'discarded', source)\n    return undefined\n  }\n\n  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {\n    const containerToProcess = containerQueue.shift()!\n    let separatorLength = 0 // 0 for the first element, 1 for subsequent elements\n\n    // Arrays and Objects have to be handled distinctly to ensure\n    // we do not pick up non-numerical properties from Arrays\n    if (Array.isArray(containerToProcess.source)) {\n      for (let key = 0; key < containerToProcess.source.length; key++) {\n        const targetData = sanitizeProcessor(\n          containerToProcess.source[key],\n          containerToProcess.path,\n          key,\n          containerQueue,\n          visitedObjectsWithPath\n        )\n\n        if (targetData !== undefined) {\n          accumulatedCharacterCount += JSON.stringify(targetData).length\n        } else {\n          // When an element of an Array (targetData) is undefined, it is serialized as null:\n          // JSON.stringify([undefined]) => '[null]' - This accounts for 4 characters\n          accumulatedCharacterCount += 4\n        }\n        accumulatedCharacterCount += separatorLength\n        separatorLength = 1\n        if (accumulatedCharacterCount > maxCharacterCount) {\n          warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n          break\n        }\n        ;(containerToProcess.target as ContextArray)[key] = targetData\n      }\n    } else {\n      for (const key in containerToProcess.source) {\n        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {\n          const targetData = sanitizeProcessor(\n            containerToProcess.source[key],\n            containerToProcess.path,\n            key,\n            containerQueue,\n            visitedObjectsWithPath\n          )\n          // When a property of an object has an undefined value, it will be dropped during serialization:\n          // JSON.stringify({a:undefined}) => '{}'\n          if (targetData !== undefined) {\n            accumulatedCharacterCount +=\n              JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH\n            separatorLength = 1\n          }\n          if (accumulatedCharacterCount > maxCharacterCount) {\n            warnOverCharacterLimit(maxCharacterCount, 'truncated', source)\n            break\n          }\n          ;(containerToProcess.target as Context)[key] = targetData\n        }\n      }\n    }\n  }\n\n  // Rebind detached toJSON functions\n  restoreObjectPrototypeToJson()\n  restoreArrayPrototypeToJson()\n\n  return sanitizedData\n}\n\n/**\n * Internal function to factorize the process common to the\n * initial call to sanitize, and iterations for Arrays and Objects\n *\n */\nfunction sanitizeProcessor(\n  source: ExtendedContextValue,\n  parentPath: string,\n  key: string | number | undefined,\n  queue: ContainerElementToProcess[],\n  visitedObjectsWithPath: WeakMap<object, string>\n) {\n  // Start by handling toJSON, as we want to sanitize its output\n  const sourceToSanitize = tryToApplyToJSON(source)\n\n  if (!sourceToSanitize || typeof sourceToSanitize !== 'object') {\n    return sanitizePrimitivesAndFunctions(sourceToSanitize)\n  }\n\n  const sanitizedSource = sanitizeObjects(sourceToSanitize)\n  if (sanitizedSource !== '[Object]' && sanitizedSource !== '[Array]' && sanitizedSource !== '[Error]') {\n    return sanitizedSource\n  }\n\n  // Handle potential cyclic references\n  // We need to use source as sourceToSanitize could be a reference to a new object\n  // At this stage, we know the source is an object type\n  const sourceAsObject = source as object\n  if (visitedObjectsWithPath.has(sourceAsObject)) {\n    return `[Reference seen at ${visitedObjectsWithPath.get(sourceAsObject)!}]`\n  }\n\n  // Add processed source to queue\n  const currentPath = key !== undefined ? `${parentPath}.${key}` : parentPath\n  const target = Array.isArray(sourceToSanitize) ? ([] as ContextArray) : ({} as Context)\n  visitedObjectsWithPath.set(sourceAsObject, currentPath)\n  queue.push({ source: sourceToSanitize as ExtendedContext | ExtendedContextArray, target, path: currentPath })\n\n  return target\n}\n\n/**\n * Handles sanitization of simple, non-object types\n *\n */\nfunction sanitizePrimitivesAndFunctions(value: PrimitivesAndFunctions) {\n  // BigInt cannot be serialized by JSON.stringify(), convert it to a string representation\n  if (typeof value === 'bigint') {\n    return `[BigInt] ${value.toString()}`\n  }\n  // Functions cannot be serialized by JSON.stringify(). Moreover, if a faulty toJSON is present, it needs to be converted\n  // so it won't prevent stringify from serializing later\n  if (typeof value === 'function') {\n    return `[Function] ${value.name || 'unknown'}`\n  }\n  // JSON.stringify() does not serialize symbols.\n  if (typeof value === 'symbol') {\n    // symbol.description is part of ES2019+\n    type symbolWithDescription = symbol & { description: string }\n    return `[Symbol] ${(value as symbolWithDescription).description || value.toString()}`\n  }\n\n  return value\n}\n\n/**\n * Handles sanitization of object types\n *\n * LIMITATIONS\n * - If a class defines a toStringTag Symbol, it will fall in the catch-all method and prevent enumeration of properties.\n * To avoid this, a toJSON method can be defined.\n * - IE11 does not return a distinct type for objects such as Map, WeakMap, ... These objects will pass through and their\n * properties enumerated if any.\n *\n */\nfunction sanitizeObjects(value: object) {\n  try {\n    // Handle events - Keep a simple implementation to avoid breaking changes\n    if (value instanceof Event) {\n      return {\n        isTrusted: value.isTrusted,\n      }\n    }\n\n    // Handle all remaining object types in a generic way\n    const result = Object.prototype.toString.call(value)\n    const match = result.match(/\\[object (.*)\\]/)\n    if (match && match[1]) {\n      return `[${match[1]}]`\n    }\n  } catch {\n    // If the previous serialization attempts failed, and we cannot convert using\n    // Object.prototype.toString, declare the value unserializable\n  }\n  return '[Unserializable]'\n}\n\n/**\n * Checks if a toJSON function exists and tries to execute it\n *\n */\nfunction tryToApplyToJSON(value: ExtendedContextValue) {\n  const object = value as ObjectWithToJsonMethod\n  if (object && typeof object.toJSON === 'function') {\n    try {\n      return object.toJSON() as ExtendedContextValue\n    } catch {\n      // If toJSON fails, we continue by trying to serialize the value manually\n    }\n  }\n\n  return value\n}\n\n/**\n * Helper function to display the warning when the accumulated character count is over the limit\n */\nfunction warnOverCharacterLimit(maxCharacterCount: number, changeType: 'discarded' | 'truncated', source: unknown) {\n  display.warn(\n    `The data provided has been ${changeType} as it is over the limit of ${maxCharacterCount} characters:`,\n    source\n  )\n}\n", "import type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport type { ClocksState } from '../../tools/utils/timeUtils'\nimport { noop } from '../../tools/utils/functionUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport type { ErrorSource, ErrorHandling, RawError, RawErrorCause, ErrorWithCause, NonErrorPrefix } from './error.types'\n\nexport const NO_ERROR_STACK_PRESENT_MESSAGE = 'No stack, consider using an instance of Error'\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: NonErrorPrefix\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  const isErrorInstance = originalError instanceof Error\n\n  const message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError)\n  const stack = hasUsableStack(isErrorInstance, stackTrace)\n    ? toStackTraceString(stackTrace)\n    : NO_ERROR_STACK_PRESENT_MESSAGE\n  const causes = isErrorInstance ? flattenErrorCauses(originalError as ErrorWithCause, source) : undefined\n  const type = stackTrace?.name\n  const fingerprint = tryToGetFingerprint(originalError)\n\n  return {\n    startClocks,\n    source,\n    handling,\n    handlingStack,\n    originalError,\n    type,\n    message,\n    stack,\n    causes,\n    fingerprint,\n  }\n}\n\nfunction computeMessage(\n  stackTrace: StackTrace | undefined,\n  isErrorInstance: boolean,\n  nonErrorPrefix: NonErrorPrefix,\n  originalError: unknown\n) {\n  // Favor stackTrace message only if tracekit has really been able to extract something meaningful (message + name)\n  // TODO rework tracekit integration to avoid scattering error building logic\n  return stackTrace?.message && stackTrace?.name\n    ? stackTrace.message\n    : !isErrorInstance\n    ? `${nonErrorPrefix} ${jsonStringify(sanitize(originalError))!}`\n    : 'Empty message'\n}\n\nfunction hasUsableStack(isErrorInstance: boolean, stackTrace?: StackTrace): stackTrace is StackTrace {\n  if (stackTrace === undefined) {\n    return false\n  }\n  if (isErrorInstance) {\n    return true\n  }\n  // handle cases where tracekit return stack = [] or stack = [{url: undefined, line: undefined, column: undefined}]\n  // TODO rework tracekit integration to avoid generating those unusable stack\n  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== undefined)\n}\n\nexport function tryToGetFingerprint(originalError: unknown) {\n  return originalError instanceof Error && 'dd_fingerprint' in originalError\n    ? String(originalError.dd_fingerprint)\n    : undefined\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n", "import type { ClocksState } from '../../tools/utils/timeUtils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n  fingerprint?: string\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum NonErrorPrefix {\n  UNCAUGHT = 'Uncaught',\n  PROVIDED = 'Provided',\n}\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = (typeof ErrorSource)[keyof typeof ErrorSource]\n", "import type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/utils/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\nimport { computeRawError } from './error'\nimport type { RawError } from './error.types'\nimport { ErrorHandling, ErrorSource, NonErrorPrefix } from './error.types'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: NonErrorPrefix.UNCAUGHT,\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n", "import { monitor } from '../tools/monitor'\nimport { getZoneJsOriginalValue } from '../tools/getZoneJsOriginalValue'\nimport type { VisualViewport, VisualViewportEventMap } from './types'\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  PAGE_SHOW = 'pageshow',\n  FREEZE = 'freeze',\n  RESUME = 'resume',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\ntype EventMapFor<T> = T extends Window\n  ? WindowEventMap & {\n      // TS 4.9.5 does not support `freeze` and `resume` events yet\n      freeze: Event\n      resume: Event\n      // TS 4.9.5 does not define `visibilitychange` on Window (only Document)\n      visibilitychange: Event\n    }\n  : T extends Document\n  ? DocumentEventMap\n  : T extends HTMLElement\n  ? HTMLElementEventMap\n  : T extends VisualViewport\n  ? VisualViewportEventMap\n  : T extends ShadowRoot\n  ? // ShadowRootEventMap is not yet defined in our supported TS version. Instead, use\n    // GlobalEventHandlersEventMap which is more than enough as we only need to listen for events bubbling\n    // through the ShadowRoot like \"change\" or \"input\"\n    GlobalEventHandlersEventMap\n  : T extends XMLHttpRequest\n  ? XMLHttpRequestEventMap\n  : T extends Performance\n  ? PerformanceEventMap\n  : T extends Worker\n  ? WorkerEventMap\n  : Record<never, never>\n\n/**\n * Add an event listener to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  eventTarget: Target,\n  eventName: EventName,\n  listener: (event: EventMapFor<Target>[EventName]) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(eventTarget, [eventName], listener, options)\n}\n\n/**\n * Add event listeners to an event target object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<Target extends EventTarget, EventName extends keyof EventMapFor<Target> & string>(\n  eventTarget: Target,\n  eventNames: EventName[],\n  listener: (event: EventMapFor<Target>[EventName]) => void,\n  { once, capture, passive }: AddEventListenerOptions = {}\n) {\n  const wrappedListener = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as EventMapFor<Target>[EventName])\n        }\n      : (listener as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n\n  const add = getZoneJsOriginalValue(eventTarget, 'addEventListener')\n  eventNames.forEach((eventName) => add.call(eventTarget, eventName, wrappedListener, options))\n\n  function stop() {\n    const remove = getZoneJsOriginalValue(eventTarget, 'removeEventListener')\n    eventNames.forEach((eventName) => remove.call(eventTarget, eventName, wrappedListener, options))\n  }\n\n  return {\n    stop,\n  }\n}\n", "import { toStackTraceString } from '../error/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { addEventListener, DOM_EVENT } from '../../browser/addEventListener'\nimport { includes } from '../../tools/utils/polyfills'\nimport { safeTruncate } from '../../tools/utils/stringUtils'\nimport type { ReportType, InterventionReport, DeprecationReport } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = (typeof RawReportType)[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable())\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!window.ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Array<DeprecationReport | InterventionReport>, _: ReportingObserver) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    ) as ReportingObserverCallback\n\n    const observer = new window.ReportingObserver(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable() {\n  const observable = new Observable<RawReport>(() => {\n    const { stop } = addEventListener(document, DOM_EVENT.SECURITY_POLICY_VIOLATION, (event) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: DeprecationReport | InterventionReport): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | null,\n  lineNumber: number | null,\n  columnNumber: number | null\n): string | undefined {\n  return sourceFile\n    ? toStackTraceString({\n        name,\n        message,\n        stack: [\n          {\n            func: '?',\n            url: sourceFile,\n            line: lineNumber ?? undefined,\n            column: columnNumber ?? undefined,\n          },\n        ],\n      })\n    : undefined\n}\n", "interface BrowserWindow {\n  __ddBrowserSdkExtensionCallback?: (message: unknown) => void\n}\n\ntype ExtensionMessageType = 'logs' | 'record' | 'rum' | 'telemetry'\n\nexport function sendToExtension(type: ExtensionMessageType, payload: unknown) {\n  const callback = (window as BrowserWindow).__ddBrowserSdkExtensionCallback\n  if (callback) {\n    callback({ type, payload })\n  }\n}\n", "/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n", "import { getType } from './utils/typeUtils'\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged = getType(destination) === 'object' ? (destination as Record<any, any>) : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are de-referenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\n\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  if (typeof WeakSet !== 'undefined') {\n    const set: WeakSet<any> = new WeakSet()\n    return {\n      hasAlreadyBeenSeen(value) {\n        const has = set.has(value)\n        if (!has) {\n          set.add(value)\n        }\n        return has\n      },\n    }\n  }\n  const array: any[] = []\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = array.indexOf(value) >= 0\n      if (!has) {\n        array.push(value)\n      }\n      return has\n    },\n  }\n}\n", "import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n", "import type { Context } from '../../tools/serialisation/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString, NO_ERROR_STACK_PRESENT_MESSAGE } from '../error/error'\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures'\nimport type { Configuration } from '../configuration'\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/utils/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport { sendToExtension } from '../../tools/sendToExtension'\nimport { startsWith, arrayFrom, includes, assign } from '../../tools/utils/polyfills'\nimport { performDraw } from '../../tools/utils/numberUtils'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\nimport { combine } from '../../tools/mergeInto'\nimport { NonErrorPrefix } from '../error/error.types'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'https://d3uc069fcn7uxw.cloudfront.net',\n  'https://d20xtzwzcl0ceb.cloudfront.net',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n  enabled: boolean\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled =\n    !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  onRawTelemetryEventCollected = (rawEvent: RawTelemetryEvent) => {\n    if (telemetryConfiguration.telemetryEnabled) {\n      const event = toTelemetryEvent(telemetryService, rawEvent)\n      observable.notify(event)\n      sendToExtension('telemetry', event)\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(telemetryService: TelemetryService, event: RawTelemetryEvent): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: event as any, // https://github.com/microsoft/TypeScript/issues/48457\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    )\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n    enabled: telemetryConfiguration.telemetryEnabled,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown, context?: Context) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e),\n      context\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n    },\n    message: `${NonErrorPrefix.UNCAUGHT} ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n", "import { setInterval, clearInterval } from './timer'\nimport type { TimeoutId } from './timer'\nimport type { Duration, RelativeTime } from './utils/timeUtils'\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ValueHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  value: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of values spans. This whole class assumes that values are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ValueHistory<Value> {\n  private entries: Array<ValueHistoryEntry<Value>> = []\n  private clearOldValuesInterval: TimeoutId\n\n  constructor(\n    private expireDelay: number,\n    private maxEntries?: number\n  ) {\n    this.clearOldValuesInterval = setInterval(() => this.clearOldValues(), CLEAR_OLD_VALUES_INTERVAL)\n  }\n\n  /**\n   * Add a value to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(value: Value, startTime: RelativeTime): ValueHistoryEntry<Value> {\n    const entry: ValueHistoryEntry<Value> = {\n      value,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n\n    if (this.maxEntries && this.entries.length >= this.maxEntries) {\n      this.entries.pop()\n    }\n\n    this.entries.unshift(entry)\n\n    return entry\n  }\n\n  /**\n   * Return the latest value that was active during `startTime`, or the currently active value\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Value | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.value\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active value, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all values with an active period overlapping with the duration,\n   * or all values that were active during `startTime` if no duration is provided,\n   * or all currently active values if no `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES, duration = 0 as Duration): Value[] {\n    const endTime = addDuration(startTime, duration)\n    return this.entries\n      .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n      .map((entry) => entry.value)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldValuesInterval)\n  }\n\n  private clearOldValues() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n", "import type { Observable } from '../../tools/observable'\nimport type { Context } from '../../tools/serialisation/context'\nimport { ValueHistory } from '../../tools/valueHistory'\nimport type { RelativeTime } from '../../tools/utils/timeUtils'\nimport { relativeNow, clocksOrigin, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport { DOM_EVENT, addEventListener, addEventListeners } from '../../browser/addEventListener'\nimport { clearInterval, setInterval } from '../../tools/timer'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { startSessionStore } from './sessionStore'\nimport type { SessionStoreStrategyType } from './storeStrategies/sessionStoreStrategy'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  expire: () => void\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  sessionStoreStrategyType: SessionStoreStrategyType,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  const sessionStore = startSessionStore(sessionStoreStrategyType, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ValueHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(() => sessionStore.expandOrRenewSession())\n  trackVisibility(() => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n    expire: sessionStore.expire,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(expandOrRenewSession: () => void) {\n  const { stop } = addEventListeners(\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.TOUCH_START, DOM_EVENT.KEY_DOWN, DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(expandSession: () => void) {\n  const expandSessionWhenVisible = () => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  }\n\n  const { stop } = addEventListener(document, DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n", "export function isServerError(status: number) {\n  return status >= 500\n}\n\nexport function tryToClone(response: Response): Response | undefined {\n  try {\n    return response.clone()\n  } catch (e) {\n    // clone can throw if the response has already been used by another instrumentation or is disturbed\n    return\n  }\n}\n", "import type { EndpointType } from '../domain/configuration'\nimport { setTimeout } from '../tools/timer'\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils'\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils'\nimport { isServerError } from '../tools/utils/responseUtils'\nimport type { RawError } from '../domain/error/error.types'\nimport { ErrorSource } from '../domain/error/error.types'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(() => {\n    const payload = state.queuedPayloads.first()\n    send(payload, state, sendStrategy, {\n      onSuccess: () => {\n        state.queuedPayloads.dequeue()\n        state.currentBackoffTime = INITIAL_BACKOFF_TIME\n        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n      },\n      onFailure: () => {\n        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  }, state.currentBackoffTime)\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      payload.retry = {\n        count: payload.retry ? payload.retry.count + 1 : 1,\n        lastFailureStatus: response.status,\n      }\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return (\n    response.type !== 'opaque' &&\n    ((response.status === 0 && !navigator.onLine) ||\n      response.status === 408 ||\n      response.status === 429 ||\n      isServerError(response.status))\n  )\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n", "import type { EndpointBuilder } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/serialisation/context'\nimport { monitor } from '../tools/monitor'\nimport { addEventListener } from '../browser/addEventListener'\nimport type { RawError } from '../domain/error/error.types'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\nimport type { FlushReason } from './flushController'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n  type?: ResponseType\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n  retry?: RetryInfo\n  flushReason?: FlushReason\n}\n\nexport interface RetryInfo {\n  count: number\n  lastFailureStatus: number\n}\n\nexport function createHttpRequest(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason }: Payload\n) {\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const beaconUrl = endpointBuilder.build('beacon', flushReason)\n      const isQueued = navigator.sendBeacon(beaconUrl, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  const xhrUrl = endpointBuilder.build('xhr', flushReason)\n  sendXHR(xhrUrl, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount, flushReason, retry }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    const fetchUrl = endpointBuilder.build('fetch', flushReason, retry)\n    fetch(fetchUrl, { method: 'POST', body: data, keepalive: true, mode: 'cors' }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status, type: response.type })),\n      monitor(() => {\n        const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n        // failed to queue the request\n        sendXHR(xhrUrl, data, onResponse)\n      })\n    )\n  } else {\n    const xhrUrl = endpointBuilder.build('xhr', flushReason, retry)\n    sendXHR(xhrUrl, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(url: string, data: Payload['data'], onResponse?: (r: HttpResponse) => void) {\n  const request = new XMLHttpRequest()\n  request.open('POST', url, true)\n  addEventListener(\n    request,\n    'loadend',\n    () => {\n      onResponse?.({ status: request.status })\n    },\n    {\n      // prevent multiple onResponse callbacks\n      // if the xhr instance is reused by a third party\n      once: true,\n    }\n  )\n  request.send(data)\n}\n", "import { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures'\nimport { Observable } from '../tools/observable'\nimport { objectValues, includes } from '../tools/utils/polyfills'\nimport { noop } from '../tools/utils/functionUtils'\nimport { addEventListeners, addEventListener, DOM_EVENT } from './addEventListener'\n\nexport const PageExitReason = {\n  HIDDEN: 'visibility_hidden',\n  UNLOADING: 'before_unload',\n  PAGEHIDE: 'page_hide',\n  FROZEN: 'page_frozen',\n} as const\n\nexport type PageExitReason = (typeof PageExitReason)[keyof typeof PageExitReason]\n\nexport interface PageExitEvent {\n  reason: PageExitReason\n}\n\nexport function createPageExitObservable(): Observable<PageExitEvent> {\n  const observable = new Observable<PageExitEvent>(() => {\n    const pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE)\n    const { stop: stopListeners } = addEventListeners(\n      window,\n      [DOM_EVENT.VISIBILITY_CHANGE, DOM_EVENT.FREEZE, DOM_EVENT.PAGE_HIDE],\n      (event) => {\n        if (event.type === DOM_EVENT.PAGE_HIDE && pagehideEnabled) {\n          /**\n           * Only event that detect page unload events while being compatible with the back/forward cache (bfcache)\n           */\n          observable.notify({ reason: PageExitReason.PAGEHIDE })\n        } else if (event.type === DOM_EVENT.VISIBILITY_CHANGE && document.visibilityState === 'hidden') {\n          /**\n           * Only event that guarantee to fire on mobile devices when the page transitions to background state\n           * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n           */\n          observable.notify({ reason: PageExitReason.HIDDEN })\n        } else if (event.type === DOM_EVENT.FREEZE) {\n          /**\n           * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n           * Allow to collect events happening between hidden and frozen state.\n           */\n          observable.notify({ reason: PageExitReason.FROZEN })\n        }\n      },\n      { capture: true }\n    )\n\n    let stopBeforeUnloadListener = noop\n    if (!pagehideEnabled) {\n      stopBeforeUnloadListener = addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, () => {\n        observable.notify({ reason: PageExitReason.UNLOADING })\n      }).stop\n    }\n\n    return () => {\n      stopListeners()\n      stopBeforeUnloadListener()\n    }\n  })\n\n  return observable\n}\n\nexport function isPageExitReason(reason: string | undefined): reason is PageExitReason {\n  return includes(objectValues(PageExitReason), reason)\n}\n", "import { display } from '../tools/display'\nimport type { Context } from '../tools/serialisation/context'\nimport { objectValues } from '../tools/utils/polyfills'\nimport { isPageExitReason } from '../browser/pageExitObservable'\nimport { computeBytesCount } from '../tools/utils/byteUtils'\nimport { jsonStringify } from '../tools/serialisation/jsonStringify'\nimport type { HttpRequest } from './httpRequest'\nimport type { FlushController, FlushEvent } from './flushController'\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n\n  constructor(\n    private request: HttpRequest,\n    private flushController: FlushController,\n    private messageBytesLimit: number\n  ) {\n    this.flushController.flushObservable.subscribe((event) => this.flush(event))\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  private flush(event: FlushEvent) {\n    const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n\n    this.pushOnlyBuffer = []\n    this.upsertBuffer = {}\n\n    const payload = { data: messages.join('\\n'), bytesCount: event.bytesCount, flushReason: event.reason }\n    if (isPageExitReason(event.reason)) {\n      this.request.sendOnExit(payload)\n    } else {\n      this.request.send(payload)\n    }\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0\n\n    this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount)\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.flushController.notifyAfterAddMessage()\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = computeBytesCount(removedMessage)\n    // If there are other messages, a '\\n' will be added at serialization\n    const separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0\n    this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount)\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n}\n", "import { endsWith } from '../tools/utils/polyfills'\nimport { getGlobalObject } from '../tools/getGlobalObject'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n", "import type { PageExitEvent, PageExitReason } from '../browser/pageExitObservable'\nimport { Observable } from '../tools/observable'\nimport type { TimeoutId } from '../tools/timer'\nimport { clearTimeout, setTimeout } from '../tools/timer'\nimport type { Duration } from '../tools/utils/timeUtils'\n\nexport type FlushReason = PageExitReason | 'duration_limit' | 'bytes_limit' | 'messages_limit' | 'session_expire'\n\nexport type FlushController = ReturnType<typeof createFlushController>\nexport interface FlushEvent {\n  reason: FlushReason\n  bytesCount: number\n  messagesCount: number\n}\n\ninterface FlushControllerOptions {\n  messagesLimit: number\n  bytesLimit: number\n  durationLimit: Duration\n  pageExitObservable: Observable<PageExitEvent>\n  sessionExpireObservable: Observable<void>\n}\n\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({\n  messagesLimit,\n  bytesLimit,\n  durationLimit,\n  pageExitObservable,\n  sessionExpireObservable,\n}: FlushControllerOptions) {\n  const flushObservable = new Observable<FlushEvent>()\n\n  pageExitObservable.subscribe((event) => flush(event.reason))\n  sessionExpireObservable.subscribe(() => flush('session_expire'))\n\n  let currentBytesCount = 0\n  let currentMessagesCount = 0\n\n  function flush(flushReason: FlushReason) {\n    if (currentMessagesCount === 0) {\n      return\n    }\n\n    const messagesCount = currentMessagesCount\n    const bytesCount = currentBytesCount\n\n    currentMessagesCount = 0\n    currentBytesCount = 0\n    cancelDurationLimitTimeout()\n\n    flushObservable.notify({\n      reason: flushReason,\n      messagesCount,\n      bytesCount,\n    })\n  }\n\n  let durationLimitTimeoutId: TimeoutId | undefined\n  function scheduleDurationLimitTimeout() {\n    if (durationLimitTimeoutId === undefined) {\n      durationLimitTimeoutId = setTimeout(() => {\n        flush('duration_limit')\n      }, durationLimit)\n    }\n  }\n\n  function cancelDurationLimitTimeout() {\n    clearTimeout(durationLimitTimeoutId)\n    durationLimitTimeoutId = undefined\n  }\n\n  return {\n    flushObservable,\n    get messagesCount() {\n      return currentMessagesCount\n    },\n\n    /**\n     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right before adding the message, so no flush\n     * event can happen after `notifyBeforeAddMessage` and before adding the message.\n     */\n    notifyBeforeAddMessage(messageBytesCount: number) {\n      if (currentBytesCount + messageBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n      // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n      // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n      // to notify when a flush is needed (for example on page exit).\n      currentMessagesCount += 1\n      currentBytesCount += messageBytesCount\n      scheduleDurationLimitTimeout()\n    },\n\n    /**\n     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n     *\n     * This function can be called asynchronously after the message was added, but in this case it\n     * should not be called if a flush event occurred in between.\n     */\n    notifyAfterAddMessage() {\n      if (currentMessagesCount >= messagesLimit) {\n        flush('messages_limit')\n      } else if (currentBytesCount >= bytesLimit) {\n        flush('bytes_limit')\n      }\n    },\n\n    /**\n     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n     *\n     * This function needs to be called synchronously, right after removing the message, so no flush\n     * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n     */\n    notifyAfterRemoveMessage(messageBytesCount: number) {\n      currentBytesCount -= messageBytesCount\n      currentMessagesCount -= 1\n      if (currentMessagesCount === 0) {\n        cancelDurationLimitTimeout()\n      }\n    },\n  }\n}\n", "import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { Context } from '../tools/serialisation/context'\nimport type { Observable } from '../tools/observable'\nimport type { PageExitEvent } from '../browser/pageExitObservable'\nimport type { RawError } from '../domain/error/error.types'\nimport { Batch } from './batch'\nimport { createHttpRequest } from './httpRequest'\nimport { createFlushController } from './flushController'\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  endpoint: EndpointBuilder,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>,\n  replicaEndpoint?: EndpointBuilder\n) {\n  const primaryBatch = createBatch(endpoint)\n  let replicaBatch: Batch | undefined\n  if (replicaEndpoint) {\n    replicaBatch = createBatch(replicaEndpoint)\n  }\n\n  function createBatch(endpointBuilder: EndpointBuilder) {\n    return new Batch(\n      createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError),\n      createFlushController({\n        messagesLimit: configuration.batchMessagesLimit,\n        bytesLimit: configuration.batchBytesLimit,\n        durationLimit: configuration.flushTimeout,\n        pageExitObservable,\n        sessionExpireObservable,\n      }),\n      configuration.messageBytesLimit\n    )\n  }\n\n  return {\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(message)\n      }\n    },\n  }\n}\n", "import { arrayFrom } from './polyfills'\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n", "import type { Subscription } from './observable'\n\n/**\n * Type helper to extract event types that have \"void\" data. This allows to call `notify` without a\n * second argument. Ex:\n *\n * ```\n * interface EventMap {\n *   foo: void\n * }\n * const LifeCycle = AbstractLifeCycle<EventMap>\n * new LifeCycle().notify('foo')\n * ```\n */\ntype EventTypesWithoutData<EventMap> = {\n  [K in keyof EventMap]: EventMap[K] extends void ? K : never\n}[keyof EventMap]\n\nexport class AbstractLifeCycle<EventMap> {\n  private callbacks: { [key in keyof EventMap]?: Array<(data: any) => void> } = {}\n\n  notify<EventType extends EventTypesWithoutData<EventMap>>(eventType: EventType): void\n  notify<EventType extends keyof EventMap>(eventType: EventType, data: EventMap[EventType]): void\n  notify(eventType: keyof EventMap, data?: unknown) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe<EventType extends keyof EventMap>(\n    eventType: EventType,\n    callback: (data: EventMap[EventType]) => void\n  ): Subscription {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n", "import { setTimeout } from '../../tools/timer'\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils'\nimport type { RawError } from '../error/error.types'\nimport { ErrorSource } from '../error/error.types'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n", "import { DOM_EVENT, addEventListener } from './addEventListener'\n\nexport function runOnReadyState(expectedReadyState: 'complete' | 'interactive', callback: () => void) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(window, eventName, callback, { once: true })\n  }\n}\n", "import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/utils/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\nimport { shallowClone } from '../tools/utils/objectUtils'\nimport { addEventListener } from './addEventListener'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable()\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable() {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = () => {\n    unsubscribeLoadEndListener()\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  }\n\n  const { stop: unsubscribeLoadEndListener } = addEventListener(this, 'loadend', onEnd)\n\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n", "import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { ClocksState } from '../tools/utils/timeUtils'\nimport { clocksNow } from '../tools/utils/timeUtils'\nimport { normalizeUrl } from '../tools/utils/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: unknown\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchResolveContext extends FetchContextBase {\n  state: 'resolve'\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchResolveContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input as RequestInfo, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: unknown, init?: RequestInit) {\n  const method = (init && init.method) || (input instanceof Request && input.method) || 'GET'\n  const url = input instanceof Request ? input.url : normalizeUrl(String(input))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchResolveContext\n    context.state = 'resolve'\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n    }\n    observable.notify(context)\n  }\n\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n", "import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString, tryToGetFingerprint } from '../error/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { ConsoleApiName, globalConsole } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\nimport { sanitize } from '../../tools/serialisation/sanitize'\nimport { find } from '../../tools/utils/polyfills'\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n  fingerprint?: string\n}\n\nlet consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\nexport function resetConsoleObservable() {\n  consoleObservablesByApi = {}\n}\n\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = globalConsole[api]\n\n    globalConsole[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      globalConsole[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n  let fingerprint\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    fingerprint = tryToGetFingerprint(firstErrorParam)\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n    fingerprint,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return sanitize(param)\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(sanitize(param), undefined, 2)\n}\n", "const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n", "import { ONE_KIBI_BYTE } from '../utils/byteUtils'\nimport { display } from '../display'\n\n// RUM and logs batch bytes limit is 16KB\n// ensure that we leave room for other event attributes and maintain a decent amount of event per batch\n// (3KB (customer data) + 1KB (other attributes)) * 4 (events per batch) = 16KB\nexport const CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE\n\nexport const enum CustomerDataType {\n  FeatureFlag = 'feature flag evaluation',\n  User = 'user',\n  GlobalContext = 'global context',\n  LoggerContext = 'logger context',\n}\n\nexport function warnIfCustomerDataLimitReached(bytesCount: number, customerDataType: CustomerDataType): boolean {\n  if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {\n    display.warn(\n      `The ${customerDataType} data exceeds the recommended ${\n        CUSTOMER_DATA_BYTES_LIMIT / ONE_KIBI_BYTE\n      }KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-3kib-warning`\n    )\n    return true\n  }\n  return false\n}\n", "import { computeBytesCount } from '../utils/byteUtils'\nimport { throttle } from '../utils/functionUtils'\nimport { deepClone } from '../mergeInto'\nimport { getType } from '../utils/typeUtils'\nimport { jsonStringify } from './jsonStringify'\nimport { sanitize } from './sanitize'\nimport { warnIfCustomerDataLimitReached } from './heavyCustomerDataWarning'\nimport type { CustomerDataType } from './heavyCustomerDataWarning'\nimport type { Context, ContextValue } from './context'\n\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type ContextManager = ReturnType<typeof createContextManager>\n\nexport function createContextManager(customerDataType: CustomerDataType, computeBytesCountImpl = computeBytesCount) {\n  let context: Context = {}\n  let bytesCountCache: number\n  let alreadyWarned = false\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call context APIs synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCountImpl(jsonStringify(context)!)\n    if (!alreadyWarned) {\n      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, customerDataType)\n    }\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  const contextManager = {\n    getBytesCount: () => bytesCountCache,\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n      computeBytesCountThrottled(context)\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n      computeBytesCountThrottled(context)\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      if (getType(newContext) === 'object') {\n        context = sanitize(newContext)\n        computeBytesCountThrottled(context)\n      } else {\n        contextManager.clearContext()\n      }\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = sanitize(property)\n      computeBytesCountThrottled(context)\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n      computeBytesCountThrottled(context)\n    },\n\n    clearContext: () => {\n      context = {}\n      bytesCountCache = 0\n    },\n  }\n  return contextManager\n}\n", "import { monitor } from './monitor'\nimport { noop } from './utils/functionUtils'\n\ntype Options = {\n  bytesLimit: number\n  collectStreamBody?: boolean\n}\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(\n  stream: ReadableStream<Uint8Array>,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void,\n  options: Options\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let bytes: Uint8Array | undefined\n    let limitExceeded: boolean | undefined\n    if (options.collectStreamBody) {\n      let completeBuffer: Uint8Array\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        let offset = 0\n        chunks.forEach((chunk) => {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n", "import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n", "import type { Context } from '../../tools/serialisation/context'\nimport { display } from '../../tools/display'\nimport { getType } from '../../tools/utils/typeUtils'\nimport { assign } from '../../tools/utils/polyfills'\nimport type { User } from './user.types'\n\n/**\n * Clone input data and ensure known user properties (id, name, email)\n * are strings, as defined here:\n * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n */\nexport function sanitizeUser(newUser: Context): Context {\n  // We shallow clone only to prevent mutation of user data.\n  const user = assign({}, newUser)\n  const keys = ['id', 'name', 'email']\n  keys.forEach((key) => {\n    if (key in user) {\n      user[key] = String(user[key])\n    }\n  })\n  return user\n}\n\n/**\n * Simple check to ensure user is valid\n */\nexport function checkUser(newUser: User): boolean {\n  const isValid = getType(newUser) === 'object'\n  if (!isValid) {\n    display.error('Unsupported user:', newUser)\n  }\n  return isValid\n}\n", "import { startsWith } from './utils/polyfills'\nimport { display } from './display'\nimport { getType } from './utils/typeUtils'\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\n\nexport function isMatchOption(item: unknown): item is MatchOption {\n  const itemType = getType(item)\n  return itemType === 'string' || itemType === 'function' || item instanceof RegExp\n}\n\n/**\n * Returns true if value can be matched by at least one of the provided MatchOptions.\n * When comparing strings, setting useStartsWith to true will compare the value with the start of\n * the option, instead of requiring an exact match.\n */\nexport function matchList(list: MatchOption[], value: string, useStartsWith = false): boolean {\n  return list.some((item) => {\n    try {\n      if (typeof item === 'function') {\n        return item(value)\n      } else if (item instanceof RegExp) {\n        return item.test(value)\n      } else if (typeof item === 'string') {\n        return useStartsWith ? startsWith(value, item) : item === value\n      }\n    } catch (e) {\n      display.error(e)\n    }\n    return false\n  })\n}\n"],
  "mappings": "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",
  "names": ["ExperimentalFeature", "buffer", "e", "Observable", "telemetryService", "ValueHistory", "xhrUrl", "Batch", "AbstractLifeCycle", "BoundedBuffer", "context"]
}
