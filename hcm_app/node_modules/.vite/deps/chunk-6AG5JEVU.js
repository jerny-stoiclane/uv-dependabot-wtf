// ../../node_modules/@datadog/browser-core/esm/tools/getGlobalObject.js
function getGlobalObject() {
  if (typeof globalThis === "object") {
    return globalThis;
  }
  Object.defineProperty(Object.prototype, "_dd_temp_", {
    get: function() {
      return this;
    },
    configurable: true
  });
  var globalObject = _dd_temp_;
  delete Object.prototype._dd_temp_;
  if (typeof globalObject !== "object") {
    if (typeof self === "object") {
      globalObject = self;
    } else if (typeof window === "object") {
      globalObject = window;
    } else {
      globalObject = {};
    }
  }
  return globalObject;
}

// ../../node_modules/@datadog/browser-core/esm/tools/display.js
var ConsoleApiName = {
  log: "log",
  debug: "debug",
  info: "info",
  warn: "warn",
  error: "error"
};
var display = function(api) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {
    api = ConsoleApiName.log;
  }
  display[api].apply(display, args);
};
var globalConsole = console;
display.debug = globalConsole.debug.bind(globalConsole);
display.log = globalConsole.log.bind(globalConsole);
display.info = globalConsole.info.bind(globalConsole);
display.warn = globalConsole.warn.bind(globalConsole);
display.error = globalConsole.error.bind(globalConsole);

// ../../node_modules/@datadog/browser-core/esm/tools/catchUserErrors.js
function catchUserErrors(fn, errorMsg) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    try {
      return fn.apply(void 0, args);
    } catch (err) {
      display.error(errorMsg, err);
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/tools/experimentalFeatures.js
var ExperimentalFeature;
(function(ExperimentalFeature2) {
  ExperimentalFeature2["PAGEHIDE"] = "pagehide";
  ExperimentalFeature2["FEATURE_FLAGS"] = "feature_flags";
  ExperimentalFeature2["RESOURCE_PAGE_STATES"] = "resource_page_states";
  ExperimentalFeature2["PAGE_STATES"] = "page_states";
  ExperimentalFeature2["COLLECT_FLUSH_REASON"] = "collect_flush_reason";
  ExperimentalFeature2["NO_RESOURCE_DURATION_FROZEN_STATE"] = "no_resource_duration_frozen_state";
  ExperimentalFeature2["SCROLLMAP"] = "scrollmap";
  ExperimentalFeature2["DISABLE_REPLAY_INLINE_CSS"] = "disable_replay_inline_css";
})(ExperimentalFeature || (ExperimentalFeature = {}));
var enabledExperimentalFeatures = /* @__PURE__ */ new Set();
function addExperimentalFeatures(enabledFeatures) {
  enabledFeatures.forEach(function(flag) {
    enabledExperimentalFeatures.add(flag);
  });
}
function isExperimentalFeatureEnabled(featureName) {
  return enabledExperimentalFeatures.has(featureName);
}
function getExperimentalFeatures() {
  return enabledExperimentalFeatures;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/numberUtils.js
function performDraw(threshold) {
  return threshold !== 0 && Math.random() * 100 <= threshold;
}
function round(num, decimals) {
  return +num.toFixed(decimals);
}
function isPercentage(value) {
  return isNumber(value) && value >= 0 && value <= 100;
}
function isNumber(value) {
  return typeof value === "number";
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/timeUtils.js
var ONE_SECOND = 1e3;
var ONE_MINUTE = 60 * ONE_SECOND;
var ONE_HOUR = 60 * ONE_MINUTE;
var ONE_DAY = 24 * ONE_HOUR;
var ONE_YEAR = 365 * ONE_DAY;
function relativeToClocks(relative) {
  return { relative, timeStamp: getCorrectedTimeStamp(relative) };
}
function getCorrectedTimeStamp(relativeTime) {
  var correctedOrigin = dateNow() - performance.now();
  if (correctedOrigin > getNavigationStart()) {
    return Math.round(addDuration(correctedOrigin, relativeTime));
  }
  return getTimeStamp(relativeTime);
}
function currentDrift() {
  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now()));
}
function toServerDuration(duration) {
  if (!isNumber(duration)) {
    return duration;
  }
  return round(duration * 1e6, 0);
}
function dateNow() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function timeStampNow() {
  return dateNow();
}
function relativeNow() {
  return performance.now();
}
function clocksNow() {
  return { relative: relativeNow(), timeStamp: timeStampNow() };
}
function clocksOrigin() {
  return { relative: 0, timeStamp: getNavigationStart() };
}
function elapsed(start, end) {
  return end - start;
}
function addDuration(a, b) {
  return a + b;
}
function getRelativeTime(timestamp) {
  return timestamp - getNavigationStart();
}
function getTimeStamp(relativeTime) {
  return Math.round(addDuration(getNavigationStart(), relativeTime));
}
function looksLikeRelativeTime(time) {
  return time < ONE_YEAR;
}
var navigationStart;
function getNavigationStart() {
  if (navigationStart === void 0) {
    navigationStart = performance.timing.navigationStart;
  }
  return navigationStart;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/byteUtils.js
var ONE_KIBI_BYTE = 1024;
var ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE;
var HAS_MULTI_BYTES_CHARACTERS = /[^\u0000-\u007F]/;
function computeBytesCount(candidate) {
  if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {
    return candidate.length;
  }
  if (window.TextEncoder !== void 0) {
    return new TextEncoder().encode(candidate).length;
  }
  return new Blob([candidate]).size;
}
function concatBuffers(buffers) {
  var length = buffers.reduce(function(total, buffer2) {
    return total + buffer2.length;
  }, 0);
  var result = new Uint8Array(length);
  var offset = 0;
  for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
    var buffer = buffers_1[_i];
    result.set(buffer, offset);
    offset += buffer.length;
  }
  return result;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/polyfills.js
function includes(candidate, search) {
  return candidate.indexOf(search) !== -1;
}
function arrayFrom(arrayLike) {
  if (Array.from) {
    return Array.from(arrayLike);
  }
  var array = [];
  if (arrayLike instanceof Set) {
    arrayLike.forEach(function(item) {
      return array.push(item);
    });
  } else {
    for (var i = 0; i < arrayLike.length; i++) {
      array.push(arrayLike[i]);
    }
  }
  return array;
}
function find(array, predicate) {
  for (var i = 0; i < array.length; i += 1) {
    var item = array[i];
    if (predicate(item, i)) {
      return item;
    }
  }
  return void 0;
}
function findLast(array, predicate) {
  for (var i = array.length - 1; i >= 0; i -= 1) {
    var item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
  return void 0;
}
function forEach(list, callback) {
  Array.prototype.forEach.call(list, callback);
}
function objectValues(object) {
  return Object.keys(object).map(function(key) {
    return object[key];
  });
}
function objectEntries(object) {
  return Object.keys(object).map(function(key) {
    return [key, object[key]];
  });
}
function startsWith(candidate, search) {
  return candidate.slice(0, search.length) === search;
}
function endsWith(candidate, search) {
  return candidate.slice(-search.length) === search;
}
function elementMatches(element, selector) {
  if (element.matches) {
    return element.matches(selector);
  }
  if (element.msMatchesSelector) {
    return element.msMatchesSelector(selector);
  }
  return false;
}
function cssEscape(str) {
  if (window.CSS && window.CSS.escape) {
    return window.CSS.escape(str);
  }
  return str.replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, function(ch, asCodePoint) {
    if (asCodePoint) {
      if (ch === "\0") {
        return "ï¿½";
      }
      return "".concat(ch.slice(0, -1), "\\").concat(ch.charCodeAt(ch.length - 1).toString(16), " ");
    }
    return "\\".concat(ch);
  });
}
function assign(target) {
  var toAssign = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    toAssign[_i - 1] = arguments[_i];
  }
  toAssign.forEach(function(source) {
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  });
  return target;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/objectUtils.js
function shallowClone(object) {
  return assign({}, object);
}
function objectHasValue(object, value) {
  return Object.keys(object).some(function(key) {
    return object[key] === value;
  });
}
function isEmptyObject(object) {
  return Object.keys(object).length === 0;
}
function mapValues(object, fn) {
  var newObject = {};
  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
    var key = _a[_i];
    newObject[key] = fn(object[key]);
  }
  return newObject;
}

// ../../node_modules/@datadog/browser-core/esm/tools/getZoneJsOriginalValue.js
function getZoneJsOriginalValue(target, name) {
  var browserWindow = getGlobalObject();
  var original;
  if (browserWindow.Zone && typeof browserWindow.Zone.__symbol__ === "function") {
    original = target[browserWindow.Zone.__symbol__(name)];
  }
  if (!original) {
    original = target[name];
  }
  return original;
}

// ../../node_modules/@datadog/browser-core/esm/tools/monitor.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var onMonitorErrorCollected;
var debugMode = false;
function startMonitorErrorCollection(newOnMonitorErrorCollected) {
  onMonitorErrorCollected = newOnMonitorErrorCollected;
}
function setDebugMode(newDebugMode) {
  debugMode = newDebugMode;
}
function monitored(_, __, descriptor) {
  var originalMethod = descriptor.value;
  descriptor.value = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod;
    return decorated.apply(this, args);
  };
}
function monitor(fn) {
  return function() {
    return callMonitored(fn, this, arguments);
  };
}
function callMonitored(fn, context, args) {
  try {
    return fn.apply(context, args);
  } catch (e) {
    displayIfDebugEnabled(ConsoleApiName.error, e);
    if (onMonitorErrorCollected) {
      try {
        onMonitorErrorCollected(e);
      } catch (e2) {
        displayIfDebugEnabled(ConsoleApiName.error, e2);
      }
    }
  }
}
function displayIfDebugEnabled(api) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (debugMode) {
    display.apply(void 0, __spreadArray([api, "[MONITOR]"], args, false));
  }
}

// ../../node_modules/@datadog/browser-core/esm/tools/timer.js
function setTimeout(callback, delay) {
  return getZoneJsOriginalValue(getGlobalObject(), "setTimeout")(monitor(callback), delay);
}
function clearTimeout(timeoutId) {
  getZoneJsOriginalValue(getGlobalObject(), "clearTimeout")(timeoutId);
}
function setInterval(callback, delay) {
  return getZoneJsOriginalValue(window, "setInterval")(monitor(callback), delay);
}
function clearInterval(timeoutId) {
  getZoneJsOriginalValue(window, "clearInterval")(timeoutId);
}

// ../../node_modules/@datadog/browser-core/esm/tools/observable.js
var Observable = (
  /** @class */
  function() {
    function Observable2(onFirstSubscribe) {
      this.onFirstSubscribe = onFirstSubscribe;
      this.observers = [];
    }
    Observable2.prototype.subscribe = function(f) {
      var _this = this;
      if (!this.observers.length && this.onFirstSubscribe) {
        this.onLastUnsubscribe = this.onFirstSubscribe() || void 0;
      }
      this.observers.push(f);
      return {
        unsubscribe: function() {
          _this.observers = _this.observers.filter(function(other) {
            return f !== other;
          });
          if (!_this.observers.length && _this.onLastUnsubscribe) {
            _this.onLastUnsubscribe();
          }
        }
      };
    };
    Observable2.prototype.notify = function(data) {
      this.observers.forEach(function(observer) {
        return observer(data);
      });
    };
    return Observable2;
  }()
);
function mergeObservables() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var globalObservable = new Observable(function() {
    var subscriptions = observables.map(function(observable) {
      return observable.subscribe(function(data) {
        return globalObservable.notify(data);
      });
    });
    return function() {
      return subscriptions.forEach(function(subscription) {
        return subscription.unsubscribe();
      });
    };
  });
  return globalObservable;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/functionUtils.js
function throttle(fn, wait, options) {
  var needLeadingExecution = options && options.leading !== void 0 ? options.leading : true;
  var needTrailingExecution = options && options.trailing !== void 0 ? options.trailing : true;
  var inWaitPeriod = false;
  var pendingExecutionWithParameters;
  var pendingTimeoutId;
  return {
    throttled: function() {
      var parameters = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        parameters[_i] = arguments[_i];
      }
      if (inWaitPeriod) {
        pendingExecutionWithParameters = parameters;
        return;
      }
      if (needLeadingExecution) {
        fn.apply(void 0, parameters);
      } else {
        pendingExecutionWithParameters = parameters;
      }
      inWaitPeriod = true;
      pendingTimeoutId = setTimeout(function() {
        if (needTrailingExecution && pendingExecutionWithParameters) {
          fn.apply(void 0, pendingExecutionWithParameters);
        }
        inWaitPeriod = false;
        pendingExecutionWithParameters = void 0;
      }, wait);
    },
    cancel: function() {
      clearTimeout(pendingTimeoutId);
      inWaitPeriod = false;
      pendingExecutionWithParameters = void 0;
    }
  };
}
function noop() {
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/stringUtils.js
function generateUUID(placeholder) {
  return placeholder ? (
    // eslint-disable-next-line  no-bitwise
    (parseInt(placeholder, 10) ^ Math.random() * 16 >> parseInt(placeholder, 10) / 4).toString(16)
  ) : "".concat(1e7, "-").concat(1e3, "-").concat(4e3, "-").concat(8e3, "-").concat(1e11).replace(/[018]/g, generateUUID);
}
function findCommaSeparatedValue(rawString, name) {
  var regex = new RegExp("(?:^|;)\\s*".concat(name, "\\s*=\\s*([^;]+)"));
  var matches = regex.exec(rawString);
  return matches ? matches[1] : void 0;
}
function safeTruncate(candidate, length, suffix) {
  if (suffix === void 0) {
    suffix = "";
  }
  var lastChar = candidate.charCodeAt(length - 1);
  var isLastCharSurrogatePair = lastChar >= 55296 && lastChar <= 56319;
  var correctedLength = isLastCharSurrogatePair ? length + 1 : length;
  if (candidate.length <= correctedLength) {
    return candidate;
  }
  return "".concat(candidate.slice(0, correctedLength)).concat(suffix);
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/sessionConstants.js
var SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR;
var SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE;

// ../../node_modules/@datadog/browser-core/esm/browser/cookie.js
function setCookie(name, value, expireDelay, options) {
  var date = /* @__PURE__ */ new Date();
  date.setTime(date.getTime() + expireDelay);
  var expires = "expires=".concat(date.toUTCString());
  var sameSite = options && options.crossSite ? "none" : "strict";
  var domain = options && options.domain ? ";domain=".concat(options.domain) : "";
  var secure = options && options.secure ? ";secure" : "";
  document.cookie = "".concat(name, "=").concat(value, ";").concat(expires, ";path=/;samesite=").concat(sameSite).concat(domain).concat(secure);
}
function getCookie(name) {
  return findCommaSeparatedValue(document.cookie, name);
}
function deleteCookie(name, options) {
  setCookie(name, "", 0, options);
}
function areCookiesAuthorized(options) {
  if (document.cookie === void 0 || document.cookie === null) {
    return false;
  }
  try {
    var testCookieName = "dd_cookie_test_".concat(generateUUID());
    var testCookieValue = "test";
    setCookie(testCookieName, testCookieValue, ONE_MINUTE, options);
    var isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue;
    deleteCookie(testCookieName, options);
    return isCookieCorrectlySet;
  } catch (error) {
    display.error(error);
    return false;
  }
}
var getCurrentSiteCache;
function getCurrentSite() {
  if (getCurrentSiteCache === void 0) {
    var testCookieName = "dd_site_test_".concat(generateUUID());
    var testCookieValue = "test";
    var domainLevels = window.location.hostname.split(".");
    var candidateDomain = domainLevels.pop();
    while (domainLevels.length && !getCookie(testCookieName)) {
      candidateDomain = "".concat(domainLevels.pop(), ".").concat(candidateDomain);
      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain });
    }
    deleteCookie(testCookieName, { domain: candidateDomain });
    getCurrentSiteCache = candidateDomain;
  }
  return getCurrentSiteCache;
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionStoreStrategy.js
var SESSION_STORE_KEY = "_dd_s";

// ../../node_modules/@datadog/browser-core/esm/domain/session/sessionState.js
var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
var SESSION_ENTRY_SEPARATOR = "&";
function isSessionInExpiredState(session) {
  return isEmptyObject(session);
}
function expandSessionState(session) {
  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY);
}
function toSessionString(session) {
  return objectEntries(session).map(function(_a) {
    var key = _a[0], value = _a[1];
    return "".concat(key, "=").concat(value);
  }).join(SESSION_ENTRY_SEPARATOR);
}
function toSessionState(sessionString) {
  var session = {};
  if (isValidSessionString(sessionString)) {
    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function(entry) {
      var matches = SESSION_ENTRY_REGEXP.exec(entry);
      if (matches !== null) {
        var key = matches[1], value = matches[2];
        session[key] = value;
      }
    });
  }
  return session;
}
function isValidSessionString(sessionString) {
  return !!sessionString && (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString));
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/oldCookiesMigration.js
var OLD_SESSION_COOKIE_NAME = "_dd";
var OLD_RUM_COOKIE_NAME = "_dd_r";
var OLD_LOGS_COOKIE_NAME = "_dd_l";
var RUM_SESSION_KEY = "rum";
var LOGS_SESSION_KEY = "logs";
function tryOldCookiesMigration(cookieStoreStrategy) {
  var sessionString = getCookie(SESSION_STORE_KEY);
  if (!sessionString) {
    var oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME);
    var oldRumType = getCookie(OLD_RUM_COOKIE_NAME);
    var oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME);
    var session = {};
    if (oldSessionId) {
      session.id = oldSessionId;
    }
    if (oldLogsType && /^[01]$/.test(oldLogsType)) {
      session[LOGS_SESSION_KEY] = oldLogsType;
    }
    if (oldRumType && /^[012]$/.test(oldRumType)) {
      session[RUM_SESSION_KEY] = oldRumType;
    }
    if (!isSessionInExpiredState(session)) {
      expandSessionState(session);
      cookieStoreStrategy.persistSession(session);
    }
  }
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInCookie.js
function selectCookieStrategy(initConfiguration) {
  var cookieOptions = buildCookieOptions(initConfiguration);
  return areCookiesAuthorized(cookieOptions) ? { type: "Cookie", cookieOptions } : void 0;
}
function initCookieStrategy(cookieOptions) {
  var cookieStore = {
    persistSession: persistSessionCookie(cookieOptions),
    retrieveSession: retrieveSessionCookie,
    clearSession: deleteSessionCookie(cookieOptions)
  };
  tryOldCookiesMigration(cookieStore);
  return cookieStore;
}
function persistSessionCookie(options) {
  return function(session) {
    setCookie(SESSION_STORE_KEY, toSessionString(session), SESSION_EXPIRATION_DELAY, options);
  };
}
function retrieveSessionCookie() {
  var sessionString = getCookie(SESSION_STORE_KEY);
  return toSessionState(sessionString);
}
function deleteSessionCookie(options) {
  return function() {
    deleteCookie(SESSION_STORE_KEY, options);
  };
}
function buildCookieOptions(initConfiguration) {
  var cookieOptions = {};
  cookieOptions.secure = !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie;
  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie;
  if (initConfiguration.trackSessionAcrossSubdomains) {
    cookieOptions.domain = getCurrentSite();
  }
  return cookieOptions;
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/storeStrategies/sessionInLocalStorage.js
var LOCAL_STORAGE_TEST_KEY = "_dd_test_";
function selectLocalStorageStrategy() {
  try {
    var id = generateUUID();
    var testKey = "".concat(LOCAL_STORAGE_TEST_KEY).concat(id);
    localStorage.setItem(testKey, id);
    var retrievedId = localStorage.getItem(testKey);
    localStorage.removeItem(testKey);
    return id === retrievedId ? { type: "LocalStorage" } : void 0;
  } catch (e) {
    return void 0;
  }
}
function initLocalStorageStrategy() {
  return {
    persistSession: persistInLocalStorage,
    retrieveSession: retrieveSessionFromLocalStorage,
    clearSession: clearSessionFromLocalStorage
  };
}
function persistInLocalStorage(sessionState) {
  localStorage.setItem(SESSION_STORE_KEY, toSessionString(sessionState));
}
function retrieveSessionFromLocalStorage() {
  var sessionString = localStorage.getItem(SESSION_STORE_KEY);
  return toSessionState(sessionString);
}
function clearSessionFromLocalStorage() {
  localStorage.removeItem(SESSION_STORE_KEY);
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/browserDetection.js
function isIE() {
  return Boolean(document.documentMode);
}
function isChromium() {
  return !!window.chrome || /HeadlessChrome/.test(window.navigator.userAgent);
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/sessionStoreOperations.js
var LOCK_RETRY_DELAY = 10;
var LOCK_MAX_TRIES = 100;
var bufferedOperations = [];
var ongoingOperations;
function processSessionStoreOperations(operations, sessionStoreStrategy, numberOfRetries) {
  var _a;
  if (numberOfRetries === void 0) {
    numberOfRetries = 0;
  }
  var retrieveSession = sessionStoreStrategy.retrieveSession, persistSession = sessionStoreStrategy.persistSession, clearSession = sessionStoreStrategy.clearSession;
  var lockEnabled = isLockEnabled();
  if (!ongoingOperations) {
    ongoingOperations = operations;
  }
  if (operations !== ongoingOperations) {
    bufferedOperations.push(operations);
    return;
  }
  if (lockEnabled && numberOfRetries >= LOCK_MAX_TRIES) {
    next(sessionStoreStrategy);
    return;
  }
  var currentLock;
  var currentSession = retrieveSession();
  if (lockEnabled) {
    if (currentSession.lock) {
      retryLater(operations, sessionStoreStrategy, numberOfRetries);
      return;
    }
    currentLock = generateUUID();
    currentSession.lock = currentLock;
    persistSession(currentSession);
    currentSession = retrieveSession();
    if (currentSession.lock !== currentLock) {
      retryLater(operations, sessionStoreStrategy, numberOfRetries);
      return;
    }
  }
  var processedSession = operations.process(currentSession);
  if (lockEnabled) {
    currentSession = retrieveSession();
    if (currentSession.lock !== currentLock) {
      retryLater(operations, sessionStoreStrategy, numberOfRetries);
      return;
    }
  }
  if (processedSession) {
    if (isSessionInExpiredState(processedSession)) {
      clearSession();
    } else {
      expandSessionState(processedSession);
      persistSession(processedSession);
    }
  }
  if (lockEnabled) {
    if (!(processedSession && isSessionInExpiredState(processedSession))) {
      currentSession = retrieveSession();
      if (currentSession.lock !== currentLock) {
        retryLater(operations, sessionStoreStrategy, numberOfRetries);
        return;
      }
      delete currentSession.lock;
      persistSession(currentSession);
      processedSession = currentSession;
    }
  }
  (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentSession);
  next(sessionStoreStrategy);
}
var isLockEnabled = function() {
  return isChromium();
};
function retryLater(operations, sessionStore, currentNumberOfRetries) {
  setTimeout(function() {
    processSessionStoreOperations(operations, sessionStore, currentNumberOfRetries + 1);
  }, LOCK_RETRY_DELAY);
}
function next(sessionStore) {
  ongoingOperations = void 0;
  var nextOperations = bufferedOperations.shift();
  if (nextOperations) {
    processSessionStoreOperations(nextOperations, sessionStore);
  }
}

// ../../node_modules/@datadog/browser-core/esm/domain/session/sessionStore.js
var STORAGE_POLL_DELAY = ONE_SECOND;
function selectSessionStoreStrategyType(initConfiguration) {
  var sessionStoreStrategyType = selectCookieStrategy(initConfiguration);
  if (!sessionStoreStrategyType && initConfiguration.allowFallbackToLocalStorage) {
    sessionStoreStrategyType = selectLocalStorageStrategy();
  }
  return sessionStoreStrategyType;
}
function startSessionStore(sessionStoreStrategyType, productKey, computeSessionState) {
  var renewObservable = new Observable();
  var expireObservable = new Observable();
  var sessionStoreStrategy = sessionStoreStrategyType.type === "Cookie" ? initCookieStrategy(sessionStoreStrategyType.cookieOptions) : initLocalStorageStrategy();
  var clearSession = sessionStoreStrategy.clearSession, retrieveSession = sessionStoreStrategy.retrieveSession;
  var watchSessionTimeoutId = setInterval(watchSession, STORAGE_POLL_DELAY);
  var sessionCache = retrieveActiveSession();
  function expandOrRenewSession() {
    var isTracked;
    processSessionStoreOperations({
      process: function(sessionState) {
        var synchronizedSession = synchronizeSession(sessionState);
        isTracked = expandOrRenewSessionState(synchronizedSession);
        return synchronizedSession;
      },
      after: function(sessionState) {
        if (isTracked && !hasSessionInCache()) {
          renewSessionInCache(sessionState);
        }
        sessionCache = sessionState;
      }
    }, sessionStoreStrategy);
  }
  function expandSession() {
    processSessionStoreOperations({
      process: function(sessionState) {
        return hasSessionInCache() ? synchronizeSession(sessionState) : void 0;
      }
    }, sessionStoreStrategy);
  }
  function watchSession() {
    processSessionStoreOperations({
      process: function(sessionState) {
        return !isActiveSession(sessionState) ? {} : void 0;
      },
      after: synchronizeSession
    }, sessionStoreStrategy);
  }
  function synchronizeSession(sessionState) {
    if (!isActiveSession(sessionState)) {
      sessionState = {};
    }
    if (hasSessionInCache()) {
      if (isSessionInCacheOutdated(sessionState)) {
        expireSessionInCache();
      } else {
        sessionCache = sessionState;
      }
    }
    return sessionState;
  }
  function expandOrRenewSessionState(sessionState) {
    var _a = computeSessionState(sessionState[productKey]), trackingType = _a.trackingType, isTracked = _a.isTracked;
    sessionState[productKey] = trackingType;
    if (isTracked && !sessionState.id) {
      sessionState.id = generateUUID();
      sessionState.created = String(dateNow());
    }
    return isTracked;
  }
  function hasSessionInCache() {
    return sessionCache[productKey] !== void 0;
  }
  function isSessionInCacheOutdated(sessionState) {
    return sessionCache.id !== sessionState.id || sessionCache[productKey] !== sessionState[productKey];
  }
  function expireSessionInCache() {
    sessionCache = {};
    expireObservable.notify();
  }
  function renewSessionInCache(sessionState) {
    sessionCache = sessionState;
    renewObservable.notify();
  }
  function retrieveActiveSession() {
    var session = retrieveSession();
    if (isActiveSession(session)) {
      return session;
    }
    return {};
  }
  function isActiveSession(sessionState) {
    return (sessionState.created === void 0 || dateNow() - Number(sessionState.created) < SESSION_TIME_OUT_DELAY) && (sessionState.expire === void 0 || dateNow() < Number(sessionState.expire));
  }
  return {
    expandOrRenewSession: throttle(expandOrRenewSession, STORAGE_POLL_DELAY).throttled,
    expandSession,
    getSession: function() {
      return sessionCache;
    },
    renewObservable,
    expireObservable,
    expire: function() {
      clearSession();
      synchronizeSession({});
    },
    stop: function() {
      clearInterval(watchSessionTimeoutId);
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/tools/serialisation/jsonStringify.js
function jsonStringify(value, replacer, space) {
  if (typeof value !== "object" || value === null) {
    return JSON.stringify(value);
  }
  var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);
  var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);
  var restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value));
  var restoreValueToJson = detachToJsonMethod(value);
  try {
    return JSON.stringify(value, replacer, space);
  } catch (_a) {
    return "<error: unable to serialize object>";
  } finally {
    restoreObjectPrototypeToJson();
    restoreArrayPrototypeToJson();
    restoreValuePrototypeToJson();
    restoreValueToJson();
  }
}
function detachToJsonMethod(value) {
  var object = value;
  var objectToJson = object.toJSON;
  if (objectToJson) {
    delete object.toJSON;
    return function() {
      object.toJSON = objectToJson;
    };
  }
  return noop;
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/urlPolyfill.js
function normalizeUrl(url) {
  return buildUrl(url, getLocationOrigin()).href;
}
function isValidUrl(url) {
  try {
    return !!buildUrl(url);
  } catch (_a) {
    return false;
  }
}
function getOrigin(url) {
  return getLinkElementOrigin(buildUrl(url));
}
function getPathName(url) {
  var pathname = buildUrl(url).pathname;
  return pathname[0] === "/" ? pathname : "/".concat(pathname);
}
function buildUrl(url, base) {
  var supportedURL = getSupportedUrl();
  if (supportedURL) {
    try {
      return base !== void 0 ? new supportedURL(url, base) : new supportedURL(url);
    } catch (error) {
      throw new Error("Failed to construct URL: ".concat(String(error), " ").concat(jsonStringify({ url, base })));
    }
  }
  if (base === void 0 && !/:/.test(url)) {
    throw new Error("Invalid URL: '".concat(url, "'"));
  }
  var doc = document;
  var anchorElement = doc.createElement("a");
  if (base !== void 0) {
    doc = document.implementation.createHTMLDocument("");
    var baseElement = doc.createElement("base");
    baseElement.href = base;
    doc.head.appendChild(baseElement);
    doc.body.appendChild(anchorElement);
  }
  anchorElement.href = url;
  return anchorElement;
}
var originalURL = URL;
var isURLSupported;
function getSupportedUrl() {
  if (isURLSupported === void 0) {
    try {
      var url = new originalURL("http://test/path");
      isURLSupported = url.href === "http://test/path";
    } catch (_a) {
      isURLSupported = false;
    }
  }
  return isURLSupported ? originalURL : void 0;
}
function getLocationOrigin() {
  return getLinkElementOrigin(window.location);
}
function getLinkElementOrigin(element) {
  if (element.origin && element.origin !== "null") {
    return element.origin;
  }
  var sanitizedHost = element.host.replace(/(:80|:443)$/, "");
  return "".concat(element.protocol, "//").concat(sanitizedHost);
}

// ../../node_modules/@datadog/browser-core/esm/domain/configuration/intakeSites.js
var INTAKE_SITE_STAGING = "datad0g.com";
var INTAKE_SITE_US1 = "datadoghq.com";
var INTAKE_SITE_EU1 = "datadoghq.eu";
var INTAKE_SITE_AP1 = "ap1.datadoghq.com";
var INTAKE_SITE_US1_FED = "ddog-gov.com";

// ../../node_modules/@datadog/browser-core/esm/domain/configuration/endpointBuilder.js
var ENDPOINTS = {
  logs: "logs",
  rum: "rum",
  sessionReplay: "session-replay"
};
var INTAKE_TRACKS = {
  logs: "logs",
  rum: "rum",
  sessionReplay: "replay"
};
function createEndpointBuilder(initConfiguration, endpointType, configurationTags) {
  var buildUrlWithParameters = createEndpointUrlWithParametersBuilder(initConfiguration, endpointType);
  return {
    build: function(api, flushReason, retry) {
      var parameters = buildEndpointParameters(initConfiguration, endpointType, configurationTags, api, flushReason, retry);
      return buildUrlWithParameters(parameters);
    },
    urlPrefix: buildUrlWithParameters(""),
    endpointType
  };
}
function createEndpointUrlWithParametersBuilder(initConfiguration, endpointType) {
  var path = "/api/v2/".concat(INTAKE_TRACKS[endpointType]);
  var proxy = initConfiguration.proxy, proxyUrl = initConfiguration.proxyUrl;
  if (proxy) {
    var normalizedProxyUrl_1 = normalizeUrl(proxy);
    return function(parameters) {
      return "".concat(normalizedProxyUrl_1, "?ddforward=").concat(encodeURIComponent("".concat(path, "?").concat(parameters)));
    };
  }
  var host = buildEndpointHost(initConfiguration, endpointType);
  if (proxy === void 0 && proxyUrl) {
    var normalizedProxyUrl_2 = normalizeUrl(proxyUrl);
    return function(parameters) {
      return "".concat(normalizedProxyUrl_2, "?ddforward=").concat(encodeURIComponent("https://".concat(host).concat(path, "?").concat(parameters)));
    };
  }
  return function(parameters) {
    return "https://".concat(host).concat(path, "?").concat(parameters);
  };
}
function buildEndpointHost(initConfiguration, endpointType) {
  var _a = initConfiguration.site, site = _a === void 0 ? INTAKE_SITE_US1 : _a, internalAnalyticsSubdomain = initConfiguration.internalAnalyticsSubdomain;
  if (internalAnalyticsSubdomain && site === INTAKE_SITE_US1) {
    return "".concat(internalAnalyticsSubdomain, ".").concat(INTAKE_SITE_US1);
  }
  var domainParts = site.split(".");
  var extension = domainParts.pop();
  var subdomain = site !== INTAKE_SITE_AP1 ? "".concat(ENDPOINTS[endpointType], ".") : "";
  return "".concat(subdomain, "browser-intake-").concat(domainParts.join("-"), ".").concat(extension);
}
function buildEndpointParameters(_a, endpointType, configurationTags, api, flushReason, retry) {
  var clientToken = _a.clientToken, internalAnalyticsSubdomain = _a.internalAnalyticsSubdomain;
  var tags = ["sdk_version:".concat("4.46.0"), "api:".concat(api)].concat(configurationTags);
  if (flushReason && isExperimentalFeatureEnabled(ExperimentalFeature.COLLECT_FLUSH_REASON)) {
    tags.push("flush_reason:".concat(flushReason));
  }
  if (retry) {
    tags.push("retry_count:".concat(retry.count), "retry_after:".concat(retry.lastFailureStatus));
  }
  var parameters = [
    "ddsource=browser",
    "ddtags=".concat(encodeURIComponent(tags.join(","))),
    "dd-api-key=".concat(clientToken),
    "dd-evp-origin-version=".concat(encodeURIComponent("4.46.0")),
    "dd-evp-origin=browser",
    "dd-request-id=".concat(generateUUID())
  ];
  if (endpointType === "rum") {
    parameters.push("batch_time=".concat(timeStampNow()));
  }
  if (internalAnalyticsSubdomain) {
    parameters.reverse();
  }
  return parameters.join("&");
}

// ../../node_modules/@datadog/browser-core/esm/domain/configuration/tags.js
var TAG_SIZE_LIMIT = 200;
function buildTags(configuration) {
  var env = configuration.env, service = configuration.service, version = configuration.version, datacenter = configuration.datacenter;
  var tags = [];
  if (env) {
    tags.push(buildTag("env", env));
  }
  if (service) {
    tags.push(buildTag("service", service));
  }
  if (version) {
    tags.push(buildTag("version", version));
  }
  if (datacenter) {
    tags.push(buildTag("datacenter", datacenter));
  }
  return tags;
}
var FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/;
function buildTag(key, rawValue) {
  var valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1;
  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {
    display.warn("".concat(key, " value doesn't meet tag requirements and will be sanitized"));
  }
  var sanitizedValue = rawValue.replace(/,/g, "_");
  return "".concat(key, ":").concat(sanitizedValue);
}

// ../../node_modules/@datadog/browser-core/esm/domain/configuration/transportConfiguration.js
function computeTransportConfiguration(initConfiguration) {
  var tags = buildTags(initConfiguration);
  var endpointBuilders = computeEndpointBuilders(initConfiguration, tags);
  var intakeUrlPrefixes = objectValues(endpointBuilders).map(function(builder) {
    return builder.urlPrefix;
  });
  var replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags);
  return assign({
    isIntakeUrl: function(url) {
      return intakeUrlPrefixes.some(function(intakeEndpoint) {
        return url.indexOf(intakeEndpoint) === 0;
      });
    },
    replica: replicaConfiguration,
    site: initConfiguration.site || INTAKE_SITE_US1
  }, endpointBuilders);
}
function computeEndpointBuilders(initConfiguration, tags) {
  return {
    logsEndpointBuilder: createEndpointBuilder(initConfiguration, "logs", tags),
    rumEndpointBuilder: createEndpointBuilder(initConfiguration, "rum", tags),
    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, "sessionReplay", tags)
  };
}
function computeReplicaConfiguration(initConfiguration, intakeUrlPrefixes, tags) {
  if (!initConfiguration.replica) {
    return;
  }
  var replicaConfiguration = assign({}, initConfiguration, {
    site: INTAKE_SITE_US1,
    clientToken: initConfiguration.replica.clientToken
  });
  var replicaEndpointBuilders = {
    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, "logs", tags),
    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, "rum", tags)
  };
  intakeUrlPrefixes.push.apply(intakeUrlPrefixes, objectValues(replicaEndpointBuilders).map(function(builder) {
    return builder.urlPrefix;
  }));
  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders);
}

// ../../node_modules/@datadog/browser-core/esm/domain/configuration/configuration.js
var DefaultPrivacyLevel = {
  ALLOW: "allow",
  MASK: "mask",
  MASK_USER_INPUT: "mask-user-input"
};
function validateAndBuildConfiguration(initConfiguration) {
  var _a, _b, _c;
  if (!initConfiguration || !initConfiguration.clientToken) {
    display.error("Client Token is not configured, we will not send any data.");
    return;
  }
  var sessionSampleRate = (_a = initConfiguration.sessionSampleRate) !== null && _a !== void 0 ? _a : initConfiguration.sampleRate;
  if (sessionSampleRate !== void 0 && !isPercentage(sessionSampleRate)) {
    display.error("Session Sample Rate should be a number between 0 and 100");
    return;
  }
  if (initConfiguration.telemetrySampleRate !== void 0 && !isPercentage(initConfiguration.telemetrySampleRate)) {
    display.error("Telemetry Sample Rate should be a number between 0 and 100");
    return;
  }
  if (initConfiguration.telemetryConfigurationSampleRate !== void 0 && !isPercentage(initConfiguration.telemetryConfigurationSampleRate)) {
    display.error("Telemetry Configuration Sample Rate should be a number between 0 and 100");
    return;
  }
  if (Array.isArray(initConfiguration.enableExperimentalFeatures)) {
    addExperimentalFeatures(initConfiguration.enableExperimentalFeatures.filter(function(flag) {
      return objectHasValue(ExperimentalFeature, flag);
    }));
  }
  return assign({
    beforeSend: initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, "beforeSend threw an error:"),
    sessionStoreStrategyType: selectSessionStoreStrategyType(initConfiguration),
    sessionSampleRate: sessionSampleRate !== null && sessionSampleRate !== void 0 ? sessionSampleRate : 100,
    telemetrySampleRate: (_b = initConfiguration.telemetrySampleRate) !== null && _b !== void 0 ? _b : 20,
    telemetryConfigurationSampleRate: (_c = initConfiguration.telemetryConfigurationSampleRate) !== null && _c !== void 0 ? _c : 5,
    service: initConfiguration.service,
    silentMultipleInit: !!initConfiguration.silentMultipleInit,
    /**
     * beacon payload max queue size implementation is 64kb
     * ensure that we leave room for logs, rum and potential other users
     */
    batchBytesLimit: 16 * ONE_KIBI_BYTE,
    eventRateLimiterThreshold: 3e3,
    maxTelemetryEventsPerPage: 15,
    /**
     * flush automatically, aim to be lower than ALB connection timeout
     * to maximize connection reuse.
     */
    flushTimeout: 30 * ONE_SECOND,
    /**
     * Logs intake limit
     */
    batchMessagesLimit: 50,
    messageBytesLimit: 256 * ONE_KIBI_BYTE
  }, computeTransportConfiguration(initConfiguration));
}
function serializeConfiguration(initConfiguration) {
  var _a, _b;
  var proxy = (_a = initConfiguration.proxy) !== null && _a !== void 0 ? _a : initConfiguration.proxyUrl;
  return {
    session_sample_rate: (_b = initConfiguration.sessionSampleRate) !== null && _b !== void 0 ? _b : initConfiguration.sampleRate,
    telemetry_sample_rate: initConfiguration.telemetrySampleRate,
    telemetry_configuration_sample_rate: initConfiguration.telemetryConfigurationSampleRate,
    use_before_send: !!initConfiguration.beforeSend,
    use_cross_site_session_cookie: initConfiguration.useCrossSiteSessionCookie,
    use_secure_session_cookie: initConfiguration.useSecureSessionCookie,
    use_proxy: proxy !== void 0 ? !!proxy : void 0,
    silent_multiple_init: initConfiguration.silentMultipleInit,
    track_session_across_subdomains: initConfiguration.trackSessionAcrossSubdomains,
    track_resources: initConfiguration.trackResources,
    track_long_task: initConfiguration.trackLongTasks,
    allow_fallback_to_local_storage: !!initConfiguration.allowFallbackToLocalStorage
  };
}

// ../../node_modules/@datadog/browser-core/esm/boot/init.js
function makePublicApi(stub) {
  var publicApi = assign({
    version: "4.46.0",
    // This API method is intentionally not monitored, since the only thing executed is the
    // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and
    // we don't want to interfere with the user uncaught exceptions.
    onReady: function(callback) {
      callback();
    }
  }, stub);
  Object.defineProperty(publicApi, "_setDebug", {
    get: function() {
      return setDebugMode;
    },
    enumerable: false
  });
  return publicApi;
}
function defineGlobal(global, name, api) {
  var existingGlobalVariable = global[name];
  global[name] = api;
  if (existingGlobalVariable && existingGlobalVariable.q) {
    existingGlobalVariable.q.forEach(function(fn) {
      return catchUserErrors(fn, "onReady callback threw an error:")();
    });
  }
}

// ../../node_modules/@datadog/browser-core/esm/domain/tracekit/computeStackTrace.js
var UNKNOWN_FUNCTION = "?";
function computeStackTrace(ex) {
  var stack = [];
  var stackProperty = tryToGetString(ex, "stack");
  var exString = String(ex);
  if (stackProperty && startsWith(stackProperty, exString)) {
    stackProperty = stackProperty.slice(exString.length);
  }
  if (stackProperty) {
    stackProperty.split("\n").forEach(function(line) {
      var stackFrame = parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line);
      if (stackFrame) {
        if (!stackFrame.func && stackFrame.line) {
          stackFrame.func = UNKNOWN_FUNCTION;
        }
        stack.push(stackFrame);
      }
    });
  }
  return {
    message: tryToGetString(ex, "message"),
    name: tryToGetString(ex, "name"),
    stack
  };
}
var fileUrl = "((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\w+\\.|\\/).*?)";
var filePosition = "(?::(\\d+))";
var CHROME_LINE_RE = new RegExp("^\\s*at (.*?) ?\\(".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "?\\)?\\s*$"), "i");
var CHROME_EVAL_RE = new RegExp("\\((\\S*)".concat(filePosition).concat(filePosition, "\\)"));
function parseChromeLine(line) {
  var parts = CHROME_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  var isNative = parts[2] && parts[2].indexOf("native") === 0;
  var isEval = parts[2] && parts[2].indexOf("eval") === 0;
  var submatch = CHROME_EVAL_RE.exec(parts[2]);
  if (isEval && submatch) {
    parts[2] = submatch[1];
    parts[3] = submatch[2];
    parts[4] = submatch[3];
  }
  return {
    args: isNative ? [parts[2]] : [],
    column: parts[4] ? +parts[4] : void 0,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: parts[3] ? +parts[3] : void 0,
    url: !isNative ? parts[2] : void 0
  };
}
var CHROME_ANONYMOUS_FUNCTION_RE = new RegExp("^\\s*at ?".concat(fileUrl).concat(filePosition, "?").concat(filePosition, "??\\s*$"), "i");
function parseChromeAnonymousLine(line) {
  var parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line);
  if (!parts) {
    return;
  }
  return {
    args: [],
    column: parts[3] ? +parts[3] : void 0,
    func: UNKNOWN_FUNCTION,
    line: parts[2] ? +parts[2] : void 0,
    url: parts[1]
  };
}
var WINJS_LINE_RE = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinLine(line) {
  var parts = WINJS_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  return {
    args: [],
    column: parts[4] ? +parts[4] : void 0,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: +parts[3],
    url: parts[2]
  };
}
var GECKO_LINE_RE = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var GECKO_EVAL_RE = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGeckoLine(line) {
  var parts = GECKO_LINE_RE.exec(line);
  if (!parts) {
    return;
  }
  var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
  var submatch = GECKO_EVAL_RE.exec(parts[3]);
  if (isEval && submatch) {
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = void 0;
  }
  return {
    args: parts[2] ? parts[2].split(",") : [],
    column: parts[5] ? +parts[5] : void 0,
    func: parts[1] || UNKNOWN_FUNCTION,
    line: parts[4] ? +parts[4] : void 0,
    url: parts[3]
  };
}
function tryToGetString(candidate, property) {
  if (typeof candidate !== "object" || !candidate || !(property in candidate)) {
    return void 0;
  }
  var value = candidate[property];
  return typeof value === "string" ? value : void 0;
}

// ../../node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js
function instrumentMethod(object, method, instrumentationFactory) {
  var original = object[method];
  var instrumentation = instrumentationFactory(original);
  var instrumentationWrapper = function() {
    if (typeof instrumentation !== "function") {
      return void 0;
    }
    return instrumentation.apply(this, arguments);
  };
  object[method] = instrumentationWrapper;
  return {
    stop: function() {
      if (object[method] === instrumentationWrapper) {
        object[method] = original;
      } else {
        instrumentation = original;
      }
    }
  };
}
function instrumentMethodAndCallOriginal(object, method, _a) {
  var before = _a.before, after = _a.after;
  return instrumentMethod(object, method, function(original) {
    return function() {
      var args = arguments;
      var result;
      if (before) {
        callMonitored(before, this, args);
      }
      if (typeof original === "function") {
        result = original.apply(this, args);
      }
      if (after) {
        callMonitored(after, this, args);
      }
      return result;
    };
  });
}
function instrumentSetter(object, property, after) {
  var originalDescriptor = Object.getOwnPropertyDescriptor(object, property);
  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {
    return { stop: noop };
  }
  var instrumentation = function(thisObject, value) {
    setTimeout(function() {
      after(thisObject, value);
    }, 0);
  };
  var instrumentationWrapper = function(value) {
    originalDescriptor.set.call(this, value);
    instrumentation(this, value);
  };
  Object.defineProperty(object, property, {
    set: instrumentationWrapper
  });
  return {
    stop: function() {
      var _a;
      if (((_a = Object.getOwnPropertyDescriptor(object, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {
        Object.defineProperty(object, property, originalDescriptor);
      } else {
        instrumentation = noop;
      }
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/domain/tracekit/tracekit.js
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\s\S]*)$/;
function startUnhandledErrorCollection(callback) {
  var stopInstrumentingOnError = instrumentOnError(callback).stop;
  var stopInstrumentingOnUnhandledRejection = instrumentUnhandledRejection(callback).stop;
  return {
    stop: function() {
      stopInstrumentingOnError();
      stopInstrumentingOnUnhandledRejection();
    }
  };
}
function instrumentOnError(callback) {
  return instrumentMethodAndCallOriginal(window, "onerror", {
    before: function(messageObj, url, line, column, errorObj) {
      var stackTrace;
      if (errorObj instanceof Error) {
        stackTrace = computeStackTrace(errorObj);
      } else {
        var stack = [{ url, column, line }];
        var _a = tryToParseMessage(messageObj), name_1 = _a.name, message = _a.message;
        stackTrace = {
          name: name_1,
          message,
          stack
        };
      }
      callback(stackTrace, errorObj !== null && errorObj !== void 0 ? errorObj : messageObj);
    }
  });
}
function tryToParseMessage(messageObj) {
  var _a;
  var name;
  var message;
  if ({}.toString.call(messageObj) === "[object String]") {
    ;
    _a = ERROR_TYPES_RE.exec(messageObj), name = _a[1], message = _a[2];
  }
  return { name, message };
}
function instrumentUnhandledRejection(callback) {
  return instrumentMethodAndCallOriginal(window, "onunhandledrejection", {
    before: function(e) {
      var reason = e.reason || "Empty reason";
      var stack = computeStackTrace(reason);
      callback(stack, reason);
    }
  });
}

// ../../node_modules/@datadog/browser-core/esm/tools/serialisation/sanitize.js
var SANITIZE_DEFAULT_MAX_CHARACTER_COUNT = 220 * ONE_KIBI_BYTE;
var JSON_PATH_ROOT_ELEMENT = "$";
var KEY_DECORATION_LENGTH = 3;
function sanitize(source, maxCharacterCount) {
  var _a;
  if (maxCharacterCount === void 0) {
    maxCharacterCount = SANITIZE_DEFAULT_MAX_CHARACTER_COUNT;
  }
  var restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype);
  var restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype);
  var containerQueue = [];
  var visitedObjectsWithPath = /* @__PURE__ */ new WeakMap();
  var sanitizedData = sanitizeProcessor(source, JSON_PATH_ROOT_ELEMENT, void 0, containerQueue, visitedObjectsWithPath);
  var accumulatedCharacterCount = ((_a = JSON.stringify(sanitizedData)) === null || _a === void 0 ? void 0 : _a.length) || 0;
  if (accumulatedCharacterCount > maxCharacterCount) {
    warnOverCharacterLimit(maxCharacterCount, "discarded", source);
    return void 0;
  }
  while (containerQueue.length > 0 && accumulatedCharacterCount < maxCharacterCount) {
    var containerToProcess = containerQueue.shift();
    var separatorLength = 0;
    if (Array.isArray(containerToProcess.source)) {
      for (var key = 0; key < containerToProcess.source.length; key++) {
        var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
        if (targetData !== void 0) {
          accumulatedCharacterCount += JSON.stringify(targetData).length;
        } else {
          accumulatedCharacterCount += 4;
        }
        accumulatedCharacterCount += separatorLength;
        separatorLength = 1;
        if (accumulatedCharacterCount > maxCharacterCount) {
          warnOverCharacterLimit(maxCharacterCount, "truncated", source);
          break;
        }
        ;
        containerToProcess.target[key] = targetData;
      }
    } else {
      for (var key in containerToProcess.source) {
        if (Object.prototype.hasOwnProperty.call(containerToProcess.source, key)) {
          var targetData = sanitizeProcessor(containerToProcess.source[key], containerToProcess.path, key, containerQueue, visitedObjectsWithPath);
          if (targetData !== void 0) {
            accumulatedCharacterCount += JSON.stringify(targetData).length + separatorLength + key.length + KEY_DECORATION_LENGTH;
            separatorLength = 1;
          }
          if (accumulatedCharacterCount > maxCharacterCount) {
            warnOverCharacterLimit(maxCharacterCount, "truncated", source);
            break;
          }
          ;
          containerToProcess.target[key] = targetData;
        }
      }
    }
  }
  restoreObjectPrototypeToJson();
  restoreArrayPrototypeToJson();
  return sanitizedData;
}
function sanitizeProcessor(source, parentPath, key, queue, visitedObjectsWithPath) {
  var sourceToSanitize = tryToApplyToJSON(source);
  if (!sourceToSanitize || typeof sourceToSanitize !== "object") {
    return sanitizePrimitivesAndFunctions(sourceToSanitize);
  }
  var sanitizedSource = sanitizeObjects(sourceToSanitize);
  if (sanitizedSource !== "[Object]" && sanitizedSource !== "[Array]" && sanitizedSource !== "[Error]") {
    return sanitizedSource;
  }
  var sourceAsObject = source;
  if (visitedObjectsWithPath.has(sourceAsObject)) {
    return "[Reference seen at ".concat(visitedObjectsWithPath.get(sourceAsObject), "]");
  }
  var currentPath = key !== void 0 ? "".concat(parentPath, ".").concat(key) : parentPath;
  var target = Array.isArray(sourceToSanitize) ? [] : {};
  visitedObjectsWithPath.set(sourceAsObject, currentPath);
  queue.push({ source: sourceToSanitize, target, path: currentPath });
  return target;
}
function sanitizePrimitivesAndFunctions(value) {
  if (typeof value === "bigint") {
    return "[BigInt] ".concat(value.toString());
  }
  if (typeof value === "function") {
    return "[Function] ".concat(value.name || "unknown");
  }
  if (typeof value === "symbol") {
    return "[Symbol] ".concat(value.description || value.toString());
  }
  return value;
}
function sanitizeObjects(value) {
  try {
    if (value instanceof Event) {
      return {
        isTrusted: value.isTrusted
      };
    }
    var result = Object.prototype.toString.call(value);
    var match = result.match(/\[object (.*)\]/);
    if (match && match[1]) {
      return "[".concat(match[1], "]");
    }
  } catch (_a) {
  }
  return "[Unserializable]";
}
function tryToApplyToJSON(value) {
  var object = value;
  if (object && typeof object.toJSON === "function") {
    try {
      return object.toJSON();
    } catch (_a) {
    }
  }
  return value;
}
function warnOverCharacterLimit(maxCharacterCount, changeType, source) {
  display.warn("The data provided has been ".concat(changeType, " as it is over the limit of ").concat(maxCharacterCount, " characters:"), source);
}

// ../../node_modules/@datadog/browser-core/esm/domain/error/error.js
var NO_ERROR_STACK_PRESENT_MESSAGE = "No stack, consider using an instance of Error";
function computeRawError(_a) {
  var stackTrace = _a.stackTrace, originalError = _a.originalError, handlingStack = _a.handlingStack, startClocks = _a.startClocks, nonErrorPrefix = _a.nonErrorPrefix, source = _a.source, handling = _a.handling;
  var isErrorInstance = originalError instanceof Error;
  var message = computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError);
  var stack = hasUsableStack(isErrorInstance, stackTrace) ? toStackTraceString(stackTrace) : NO_ERROR_STACK_PRESENT_MESSAGE;
  var causes = isErrorInstance ? flattenErrorCauses(originalError, source) : void 0;
  var type = stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name;
  var fingerprint = tryToGetFingerprint(originalError);
  return {
    startClocks,
    source,
    handling,
    handlingStack,
    originalError,
    type,
    message,
    stack,
    causes,
    fingerprint
  };
}
function computeMessage(stackTrace, isErrorInstance, nonErrorPrefix, originalError) {
  return (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.message) && (stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name) ? stackTrace.message : !isErrorInstance ? "".concat(nonErrorPrefix, " ").concat(jsonStringify(sanitize(originalError))) : "Empty message";
}
function hasUsableStack(isErrorInstance, stackTrace) {
  if (stackTrace === void 0) {
    return false;
  }
  if (isErrorInstance) {
    return true;
  }
  return stackTrace.stack.length > 0 && (stackTrace.stack.length > 1 || stackTrace.stack[0].url !== void 0);
}
function tryToGetFingerprint(originalError) {
  return originalError instanceof Error && "dd_fingerprint" in originalError ? String(originalError.dd_fingerprint) : void 0;
}
function toStackTraceString(stack) {
  var result = formatErrorMessage(stack);
  stack.stack.forEach(function(frame) {
    var func = frame.func === "?" ? "<anonymous>" : frame.func;
    var args = frame.args && frame.args.length > 0 ? "(".concat(frame.args.join(", "), ")") : "";
    var line = frame.line ? ":".concat(frame.line) : "";
    var column = frame.line && frame.column ? ":".concat(frame.column) : "";
    result += "\n  at ".concat(func).concat(args, " @ ").concat(frame.url).concat(line).concat(column);
  });
  return result;
}
function getFileFromStackTraceString(stack) {
  var _a;
  return (_a = /@ (.+)/.exec(stack)) === null || _a === void 0 ? void 0 : _a[1];
}
function formatErrorMessage(stack) {
  return "".concat(stack.name || "Error", ": ").concat(stack.message);
}
function createHandlingStack() {
  var internalFramesToSkip = 2;
  var error = new Error();
  var formattedStack;
  if (!error.stack) {
    try {
      throw error;
    } catch (e) {
      noop();
    }
  }
  callMonitored(function() {
    var stackTrace = computeStackTrace(error);
    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip);
    formattedStack = toStackTraceString(stackTrace);
  });
  return formattedStack;
}
function flattenErrorCauses(error, parentSource) {
  var currentError = error;
  var causes = [];
  while ((currentError === null || currentError === void 0 ? void 0 : currentError.cause) instanceof Error && causes.length < 10) {
    var stackTrace = computeStackTrace(currentError.cause);
    causes.push({
      message: currentError.cause.message,
      source: parentSource,
      type: stackTrace === null || stackTrace === void 0 ? void 0 : stackTrace.name,
      stack: stackTrace && toStackTraceString(stackTrace)
    });
    currentError = currentError.cause;
  }
  return causes.length ? causes : void 0;
}

// ../../node_modules/@datadog/browser-core/esm/domain/error/error.types.js
var ErrorSource = {
  AGENT: "agent",
  CONSOLE: "console",
  CUSTOM: "custom",
  LOGGER: "logger",
  NETWORK: "network",
  SOURCE: "source",
  REPORT: "report"
};

// ../../node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js
function trackRuntimeError(errorObservable) {
  return startUnhandledErrorCollection(function(stackTrace, originalError) {
    errorObservable.notify(computeRawError({
      stackTrace,
      originalError,
      startClocks: clocksNow(),
      nonErrorPrefix: "Uncaught",
      source: ErrorSource.SOURCE,
      handling: "unhandled"
    }));
  });
}

// ../../node_modules/@datadog/browser-core/esm/browser/addEventListener.js
function addEventListener(eventTarget, eventName, listener, options) {
  return addEventListeners(eventTarget, [eventName], listener, options);
}
function addEventListeners(eventTarget, eventNames, listener, _a) {
  var _b = _a === void 0 ? {} : _a, once = _b.once, capture = _b.capture, passive = _b.passive;
  var wrappedListener = monitor(once ? function(event) {
    stop();
    listener(event);
  } : listener);
  var options = passive ? { capture, passive } : capture;
  var add = getZoneJsOriginalValue(eventTarget, "addEventListener");
  eventNames.forEach(function(eventName) {
    return add.call(eventTarget, eventName, wrappedListener, options);
  });
  function stop() {
    var remove = getZoneJsOriginalValue(eventTarget, "removeEventListener");
    eventNames.forEach(function(eventName) {
      return remove.call(eventTarget, eventName, wrappedListener, options);
    });
  }
  return {
    stop
  };
}

// ../../node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js
var RawReportType = {
  intervention: "intervention",
  deprecation: "deprecation",
  cspViolation: "csp_violation"
};
function initReportObservable(apis) {
  var observables = [];
  if (includes(apis, RawReportType.cspViolation)) {
    observables.push(createCspViolationReportObservable());
  }
  var reportTypes = apis.filter(function(api) {
    return api !== RawReportType.cspViolation;
  });
  if (reportTypes.length) {
    observables.push(createReportObservable(reportTypes));
  }
  return mergeObservables.apply(void 0, observables);
}
function createReportObservable(reportTypes) {
  var observable = new Observable(function() {
    if (!window.ReportingObserver) {
      return;
    }
    var handleReports = monitor(function(reports, _) {
      return reports.forEach(function(report) {
        observable.notify(buildRawReportFromReport(report));
      });
    });
    var observer = new window.ReportingObserver(handleReports, {
      types: reportTypes,
      buffered: true
    });
    observer.observe();
    return function() {
      observer.disconnect();
    };
  });
  return observable;
}
function createCspViolationReportObservable() {
  var observable = new Observable(function() {
    var stop = addEventListener(document, "securitypolicyviolation", function(event) {
      observable.notify(buildRawReportFromCspViolation(event));
    }).stop;
    return stop;
  });
  return observable;
}
function buildRawReportFromReport(_a) {
  var type = _a.type, body = _a.body;
  return {
    type,
    subtype: body.id,
    message: "".concat(type, ": ").concat(body.message),
    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber)
  };
}
function buildRawReportFromCspViolation(event) {
  var type = RawReportType.cspViolation;
  var message = "'".concat(event.blockedURI, "' blocked by '").concat(event.effectiveDirective, "' directive");
  return {
    type: RawReportType.cspViolation,
    subtype: event.effectiveDirective,
    message: "".concat(type, ": ").concat(message),
    stack: buildStack(event.effectiveDirective, event.originalPolicy ? "".concat(message, ' of the policy "').concat(safeTruncate(event.originalPolicy, 100, "..."), '"') : "no policy", event.sourceFile, event.lineNumber, event.columnNumber)
  };
}
function buildStack(name, message, sourceFile, lineNumber, columnNumber) {
  return sourceFile ? toStackTraceString({
    name,
    message,
    stack: [
      {
        func: "?",
        url: sourceFile,
        line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : void 0,
        column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : void 0
      }
    ]
  }) : void 0;
}

// ../../node_modules/@datadog/browser-core/esm/tools/sendToExtension.js
function sendToExtension(type, payload) {
  var callback = window.__ddBrowserSdkExtensionCallback;
  if (callback) {
    callback({ type, payload });
  }
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/typeUtils.js
function getType(value) {
  if (value === null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "array";
  }
  return typeof value;
}

// ../../node_modules/@datadog/browser-core/esm/tools/mergeInto.js
function mergeInto(destination, source, circularReferenceChecker) {
  if (circularReferenceChecker === void 0) {
    circularReferenceChecker = createCircularReferenceChecker();
  }
  if (source === void 0) {
    return destination;
  }
  if (typeof source !== "object" || source === null) {
    return source;
  } else if (source instanceof Date) {
    return new Date(source.getTime());
  } else if (source instanceof RegExp) {
    var flags = source.flags || // old browsers compatibility
    [
      source.global ? "g" : "",
      source.ignoreCase ? "i" : "",
      source.multiline ? "m" : "",
      source.sticky ? "y" : "",
      source.unicode ? "u" : ""
    ].join("");
    return new RegExp(source.source, flags);
  }
  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {
    return void 0;
  } else if (Array.isArray(source)) {
    var merged_1 = Array.isArray(destination) ? destination : [];
    for (var i = 0; i < source.length; ++i) {
      merged_1[i] = mergeInto(merged_1[i], source[i], circularReferenceChecker);
    }
    return merged_1;
  }
  var merged = getType(destination) === "object" ? destination : {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);
    }
  }
  return merged;
}
function deepClone(value) {
  return mergeInto(void 0, value);
}
function combine() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var destination;
  for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
    var source = sources_1[_a];
    if (source === void 0 || source === null) {
      continue;
    }
    destination = mergeInto(destination, source);
  }
  return destination;
}
function createCircularReferenceChecker() {
  if (typeof WeakSet !== "undefined") {
    var set_1 = /* @__PURE__ */ new WeakSet();
    return {
      hasAlreadyBeenSeen: function(value) {
        var has = set_1.has(value);
        if (!has) {
          set_1.add(value);
        }
        return has;
      }
    };
  }
  var array = [];
  return {
    hasAlreadyBeenSeen: function(value) {
      var has = array.indexOf(value) >= 0;
      if (!has) {
        array.push(value);
      }
      return has;
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js
var TelemetryType = {
  log: "log",
  configuration: "configuration"
};

// ../../node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js
var ALLOWED_FRAME_URLS = [
  "https://www.datadoghq-browser-agent.com",
  "https://www.datad0g-browser-agent.com",
  "https://d3uc069fcn7uxw.cloudfront.net",
  "https://d20xtzwzcl0ceb.cloudfront.net",
  "http://localhost",
  "<anonymous>"
];
var TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];
var telemetryConfiguration = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false };
var onRawTelemetryEventCollected;
function startTelemetry(telemetryService, configuration) {
  var contextProvider;
  var observable = new Observable();
  telemetryConfiguration.telemetryEnabled = !includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && performDraw(configuration.telemetrySampleRate);
  telemetryConfiguration.telemetryConfigurationEnabled = telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate);
  onRawTelemetryEventCollected = function(rawEvent) {
    if (telemetryConfiguration.telemetryEnabled) {
      var event_1 = toTelemetryEvent(telemetryService, rawEvent);
      observable.notify(event_1);
      sendToExtension("telemetry", event_1);
    }
  };
  startMonitorErrorCollection(addTelemetryError);
  assign(telemetryConfiguration, {
    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,
    sentEventCount: 0
  });
  function toTelemetryEvent(telemetryService2, event) {
    return combine({
      type: "telemetry",
      date: timeStampNow(),
      service: telemetryService2,
      version: "4.46.0",
      source: "browser",
      _dd: {
        format_version: 2
      },
      telemetry: event,
      experimental_features: arrayFrom(getExperimentalFeatures())
    }, contextProvider !== void 0 ? contextProvider() : {});
  }
  return {
    setContextProvider: function(provider) {
      contextProvider = provider;
    },
    observable,
    enabled: telemetryConfiguration.telemetryEnabled
  };
}
function isTelemetryReplicationAllowed(configuration) {
  return configuration.site === INTAKE_SITE_STAGING;
}
function addTelemetryDebug(message, context) {
  displayIfDebugEnabled(ConsoleApiName.debug, message, context);
  addTelemetry(assign({
    type: TelemetryType.log,
    message,
    status: "debug"
  }, context));
}
function addTelemetryError(e, context) {
  addTelemetry(assign({
    type: TelemetryType.log,
    status: "error"
  }, formatError(e), context));
}
function addTelemetryConfiguration(configuration) {
  if (telemetryConfiguration.telemetryConfigurationEnabled) {
    addTelemetry({
      type: TelemetryType.configuration,
      configuration
    });
  }
}
function addTelemetry(event) {
  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {
    telemetryConfiguration.sentEventCount += 1;
    onRawTelemetryEventCollected(event);
  }
}
function formatError(e) {
  if (e instanceof Error) {
    var stackTrace = computeStackTrace(e);
    return {
      error: {
        kind: stackTrace.name,
        stack: toStackTraceString(scrubCustomerFrames(stackTrace))
      },
      message: stackTrace.message
    };
  }
  return {
    error: {
      stack: NO_ERROR_STACK_PRESENT_MESSAGE
    },
    message: "".concat("Uncaught", " ").concat(jsonStringify(e))
  };
}
function scrubCustomerFrames(stackTrace) {
  stackTrace.stack = stackTrace.stack.filter(function(frame) {
    return !frame.url || ALLOWED_FRAME_URLS.some(function(allowedFrameUrl) {
      return startsWith(frame.url, allowedFrameUrl);
    });
  });
  return stackTrace;
}

// ../../node_modules/@datadog/browser-core/esm/tools/valueHistory.js
var END_OF_TIMES = Infinity;
var CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;
var ValueHistory = (
  /** @class */
  function() {
    function ValueHistory2(expireDelay, maxEntries) {
      var _this = this;
      this.expireDelay = expireDelay;
      this.maxEntries = maxEntries;
      this.entries = [];
      this.clearOldValuesInterval = setInterval(function() {
        return _this.clearOldValues();
      }, CLEAR_OLD_VALUES_INTERVAL);
    }
    ValueHistory2.prototype.add = function(value, startTime) {
      var _this = this;
      var entry = {
        value,
        startTime,
        endTime: END_OF_TIMES,
        remove: function() {
          var index = _this.entries.indexOf(entry);
          if (index >= 0) {
            _this.entries.splice(index, 1);
          }
        },
        close: function(endTime) {
          entry.endTime = endTime;
        }
      };
      if (this.maxEntries && this.entries.length >= this.maxEntries) {
        this.entries.pop();
      }
      this.entries.unshift(entry);
      return entry;
    };
    ValueHistory2.prototype.find = function(startTime) {
      if (startTime === void 0) {
        startTime = END_OF_TIMES;
      }
      for (var _i = 0, _a = this.entries; _i < _a.length; _i++) {
        var entry = _a[_i];
        if (entry.startTime <= startTime) {
          if (startTime <= entry.endTime) {
            return entry.value;
          }
          break;
        }
      }
    };
    ValueHistory2.prototype.closeActive = function(endTime) {
      var latestEntry = this.entries[0];
      if (latestEntry && latestEntry.endTime === END_OF_TIMES) {
        latestEntry.close(endTime);
      }
    };
    ValueHistory2.prototype.findAll = function(startTime, duration) {
      if (startTime === void 0) {
        startTime = END_OF_TIMES;
      }
      if (duration === void 0) {
        duration = 0;
      }
      var endTime = addDuration(startTime, duration);
      return this.entries.filter(function(entry) {
        return entry.startTime <= endTime && startTime <= entry.endTime;
      }).map(function(entry) {
        return entry.value;
      });
    };
    ValueHistory2.prototype.reset = function() {
      this.entries = [];
    };
    ValueHistory2.prototype.stop = function() {
      clearInterval(this.clearOldValuesInterval);
    };
    ValueHistory2.prototype.clearOldValues = function() {
      var oldTimeThreshold = relativeNow() - this.expireDelay;
      while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {
        this.entries.pop();
      }
    };
    return ValueHistory2;
  }()
);

// ../../node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js
var VISIBILITY_CHECK_DELAY = ONE_MINUTE;
var SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;
var stopCallbacks = [];
function startSessionManager(sessionStoreStrategyType, productKey, computeSessionState) {
  var sessionStore = startSessionStore(sessionStoreStrategyType, productKey, computeSessionState);
  stopCallbacks.push(function() {
    return sessionStore.stop();
  });
  var sessionContextHistory = new ValueHistory(SESSION_CONTEXT_TIMEOUT_DELAY);
  stopCallbacks.push(function() {
    return sessionContextHistory.stop();
  });
  sessionStore.renewObservable.subscribe(function() {
    sessionContextHistory.add(buildSessionContext(), relativeNow());
  });
  sessionStore.expireObservable.subscribe(function() {
    sessionContextHistory.closeActive(relativeNow());
  });
  sessionStore.expandOrRenewSession();
  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);
  trackActivity(function() {
    return sessionStore.expandOrRenewSession();
  });
  trackVisibility(function() {
    return sessionStore.expandSession();
  });
  function buildSessionContext() {
    return {
      id: sessionStore.getSession().id,
      trackingType: sessionStore.getSession()[productKey]
    };
  }
  return {
    findActiveSession: function(startTime) {
      return sessionContextHistory.find(startTime);
    },
    renewObservable: sessionStore.renewObservable,
    expireObservable: sessionStore.expireObservable,
    expire: sessionStore.expire
  };
}
function trackActivity(expandOrRenewSession) {
  var stop = addEventListeners(window, [
    "click",
    "touchstart",
    "keydown",
    "scroll"
    /* DOM_EVENT.SCROLL */
  ], expandOrRenewSession, { capture: true, passive: true }).stop;
  stopCallbacks.push(stop);
}
function trackVisibility(expandSession) {
  var expandSessionWhenVisible = function() {
    if (document.visibilityState === "visible") {
      expandSession();
    }
  };
  var stop = addEventListener(document, "visibilitychange", expandSessionWhenVisible).stop;
  stopCallbacks.push(stop);
  var visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);
  stopCallbacks.push(function() {
    clearInterval(visibilityCheckInterval);
  });
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js
function isServerError(status) {
  return status >= 500;
}
function tryToClone(response) {
  try {
    return response.clone();
  } catch (e) {
    return;
  }
}

// ../../node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js
var MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;
var MAX_ONGOING_REQUESTS = 32;
var MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE;
var MAX_BACKOFF_TIME = ONE_MINUTE;
var INITIAL_BACKOFF_TIME = ONE_SECOND;
function sendWithRetryStrategy(payload, state, sendStrategy, endpointType, reportError) {
  if (state.transportStatus === 0 && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {
    send(payload, state, sendStrategy, {
      onSuccess: function() {
        return retryQueuedPayloads(0, state, sendStrategy, endpointType, reportError);
      },
      onFailure: function() {
        state.queuedPayloads.enqueue(payload);
        scheduleRetry(state, sendStrategy, endpointType, reportError);
      }
    });
  } else {
    state.queuedPayloads.enqueue(payload);
  }
}
function scheduleRetry(state, sendStrategy, endpointType, reportError) {
  if (state.transportStatus !== 2) {
    return;
  }
  setTimeout(function() {
    var payload = state.queuedPayloads.first();
    send(payload, state, sendStrategy, {
      onSuccess: function() {
        state.queuedPayloads.dequeue();
        state.currentBackoffTime = INITIAL_BACKOFF_TIME;
        retryQueuedPayloads(1, state, sendStrategy, endpointType, reportError);
      },
      onFailure: function() {
        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);
        scheduleRetry(state, sendStrategy, endpointType, reportError);
      }
    });
  }, state.currentBackoffTime);
}
function send(payload, state, sendStrategy, _a) {
  var onSuccess = _a.onSuccess, onFailure = _a.onFailure;
  state.bandwidthMonitor.add(payload);
  sendStrategy(payload, function(response) {
    state.bandwidthMonitor.remove(payload);
    if (!shouldRetryRequest(response)) {
      state.transportStatus = 0;
      onSuccess();
    } else {
      state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 : 2;
      payload.retry = {
        count: payload.retry ? payload.retry.count + 1 : 1,
        lastFailureStatus: response.status
      };
      onFailure();
    }
  });
}
function retryQueuedPayloads(reason, state, sendStrategy, endpointType, reportError) {
  if (reason === 0 && state.queuedPayloads.isFull() && !state.queueFullReported) {
    reportError({
      message: "Reached max ".concat(endpointType, " events size queued for upload: ").concat(MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE, "MiB"),
      source: ErrorSource.AGENT,
      startClocks: clocksNow()
    });
    state.queueFullReported = true;
  }
  var previousQueue = state.queuedPayloads;
  state.queuedPayloads = newPayloadQueue();
  while (previousQueue.size() > 0) {
    sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, endpointType, reportError);
  }
}
function shouldRetryRequest(response) {
  return response.type !== "opaque" && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || isServerError(response.status));
}
function newRetryState() {
  return {
    transportStatus: 0,
    currentBackoffTime: INITIAL_BACKOFF_TIME,
    bandwidthMonitor: newBandwidthMonitor(),
    queuedPayloads: newPayloadQueue(),
    queueFullReported: false
  };
}
function newPayloadQueue() {
  var queue = [];
  return {
    bytesCount: 0,
    enqueue: function(payload) {
      if (this.isFull()) {
        return;
      }
      queue.push(payload);
      this.bytesCount += payload.bytesCount;
    },
    first: function() {
      return queue[0];
    },
    dequeue: function() {
      var payload = queue.shift();
      if (payload) {
        this.bytesCount -= payload.bytesCount;
      }
      return payload;
    },
    size: function() {
      return queue.length;
    },
    isFull: function() {
      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;
    }
  };
}
function newBandwidthMonitor() {
  return {
    ongoingRequestCount: 0,
    ongoingByteCount: 0,
    canHandle: function(payload) {
      return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;
    },
    add: function(payload) {
      this.ongoingRequestCount += 1;
      this.ongoingByteCount += payload.bytesCount;
    },
    remove: function(payload) {
      this.ongoingRequestCount -= 1;
      this.ongoingByteCount -= payload.bytesCount;
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/transport/httpRequest.js
function createHttpRequest(endpointBuilder, bytesLimit, reportError) {
  var retryState = newRetryState();
  var sendStrategyForRetry = function(payload, onResponse) {
    return fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);
  };
  return {
    send: function(payload) {
      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError);
    },
    /**
     * Since fetch keepalive behaves like regular fetch on Firefox,
     * keep using sendBeaconStrategy on exit
     */
    sendOnExit: function(payload) {
      sendBeaconStrategy(endpointBuilder, bytesLimit, payload);
    }
  };
}
function sendBeaconStrategy(endpointBuilder, bytesLimit, _a) {
  var data = _a.data, bytesCount = _a.bytesCount, flushReason = _a.flushReason;
  var canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit;
  if (canUseBeacon) {
    try {
      var beaconUrl = endpointBuilder.build("beacon", flushReason);
      var isQueued = navigator.sendBeacon(beaconUrl, data);
      if (isQueued) {
        return;
      }
    } catch (e) {
      reportBeaconError(e);
    }
  }
  var xhrUrl = endpointBuilder.build("xhr", flushReason);
  sendXHR(xhrUrl, data);
}
var hasReportedBeaconError = false;
function reportBeaconError(e) {
  if (!hasReportedBeaconError) {
    hasReportedBeaconError = true;
    addTelemetryError(e);
  }
}
function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, _a, onResponse) {
  var data = _a.data, bytesCount = _a.bytesCount, flushReason = _a.flushReason, retry = _a.retry;
  var canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit;
  if (canUseKeepAlive) {
    var fetchUrl = endpointBuilder.build("fetch", flushReason, retry);
    fetch(fetchUrl, { method: "POST", body: data, keepalive: true, mode: "cors" }).then(monitor(function(response) {
      return onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type });
    }), monitor(function() {
      var xhrUrl2 = endpointBuilder.build("xhr", flushReason, retry);
      sendXHR(xhrUrl2, data, onResponse);
    }));
  } else {
    var xhrUrl = endpointBuilder.build("xhr", flushReason, retry);
    sendXHR(xhrUrl, data, onResponse);
  }
}
function isKeepAliveSupported() {
  try {
    return window.Request && "keepalive" in new Request("http://a");
  } catch (_a) {
    return false;
  }
}
function sendXHR(url, data, onResponse) {
  var request = new XMLHttpRequest();
  request.open("POST", url, true);
  addEventListener(request, "loadend", function() {
    onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: request.status });
  }, {
    // prevent multiple onResponse callbacks
    // if the xhr instance is reused by a third party
    once: true
  });
  request.send(data);
}

// ../../node_modules/@datadog/browser-core/esm/browser/pageExitObservable.js
var PageExitReason = {
  HIDDEN: "visibility_hidden",
  UNLOADING: "before_unload",
  PAGEHIDE: "page_hide",
  FROZEN: "page_frozen"
};
function createPageExitObservable() {
  var observable = new Observable(function() {
    var pagehideEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGEHIDE);
    var stopListeners = addEventListeners(window, [
      "visibilitychange",
      "freeze",
      "pagehide"
      /* DOM_EVENT.PAGE_HIDE */
    ], function(event) {
      if (event.type === "pagehide" && pagehideEnabled) {
        observable.notify({ reason: PageExitReason.PAGEHIDE });
      } else if (event.type === "visibilitychange" && document.visibilityState === "hidden") {
        observable.notify({ reason: PageExitReason.HIDDEN });
      } else if (event.type === "freeze") {
        observable.notify({ reason: PageExitReason.FROZEN });
      }
    }, { capture: true }).stop;
    var stopBeforeUnloadListener = noop;
    if (!pagehideEnabled) {
      stopBeforeUnloadListener = addEventListener(window, "beforeunload", function() {
        observable.notify({ reason: PageExitReason.UNLOADING });
      }).stop;
    }
    return function() {
      stopListeners();
      stopBeforeUnloadListener();
    };
  });
  return observable;
}
function isPageExitReason(reason) {
  return includes(objectValues(PageExitReason), reason);
}

// ../../node_modules/@datadog/browser-core/esm/transport/batch.js
var Batch = (
  /** @class */
  function() {
    function Batch2(request, flushController, messageBytesLimit) {
      var _this = this;
      this.request = request;
      this.flushController = flushController;
      this.messageBytesLimit = messageBytesLimit;
      this.pushOnlyBuffer = [];
      this.upsertBuffer = {};
      this.flushController.flushObservable.subscribe(function(event) {
        return _this.flush(event);
      });
    }
    Batch2.prototype.add = function(message) {
      this.addOrUpdate(message);
    };
    Batch2.prototype.upsert = function(message, key) {
      this.addOrUpdate(message, key);
    };
    Batch2.prototype.flush = function(event) {
      var messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer));
      this.pushOnlyBuffer = [];
      this.upsertBuffer = {};
      var payload = { data: messages.join("\n"), bytesCount: event.bytesCount, flushReason: event.reason };
      if (isPageExitReason(event.reason)) {
        this.request.sendOnExit(payload);
      } else {
        this.request.send(payload);
      }
    };
    Batch2.prototype.addOrUpdate = function(message, key) {
      var _a = this.process(message), processedMessage = _a.processedMessage, messageBytesCount = _a.messageBytesCount;
      if (messageBytesCount >= this.messageBytesLimit) {
        display.warn("Discarded a message whose size was bigger than the maximum allowed size ".concat(this.messageBytesLimit, "KB."));
        return;
      }
      if (this.hasMessageFor(key)) {
        this.remove(key);
      }
      this.push(processedMessage, messageBytesCount, key);
    };
    Batch2.prototype.process = function(message) {
      var processedMessage = jsonStringify(message);
      var messageBytesCount = computeBytesCount(processedMessage);
      return { processedMessage, messageBytesCount };
    };
    Batch2.prototype.push = function(processedMessage, messageBytesCount, key) {
      var separatorBytesCount = this.flushController.messagesCount > 0 ? 1 : 0;
      this.flushController.notifyBeforeAddMessage(messageBytesCount + separatorBytesCount);
      if (key !== void 0) {
        this.upsertBuffer[key] = processedMessage;
      } else {
        this.pushOnlyBuffer.push(processedMessage);
      }
      this.flushController.notifyAfterAddMessage();
    };
    Batch2.prototype.remove = function(key) {
      var removedMessage = this.upsertBuffer[key];
      delete this.upsertBuffer[key];
      var messageBytesCount = computeBytesCount(removedMessage);
      var separatorBytesCount = this.flushController.messagesCount > 1 ? 1 : 0;
      this.flushController.notifyAfterRemoveMessage(messageBytesCount + separatorBytesCount);
    };
    Batch2.prototype.hasMessageFor = function(key) {
      return key !== void 0 && this.upsertBuffer[key] !== void 0;
    };
    return Batch2;
  }()
);

// ../../node_modules/@datadog/browser-core/esm/transport/eventBridge.js
function getEventBridge() {
  var eventBridgeGlobal = getEventBridgeGlobal();
  if (!eventBridgeGlobal) {
    return;
  }
  return {
    getAllowedWebViewHosts: function() {
      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());
    },
    send: function(eventType, event) {
      eventBridgeGlobal.send(JSON.stringify({ eventType, event }));
    }
  };
}
function canUseEventBridge(currentHost) {
  var _a;
  if (currentHost === void 0) {
    currentHost = (_a = getGlobalObject().location) === null || _a === void 0 ? void 0 : _a.hostname;
  }
  var bridge = getEventBridge();
  return !!bridge && bridge.getAllowedWebViewHosts().some(function(allowedHost) {
    return currentHost === allowedHost || endsWith(currentHost, ".".concat(allowedHost));
  });
}
function getEventBridgeGlobal() {
  return getGlobalObject().DatadogEventBridge;
}

// ../../node_modules/@datadog/browser-core/esm/transport/flushController.js
function createFlushController(_a) {
  var messagesLimit = _a.messagesLimit, bytesLimit = _a.bytesLimit, durationLimit = _a.durationLimit, pageExitObservable = _a.pageExitObservable, sessionExpireObservable = _a.sessionExpireObservable;
  var flushObservable = new Observable();
  pageExitObservable.subscribe(function(event) {
    return flush(event.reason);
  });
  sessionExpireObservable.subscribe(function() {
    return flush("session_expire");
  });
  var currentBytesCount = 0;
  var currentMessagesCount = 0;
  function flush(flushReason) {
    if (currentMessagesCount === 0) {
      return;
    }
    var messagesCount = currentMessagesCount;
    var bytesCount = currentBytesCount;
    currentMessagesCount = 0;
    currentBytesCount = 0;
    cancelDurationLimitTimeout();
    flushObservable.notify({
      reason: flushReason,
      messagesCount,
      bytesCount
    });
  }
  var durationLimitTimeoutId;
  function scheduleDurationLimitTimeout() {
    if (durationLimitTimeoutId === void 0) {
      durationLimitTimeoutId = setTimeout(function() {
        flush("duration_limit");
      }, durationLimit);
    }
  }
  function cancelDurationLimitTimeout() {
    clearTimeout(durationLimitTimeoutId);
    durationLimitTimeoutId = void 0;
  }
  return {
    flushObservable,
    get messagesCount() {
      return currentMessagesCount;
    },
    /**
     * Notifies that a message will be added to a pool of pending messages waiting to be flushed.
     *
     * This function needs to be called synchronously, right before adding the message, so no flush
     * event can happen after `notifyBeforeAddMessage` and before adding the message.
     */
    notifyBeforeAddMessage: function(messageBytesCount) {
      if (currentBytesCount + messageBytesCount >= bytesLimit) {
        flush("bytes_limit");
      }
      currentMessagesCount += 1;
      currentBytesCount += messageBytesCount;
      scheduleDurationLimitTimeout();
    },
    /**
     * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.
     *
     * This function can be called asynchronously after the message was added, but in this case it
     * should not be called if a flush event occurred in between.
     */
    notifyAfterAddMessage: function() {
      if (currentMessagesCount >= messagesLimit) {
        flush("messages_limit");
      } else if (currentBytesCount >= bytesLimit) {
        flush("bytes_limit");
      }
    },
    /**
     * Notifies that a message was removed from a pool of pending messages waiting to be flushed.
     *
     * This function needs to be called synchronously, right after removing the message, so no flush
     * event can happen after removing the message and before `notifyAfterRemoveMessage`.
     */
    notifyAfterRemoveMessage: function(messageBytesCount) {
      currentBytesCount -= messageBytesCount;
      currentMessagesCount -= 1;
      if (currentMessagesCount === 0) {
        cancelDurationLimitTimeout();
      }
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/transport/startBatchWithReplica.js
function startBatchWithReplica(configuration, endpoint, reportError, pageExitObservable, sessionExpireObservable, replicaEndpoint) {
  var primaryBatch = createBatch(endpoint);
  var replicaBatch;
  if (replicaEndpoint) {
    replicaBatch = createBatch(replicaEndpoint);
  }
  function createBatch(endpointBuilder) {
    return new Batch(createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError), createFlushController({
      messagesLimit: configuration.batchMessagesLimit,
      bytesLimit: configuration.batchBytesLimit,
      durationLimit: configuration.flushTimeout,
      pageExitObservable,
      sessionExpireObservable
    }), configuration.messageBytesLimit);
  }
  return {
    add: function(message, replicated) {
      if (replicated === void 0) {
        replicated = true;
      }
      primaryBatch.add(message);
      if (replicaBatch && replicated) {
        replicaBatch.add(message);
      }
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js
function removeDuplicates(array) {
  var set = /* @__PURE__ */ new Set();
  array.forEach(function(item) {
    return set.add(item);
  });
  return arrayFrom(set);
}

// ../../node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js
var AbstractLifeCycle = (
  /** @class */
  function() {
    function AbstractLifeCycle2() {
      this.callbacks = {};
    }
    AbstractLifeCycle2.prototype.notify = function(eventType, data) {
      var eventCallbacks = this.callbacks[eventType];
      if (eventCallbacks) {
        eventCallbacks.forEach(function(callback) {
          return callback(data);
        });
      }
    };
    AbstractLifeCycle2.prototype.subscribe = function(eventType, callback) {
      var _this = this;
      if (!this.callbacks[eventType]) {
        this.callbacks[eventType] = [];
      }
      this.callbacks[eventType].push(callback);
      return {
        unsubscribe: function() {
          _this.callbacks[eventType] = _this.callbacks[eventType].filter(function(other) {
            return callback !== other;
          });
        }
      };
    };
    return AbstractLifeCycle2;
  }()
);

// ../../node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js
function createEventRateLimiter(eventType, limit, onLimitReached) {
  var eventCount = 0;
  var allowNextEvent = false;
  return {
    isLimitReached: function() {
      if (eventCount === 0) {
        setTimeout(function() {
          eventCount = 0;
        }, ONE_MINUTE);
      }
      eventCount += 1;
      if (eventCount <= limit || allowNextEvent) {
        allowNextEvent = false;
        return false;
      }
      if (eventCount === limit + 1) {
        allowNextEvent = true;
        try {
          onLimitReached({
            message: "Reached max number of ".concat(eventType, "s by minute: ").concat(limit),
            source: ErrorSource.AGENT,
            startClocks: clocksNow()
          });
        } finally {
          allowNextEvent = false;
        }
      }
      return true;
    }
  };
}

// ../../node_modules/@datadog/browser-core/esm/browser/runOnReadyState.js
function runOnReadyState(expectedReadyState, callback) {
  if (document.readyState === expectedReadyState || document.readyState === "complete") {
    callback();
  } else {
    var eventName = expectedReadyState === "complete" ? "load" : "DOMContentLoaded";
    addEventListener(window, eventName, callback, { once: true });
  }
}

// ../../node_modules/@datadog/browser-core/esm/browser/xhrObservable.js
var xhrObservable;
var xhrContexts = /* @__PURE__ */ new WeakMap();
function initXhrObservable() {
  if (!xhrObservable) {
    xhrObservable = createXhrObservable();
  }
  return xhrObservable;
}
function createXhrObservable() {
  var observable = new Observable(function() {
    var stopInstrumentingStart = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "open", {
      before: openXhr
    }).stop;
    var stopInstrumentingSend = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "send", {
      before: function() {
        sendXhr.call(this, observable);
      }
    }).stop;
    var stopInstrumentingAbort = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, "abort", {
      before: abortXhr
    }).stop;
    return function() {
      stopInstrumentingStart();
      stopInstrumentingSend();
      stopInstrumentingAbort();
    };
  });
  return observable;
}
function openXhr(method, url) {
  xhrContexts.set(this, {
    state: "open",
    method,
    url: normalizeUrl(String(url))
  });
}
function sendXhr(observable) {
  var _this = this;
  var context = xhrContexts.get(this);
  if (!context) {
    return;
  }
  var startContext = context;
  startContext.state = "start";
  startContext.startTime = relativeNow();
  startContext.startClocks = clocksNow();
  startContext.isAborted = false;
  startContext.xhr = this;
  var hasBeenReported = false;
  var stopInstrumentingOnReadyStateChange = instrumentMethodAndCallOriginal(this, "onreadystatechange", {
    before: function() {
      if (this.readyState === XMLHttpRequest.DONE) {
        onEnd();
      }
    }
  }).stop;
  var onEnd = function() {
    unsubscribeLoadEndListener();
    stopInstrumentingOnReadyStateChange();
    if (hasBeenReported) {
      return;
    }
    hasBeenReported = true;
    var completeContext = context;
    completeContext.state = "complete";
    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());
    completeContext.status = _this.status;
    observable.notify(shallowClone(completeContext));
  };
  var unsubscribeLoadEndListener = addEventListener(this, "loadend", onEnd).stop;
  observable.notify(startContext);
}
function abortXhr() {
  var context = xhrContexts.get(this);
  if (context) {
    context.isAborted = true;
  }
}

// ../../node_modules/@datadog/browser-core/esm/browser/fetchObservable.js
var fetchObservable;
function initFetchObservable() {
  if (!fetchObservable) {
    fetchObservable = createFetchObservable();
  }
  return fetchObservable;
}
function createFetchObservable() {
  var observable = new Observable(function() {
    if (!window.fetch) {
      return;
    }
    var stop = instrumentMethod(window, "fetch", function(originalFetch) {
      return function(input, init) {
        var responsePromise;
        var context = callMonitored(beforeSend, null, [observable, input, init]);
        if (context) {
          responsePromise = originalFetch.call(this, context.input, context.init);
          callMonitored(afterSend, null, [observable, responsePromise, context]);
        } else {
          responsePromise = originalFetch.call(this, input, init);
        }
        return responsePromise;
      };
    }).stop;
    return stop;
  });
  return observable;
}
function beforeSend(observable, input, init) {
  var method = init && init.method || input instanceof Request && input.method || "GET";
  var url = input instanceof Request ? input.url : normalizeUrl(String(input));
  var startClocks = clocksNow();
  var context = {
    state: "start",
    init,
    input,
    method,
    startClocks,
    url
  };
  observable.notify(context);
  return context;
}
function afterSend(observable, responsePromise, startContext) {
  var reportFetch = function(response) {
    var context = startContext;
    context.state = "resolve";
    if ("stack" in response || response instanceof Error) {
      context.status = 0;
      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR;
      context.error = response;
    } else if ("status" in response) {
      context.response = response;
      context.responseType = response.type;
      context.status = response.status;
      context.isAborted = false;
    }
    observable.notify(context);
  };
  responsePromise.then(monitor(reportFetch), monitor(reportFetch));
}

// ../../node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js
var consoleObservablesByApi = {};
function initConsoleObservable(apis) {
  var consoleObservables = apis.map(function(api) {
    if (!consoleObservablesByApi[api]) {
      consoleObservablesByApi[api] = createConsoleObservable(api);
    }
    return consoleObservablesByApi[api];
  });
  return mergeObservables.apply(void 0, consoleObservables);
}
function createConsoleObservable(api) {
  var observable = new Observable(function() {
    var originalConsoleApi = globalConsole[api];
    globalConsole[api] = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      originalConsoleApi.apply(console, params);
      var handlingStack = createHandlingStack();
      callMonitored(function() {
        observable.notify(buildConsoleLog(params, api, handlingStack));
      });
    };
    return function() {
      globalConsole[api] = originalConsoleApi;
    };
  });
  return observable;
}
function buildConsoleLog(params, api, handlingStack) {
  var message = params.map(function(param) {
    return formatConsoleParameters(param);
  }).join(" ");
  var stack;
  var fingerprint;
  if (api === ConsoleApiName.error) {
    var firstErrorParam = find(params, function(param) {
      return param instanceof Error;
    });
    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : void 0;
    fingerprint = tryToGetFingerprint(firstErrorParam);
    message = "console error: ".concat(message);
  }
  return {
    api,
    message,
    stack,
    handlingStack,
    fingerprint
  };
}
function formatConsoleParameters(param) {
  if (typeof param === "string") {
    return sanitize(param);
  }
  if (param instanceof Error) {
    return formatErrorMessage(computeStackTrace(param));
  }
  return jsonStringify(sanitize(param), void 0, 2);
}

// ../../node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js
var BUFFER_LIMIT = 500;
var BoundedBuffer = (
  /** @class */
  function() {
    function BoundedBuffer2() {
      this.buffer = [];
    }
    BoundedBuffer2.prototype.add = function(callback) {
      var length = this.buffer.push(callback);
      if (length > BUFFER_LIMIT) {
        this.buffer.splice(0, 1);
      }
    };
    BoundedBuffer2.prototype.drain = function() {
      this.buffer.forEach(function(callback) {
        return callback();
      });
      this.buffer.length = 0;
    };
    return BoundedBuffer2;
  }()
);

// ../../node_modules/@datadog/browser-core/esm/tools/serialisation/heavyCustomerDataWarning.js
var CUSTOMER_DATA_BYTES_LIMIT = 3 * ONE_KIBI_BYTE;
function warnIfCustomerDataLimitReached(bytesCount, customerDataType) {
  if (bytesCount > CUSTOMER_DATA_BYTES_LIMIT) {
    display.warn("The ".concat(customerDataType, " data exceeds the recommended ").concat(CUSTOMER_DATA_BYTES_LIMIT / ONE_KIBI_BYTE, "KiB threshold. More details: https://docs.datadoghq.com/real_user_monitoring/browser/troubleshooting/#customer-data-exceeds-the-recommended-3kib-warning"));
    return true;
  }
  return false;
}

// ../../node_modules/@datadog/browser-core/esm/tools/serialisation/contextManager.js
var BYTES_COMPUTATION_THROTTLING_DELAY = 200;
function createContextManager(customerDataType, computeBytesCountImpl) {
  if (computeBytesCountImpl === void 0) {
    computeBytesCountImpl = computeBytesCount;
  }
  var context = {};
  var bytesCountCache;
  var alreadyWarned = false;
  var computeBytesCountThrottled = throttle(function(context2) {
    bytesCountCache = computeBytesCountImpl(jsonStringify(context2));
    if (!alreadyWarned) {
      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, customerDataType);
    }
  }, BYTES_COMPUTATION_THROTTLING_DELAY).throttled;
  var contextManager = {
    getBytesCount: function() {
      return bytesCountCache;
    },
    /** @deprecated use getContext instead */
    get: function() {
      return context;
    },
    /** @deprecated use setContextProperty instead */
    add: function(key, value) {
      context[key] = value;
      computeBytesCountThrottled(context);
    },
    /** @deprecated renamed to removeContextProperty */
    remove: function(key) {
      delete context[key];
      computeBytesCountThrottled(context);
    },
    /** @deprecated use setContext instead */
    set: function(newContext) {
      context = newContext;
      computeBytesCountThrottled(context);
    },
    getContext: function() {
      return deepClone(context);
    },
    setContext: function(newContext) {
      if (getType(newContext) === "object") {
        context = sanitize(newContext);
        computeBytesCountThrottled(context);
      } else {
        contextManager.clearContext();
      }
    },
    setContextProperty: function(key, property) {
      context[key] = sanitize(property);
      computeBytesCountThrottled(context);
    },
    removeContextProperty: function(key) {
      delete context[key];
      computeBytesCountThrottled(context);
    },
    clearContext: function() {
      context = {};
      bytesCountCache = 0;
    }
  };
  return contextManager;
}

// ../../node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js
function readBytesFromStream(stream, callback, options) {
  var reader = stream.getReader();
  var chunks = [];
  var readBytesCount = 0;
  readMore();
  function readMore() {
    reader.read().then(monitor(function(result) {
      if (result.done) {
        onDone();
        return;
      }
      if (options.collectStreamBody) {
        chunks.push(result.value);
      }
      readBytesCount += result.value.length;
      if (readBytesCount > options.bytesLimit) {
        onDone();
      } else {
        readMore();
      }
    }), monitor(function(error) {
      return callback(error);
    }));
  }
  function onDone() {
    reader.cancel().catch(
      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it
      // as an unhandled rejection
      noop
    );
    var bytes;
    var limitExceeded;
    if (options.collectStreamBody) {
      var completeBuffer_1;
      if (chunks.length === 1) {
        completeBuffer_1 = chunks[0];
      } else {
        completeBuffer_1 = new Uint8Array(readBytesCount);
        var offset_1 = 0;
        chunks.forEach(function(chunk) {
          completeBuffer_1.set(chunk, offset_1);
          offset_1 += chunk.length;
        });
      }
      bytes = completeBuffer_1.slice(0, options.bytesLimit);
      limitExceeded = completeBuffer_1.length > options.bytesLimit;
    }
    callback(void 0, bytes, limitExceeded);
  }
}

// ../../node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js
var SYNTHETICS_TEST_ID_COOKIE_NAME = "datadog-synthetics-public-id";
var SYNTHETICS_RESULT_ID_COOKIE_NAME = "datadog-synthetics-result-id";
var SYNTHETICS_INJECTS_RUM_COOKIE_NAME = "datadog-synthetics-injects-rum";
function willSyntheticsInjectRum() {
  return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));
}
function getSyntheticsTestId() {
  var value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);
  return typeof value === "string" ? value : void 0;
}
function getSyntheticsResultId() {
  var value = window._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);
  return typeof value === "string" ? value : void 0;
}

// ../../node_modules/@datadog/browser-core/esm/domain/user/user.js
function sanitizeUser(newUser) {
  var user = assign({}, newUser);
  var keys = ["id", "name", "email"];
  keys.forEach(function(key) {
    if (key in user) {
      user[key] = String(user[key]);
    }
  });
  return user;
}
function checkUser(newUser) {
  var isValid = getType(newUser) === "object";
  if (!isValid) {
    display.error("Unsupported user:", newUser);
  }
  return isValid;
}

// ../../node_modules/@datadog/browser-core/esm/tools/matchOption.js
function isMatchOption(item) {
  var itemType = getType(item);
  return itemType === "string" || itemType === "function" || item instanceof RegExp;
}
function matchList(list, value, useStartsWith) {
  if (useStartsWith === void 0) {
    useStartsWith = false;
  }
  return list.some(function(item) {
    try {
      if (typeof item === "function") {
        return item(value);
      } else if (item instanceof RegExp) {
        return item.test(value);
      } else if (typeof item === "string") {
        return useStartsWith ? startsWith(value, item) : item === value;
      }
    } catch (e) {
      display.error(e);
    }
    return false;
  });
}

export {
  ConsoleApiName,
  display,
  ExperimentalFeature,
  isExperimentalFeatureEnabled,
  performDraw,
  round,
  isPercentage,
  isNumber,
  ONE_SECOND,
  ONE_MINUTE,
  relativeToClocks,
  currentDrift,
  toServerDuration,
  dateNow,
  timeStampNow,
  relativeNow,
  clocksNow,
  clocksOrigin,
  elapsed,
  addDuration,
  getRelativeTime,
  looksLikeRelativeTime,
  ONE_KIBI_BYTE,
  computeBytesCount,
  concatBuffers,
  includes,
  arrayFrom,
  find,
  findLast,
  forEach,
  objectValues,
  objectEntries,
  startsWith,
  elementMatches,
  cssEscape,
  assign,
  shallowClone,
  objectHasValue,
  isEmptyObject,
  mapValues,
  getGlobalObject,
  getZoneJsOriginalValue,
  monitored,
  monitor,
  callMonitored,
  setTimeout,
  clearTimeout,
  setInterval,
  clearInterval,
  Observable,
  throttle,
  noop,
  generateUUID,
  findCommaSeparatedValue,
  safeTruncate,
  SESSION_TIME_OUT_DELAY,
  isIE,
  jsonStringify,
  isValidUrl,
  getOrigin,
  getPathName,
  buildUrl,
  INTAKE_SITE_STAGING,
  INTAKE_SITE_US1,
  INTAKE_SITE_EU1,
  DefaultPrivacyLevel,
  validateAndBuildConfiguration,
  serializeConfiguration,
  computeStackTrace,
  instrumentMethodAndCallOriginal,
  instrumentSetter,
  sanitize,
  computeRawError,
  toStackTraceString,
  getFileFromStackTraceString,
  createHandlingStack,
  ErrorSource,
  trackRuntimeError,
  makePublicApi,
  defineGlobal,
  addEventListener,
  addEventListeners,
  RawReportType,
  initReportObservable,
  sendToExtension,
  getType,
  deepClone,
  combine,
  startTelemetry,
  isTelemetryReplicationAllowed,
  addTelemetryDebug,
  addTelemetryError,
  addTelemetryConfiguration,
  ValueHistory,
  startSessionManager,
  isServerError,
  tryToClone,
  createHttpRequest,
  PageExitReason,
  createPageExitObservable,
  isPageExitReason,
  Batch,
  getEventBridge,
  canUseEventBridge,
  createFlushController,
  startBatchWithReplica,
  removeDuplicates,
  AbstractLifeCycle,
  createEventRateLimiter,
  runOnReadyState,
  initXhrObservable,
  initFetchObservable,
  initConsoleObservable,
  BoundedBuffer,
  warnIfCustomerDataLimitReached,
  createContextManager,
  readBytesFromStream,
  willSyntheticsInjectRum,
  getSyntheticsTestId,
  getSyntheticsResultId,
  sanitizeUser,
  checkUser,
  isMatchOption,
  matchList
};
//# sourceMappingURL=chunk-6AG5JEVU.js.map
