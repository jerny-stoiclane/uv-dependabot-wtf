import {
  cumsum,
  identity,
  linkHorizontal,
  max,
  min,
  select_default,
  selection_default,
  stratify_default,
  sum,
  tree_default,
  zoom_default2 as zoom_default
} from "./chunk-GTTQG4K4.js";
import "./chunk-GFT2G5UO.js";

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children = node.children, i = children && children.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children)
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
    }
  } while (next.length);
  return this;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children)
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
  }
  return this;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children)
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum2 = +value(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum2 += children[i].value;
    node.value = sum2;
  });
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children) {
  var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i, n;
  if (children == null)
    children = defaultChildren;
  while (node = nodes.pop()) {
    if (valued)
      node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d) {
  return d.children;
}
function copyData(node) {
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  sum: sum_default,
  sort: sort_default,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy
};

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/array.js
var slice = Array.prototype.slice;

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/tree.js
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else
      slice_default(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };
  return squarify;
}(phi);

// ../../node_modules/d3-flextree/node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom2(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else
          slice_default(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x) {
    return custom2((x = +x) > 1 ? x : 1);
  };
  return resquarify;
}(phi);

// ../../node_modules/d3-flextree/package.json
var package_default = {
  name: "d3-flextree",
  version: "2.1.2",
  main: "build/d3-flextree.js",
  module: "index",
  "jsnext:main": "index",
  author: {
    name: "Chris Maloney",
    url: "http://chrismaloney.org"
  },
  description: "Flexible tree layout algorithm that allows for variable node sizes.",
  keywords: [
    "d3",
    "d3-module",
    "layout",
    "tree",
    "hierarchy",
    "d3-hierarchy",
    "plugin",
    "d3-plugin",
    "infovis",
    "visualization",
    "2d"
  ],
  homepage: "https://github.com/klortho/d3-flextree",
  license: "WTFPL",
  repository: {
    type: "git",
    url: "https://github.com/klortho/d3-flextree.git"
  },
  scripts: {
    clean: "rm -rf build demo test",
    "build:demo": "rollup -c --environment BUILD:demo",
    "build:dev": "rollup -c --environment BUILD:dev",
    "build:prod": "rollup -c --environment BUILD:prod",
    "build:test": "rollup -c --environment BUILD:test",
    build: "rollup -c",
    lint: "eslint index.js src",
    "test:main": "node test/bundle.js",
    "test:browser": "node test/browser-tests.js",
    test: "npm-run-all test:*",
    prepare: "npm-run-all clean build lint test"
  },
  dependencies: {
    "d3-hierarchy": "^1.1.5"
  },
  devDependencies: {
    "babel-plugin-external-helpers": "^6.22.0",
    "babel-preset-es2015-rollup": "^3.0.0",
    d3: "^4.13.0",
    "d3-selection-multi": "^1.0.1",
    eslint: "^4.19.1",
    jsdom: "^11.6.2",
    "npm-run-all": "^4.1.2",
    rollup: "^0.55.3",
    "rollup-plugin-babel": "^2.7.1",
    "rollup-plugin-commonjs": "^8.0.2",
    "rollup-plugin-copy": "^0.2.3",
    "rollup-plugin-json": "^2.3.0",
    "rollup-plugin-node-resolve": "^3.0.2",
    "rollup-plugin-uglify": "^3.0.0",
    "uglify-es": "^3.3.9"
  }
};

// ../../node_modules/d3-flextree/src/flextree.js
var { version } = package_default;
var defaults = Object.freeze({
  children: (data) => data.children,
  nodeSize: (node) => node.data.size,
  spacing: 0
});
function flextree(options) {
  const opts = Object.assign({}, defaults, options);
  function accessor(name) {
    const opt = opts[name];
    return typeof opt === "function" ? opt : () => opt;
  }
  function layout(tree) {
    const wtree = wrap(getWrapper(), tree, (node) => node.children);
    wtree.update();
    return wtree.data;
  }
  function getFlexNode() {
    const nodeSize = accessor("nodeSize");
    const spacing = accessor("spacing");
    return class FlexNode extends hierarchy.prototype.constructor {
      constructor(data) {
        super(data);
      }
      copy() {
        const c = wrap(this.constructor, this, (node) => node.children);
        c.each((node) => node.data = node.data.data);
        return c;
      }
      get size() {
        return nodeSize(this);
      }
      spacing(oNode) {
        return spacing(this, oNode);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const ancs = this.ancestors();
        return ancs[ancs.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (acc, kid) => FlexNode.maxExtents(acc, kid.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(e0, e1) {
        return {
          top: Math.min(e0.top, e1.top),
          bottom: Math.max(e0.bottom, e1.bottom),
          left: Math.min(e0.left, e1.left),
          right: Math.max(e0.right, e1.right)
        };
      }
    };
  }
  function getWrapper() {
    const FlexNode = getFlexNode();
    const nodeSize = accessor("nodeSize");
    const spacing = accessor("spacing");
    return class extends FlexNode {
      constructor(data) {
        super(data);
        Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return nodeSize(this.data);
      }
      spacing(oNode) {
        return spacing(this.data, oNode.data);
      }
      get x() {
        return this.data.x;
      }
      set x(v) {
        this.data.x = v;
      }
      get y() {
        return this.data.y;
      }
      set y(v) {
        this.data.y = v;
      }
      update() {
        layoutChildren(this);
        resolveX(this);
        return this;
      }
    };
  }
  function wrap(FlexClass, treeData, children) {
    const _wrap = (data, parent) => {
      const node = new FlexClass(data);
      Object.assign(node, {
        parent,
        depth: parent === null ? 0 : parent.depth + 1,
        height: 0,
        length: 1
      });
      const kidsData = children(data) || [];
      node.children = kidsData.length === 0 ? null : kidsData.map((kd) => _wrap(kd, node));
      if (node.children) {
        Object.assign(node, node.children.reduce(
          (hl, kid) => ({
            height: Math.max(hl.height, kid.height + 1),
            length: hl.length + kid.length
          }),
          node
        ));
      }
      return node;
    };
    return _wrap(treeData, null);
  }
  Object.assign(layout, {
    nodeSize(arg) {
      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;
    },
    spacing(arg) {
      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;
    },
    children(arg) {
      return arguments.length ? (opts.children = arg, layout) : opts.children;
    },
    hierarchy(treeData, children) {
      const kids = typeof children === "undefined" ? opts.children : children;
      return wrap(getFlexNode(), treeData, kids);
    },
    dump(tree) {
      const nodeSize = accessor("nodeSize");
      const _dump = (i0) => (node) => {
        const i1 = i0 + "  ";
        const i2 = i0 + "    ";
        const { x, y } = node;
        const size = nodeSize(node);
        const kids = node.children || [];
        const kdumps = kids.length === 0 ? " " : `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;
        return `{ size: [${size.join(", ")}],${i1}x: ${x}, y: ${y}${kdumps}},`;
      };
      return _dump("\n")(tree);
    }
  });
  return layout;
}
flextree.version = version;
var layoutChildren = (w, y = 0) => {
  w.y = y;
  (w.children || []).reduce((acc, kid) => {
    const [i, lastLows] = acc;
    layoutChildren(kid, w.y + w.ySize);
    const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;
    if (i !== 0)
      separate(w, i, lastLows);
    const lows = updateLows(lowY, i, lastLows);
    return [i + 1, lows];
  }, [0, null]);
  shiftChange(w);
  positionRoot(w);
  return w;
};
var resolveX = (w, prevSum, parentX) => {
  if (typeof prevSum === "undefined") {
    prevSum = -w.relX - w.prelim;
    parentX = 0;
  }
  const sum2 = prevSum + w.relX;
  w.relX = sum2 + w.prelim - parentX;
  w.prelim = 0;
  w.x = parentX + w.relX;
  (w.children || []).forEach((k) => resolveX(k, sum2, w.x));
  return w;
};
var shiftChange = (w) => {
  (w.children || []).reduce((acc, child) => {
    const [lastShiftSum, lastChangeSum] = acc;
    const shiftSum = lastShiftSum + child.shift;
    const changeSum = lastChangeSum + shiftSum + child.change;
    child.relX += changeSum;
    return [shiftSum, changeSum];
  }, [0, 0]);
};
var separate = (w, i, lows) => {
  const lSib = w.children[i - 1];
  const curSubtree = w.children[i];
  let rContour = lSib;
  let rSumMods = lSib.relX;
  let lContour = curSubtree;
  let lSumMods = curSubtree.relX;
  let isFirst = true;
  while (rContour && lContour) {
    if (rContour.bottom > lows.lowY)
      lows = lows.next;
    const dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);
    if (dist > 0 || dist < 0 && isFirst) {
      lSumMods += dist;
      moveSubtree(curSubtree, dist);
      distributeExtra(w, i, lows.index, dist);
    }
    isFirst = false;
    const rightBottom = rContour.bottom;
    const leftBottom = lContour.bottom;
    if (rightBottom <= leftBottom) {
      rContour = nextRContour(rContour);
      if (rContour)
        rSumMods += rContour.relX;
    }
    if (rightBottom >= leftBottom) {
      lContour = nextLContour(lContour);
      if (lContour)
        lSumMods += lContour.relX;
    }
  }
  if (!rContour && lContour)
    setLThr(w, i, lContour, lSumMods);
  else if (rContour && !lContour)
    setRThr(w, i, rContour, rSumMods);
};
var moveSubtree = (subtree, distance) => {
  subtree.relX += distance;
  subtree.lExtRelX += distance;
  subtree.rExtRelX += distance;
};
var distributeExtra = (w, curSubtreeI, leftSibI, dist) => {
  const curSubtree = w.children[curSubtreeI];
  const n = curSubtreeI - leftSibI;
  if (n > 1) {
    const delta = dist / n;
    w.children[leftSibI + 1].shift += delta;
    curSubtree.shift -= delta;
    curSubtree.change -= dist - delta;
  }
};
var nextLContour = (w) => {
  return w.hasChildren ? w.firstChild : w.lThr;
};
var nextRContour = (w) => {
  return w.hasChildren ? w.lastChild : w.rThr;
};
var setLThr = (w, i, lContour, lSumMods) => {
  const firstChild = w.firstChild;
  const lExt = firstChild.lExt;
  const curSubtree = w.children[i];
  lExt.lThr = lContour;
  const diff = lSumMods - lContour.relX - firstChild.lExtRelX;
  lExt.relX += diff;
  lExt.prelim -= diff;
  firstChild.lExt = curSubtree.lExt;
  firstChild.lExtRelX = curSubtree.lExtRelX;
};
var setRThr = (w, i, rContour, rSumMods) => {
  const curSubtree = w.children[i];
  const rExt = curSubtree.rExt;
  const lSib = w.children[i - 1];
  rExt.rThr = rContour;
  const diff = rSumMods - rContour.relX - curSubtree.rExtRelX;
  rExt.relX += diff;
  rExt.prelim -= diff;
  curSubtree.rExt = lSib.rExt;
  curSubtree.rExtRelX = lSib.rExtRelX;
};
var positionRoot = (w) => {
  if (w.hasChildren) {
    const k0 = w.firstChild;
    const kf = w.lastChild;
    const prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;
    Object.assign(w, {
      prelim,
      lExt: k0.lExt,
      lExtRelX: k0.lExtRelX,
      rExt: kf.rExt,
      rExtRelX: kf.rExtRelX
    });
  }
};
var updateLows = (lowY, index, lastLows) => {
  while (lastLows !== null && lowY >= lastLows.lowY)
    lastLows = lastLows.next;
  return {
    lowY,
    index,
    next: lastLows
  };
};

// ../../node_modules/d3-org-chart/src/d3-org-chart.js
var d3 = {
  selection: selection_default,
  select: select_default,
  max,
  min,
  sum,
  cumsum,
  tree: tree_default,
  stratify: stratify_default,
  zoom: zoom_default,
  zoomIdentity: identity,
  linkHorizontal
};
var OrgChart = class {
  constructor() {
    const attrs = {
      id: `ID${Math.floor(Math.random() * 1e6)}`,
      // Id for event handlings
      firstDraw: true,
      svgWidth: 800,
      svgHeight: window.innerHeight - 100,
      scaleExtent: [1e-3, 20],
      container: "body",
      defaultTextFill: "#2C3E50",
      defaultFont: "Helvetica",
      ctx: document.createElement("canvas").getContext("2d"),
      data: null,
      duration: 400,
      setActiveNodeCentered: true,
      expandLevel: 1,
      compact: true,
      rootMargin: 40,
      nodeDefaultBackground: "none",
      connections: [],
      lastTransform: { x: 0, y: 0, k: 1 },
      nodeId: (d) => d.nodeId || d.id,
      parentNodeId: (d) => d.parentNodeId || d.parentId,
      backgroundColor: "none",
      zoomBehavior: null,
      defs: function(state, visibleConnections) {
        return `<defs>
                    ${visibleConnections.map((conn) => {
          const labelWidth = this.getTextWidth(conn.label, { ctx: state.ctx, fontSize: 2, defaultFont: state.defaultFont });
          return `
                       <marker id="${conn.from + "_" + conn.to}" refX="${conn._source.x < conn._target.x ? -7 : 7}" refY="5" markerWidth="500"  markerHeight="500"  orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <rect rx=0.5 width=${conn.label ? labelWidth + 3 : 0} height=3 y=1  fill="#152785"></rect>
                       <text font-size="2px" x=1 fill="white" y=3>${conn.label || ""}</text>
                       </marker>

                       <marker id="arrow-${conn.from + "_" + conn.to}"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <path transform="translate(0)" d='M0,0 V4 L2,2 Z' fill='#152785' />
                       </marker>
                    `;
        }).join("")}
                    </defs>
                    `;
      },
      connectionsUpdate: function(d, i, arr) {
        d3.select(this).attr("stroke", (d2) => "#152785").attr("stroke-linecap", "round").attr("stroke-width", (d2) => "5").attr("pointer-events", "none").attr("marker-start", (d2) => `url(#${d2.from + "_" + d2.to})`).attr("marker-end", (d2) => `url(#arrow-${d2.from + "_" + d2.to})`);
      },
      linkUpdate: function(d, i, arr) {
        d3.select(this).attr("stroke", (d2) => d2.data._upToTheRootHighlighted ? "#152785" : "lightgray").attr("stroke-width", (d2) => d2.data._upToTheRootHighlighted ? 5 : 2);
        if (d.data._upToTheRootHighlighted) {
          d3.select(this).raise();
        }
      },
      nodeUpdate: function(d, i, arr) {
        d3.select(this).select(".node-rect").attr("stroke", (d2) => d2.data._highlighted || d2.data._upToTheRootHighlighted ? "#152785" : "none").attr("stroke-width", d.data._highlighted || d.data._upToTheRootHighlighted ? 10 : 1);
      },
      nodeWidth: (d3Node) => 250,
      nodeHeight: (d) => 150,
      siblingsMargin: (d3Node) => 20,
      childrenMargin: (d) => 60,
      neightbourMargin: (n1, n2) => 80,
      compactMarginPair: (d) => 100,
      compactMarginBetween: (d3Node) => 20,
      onNodeClick: (d) => d,
      linkGroupArc: d3.linkHorizontal().x((d) => d.x).y((d) => d.y),
      // ({ source, target }) => {
      //     return 
      //     return `M ${source.x} , ${source.y} Q ${(source.x + target.x) / 2 + 100},${source.y-100}  ${target.x}, ${target.y}`;
      // },
      nodeContent: (d) => `<div style="padding:5px;font-size:10px;">Sample Node(id=${d.id}), override using <br/> <br/> 
            <code>chart<br/>
            &nbsp;.nodeContent({data}=>{ <br/>
             &nbsp;&nbsp;&nbsp;&nbsp;return '' // Custom HTML <br/>
             &nbsp;})</code>
             <br/> <br/>
             Or check different <a href="https://github.com/bumbeishvili/org-chart#jump-to-examples" target="_blank">layout examples</a>
             
             </div>`,
      layout: "top",
      // top, left,right, bottom
      buttonContent: ({ node, state }) => {
        const icons = {
          "left": (d) => d ? `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px">‹</div>` : `<div style="margin-top:-10px;font-size:25px;height:23px">›</div>`,
          "bottom": (d) => d ? `<div style="margin-top:-20px;font-size:25px">ˬ</div>` : `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px">ˆ</div>`,
          "right": (d) => d ? `<div style="margin-top:-10px;font-size:25px;height:23px">›</div>` : `<div style="margin-top:-10px;line-height:1.2;font-size:25px;height:22px">‹</div>`,
          "top": (d) => d ? `<div style="margin-top:0px;line-height:1.2;height:11px;font-size:25px">ˆ</div>` : `<div style="margin-top:-20px;font-size:25px">ˬ</div>`
        };
        return `<div style="border-radius:3px;padding:3px;font-size:10px;margin:auto auto;background-color:lightgray"> ${icons[state.layout](node.children)}  </div>`;
      },
      layoutBindings: {
        "left": {
          "nodeLeftX": (node) => 0,
          "nodeRightX": (node) => node.width,
          "nodeTopY": (node) => -node.height / 2,
          "nodeBottomY": (node) => node.height / 2,
          "nodeJoinX": (node) => node.x + node.width,
          "nodeJoinY": (node) => node.y - node.height / 2,
          "linkJoinX": (node) => node.x + node.width,
          "linkJoinY": (node) => node.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkCompactXStart": (node) => node.x + node.width / 2,
          //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
          "compactLinkMidX": (node, state) => node.firstCompactNode.x,
          // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "linkParentX": (node) => node.parent.x + node.parent.width,
          "linkParentY": (node) => node.parent.y,
          "buttonX": (node) => node.width,
          "buttonY": (node) => node.height / 2,
          "centerTransform": ({ root, rootMargin, centerY, scale, centerX }) => `translate(${rootMargin},${centerY}) scale(${scale})`,
          "compactDimension": {
            sizeColumn: (node) => node.height,
            sizeRow: (node) => node.width,
            reverse: (arr) => arr.slice().reverse()
          },
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            ;
            return [height + siblingsMargin, width + childrenMargin];
          },
          "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
          "diagonal": this.hdiagonal.bind(this),
          "swap": (d) => {
            const x = d.x;
            d.x = d.y;
            d.y = x;
          },
          "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x},${y - height / 2})`
        },
        "top": {
          "nodeLeftX": (node) => -node.width / 2,
          "nodeRightX": (node) => node.width / 2,
          "nodeTopY": (node) => 0,
          "nodeBottomY": (node) => node.height,
          "nodeJoinX": (node) => node.x - node.width / 2,
          "nodeJoinY": (node) => node.y + node.height,
          "linkJoinX": (node) => node.x,
          "linkJoinY": (node) => node.y + node.height,
          "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + node.height / 2,
          "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node) => node.firstCompactNode.y,
          "compactDimension": {
            sizeColumn: (node) => node.width,
            sizeRow: (node) => node.height,
            reverse: (arr) => arr
          },
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkParentX": (node) => node.parent.x,
          "linkParentY": (node) => node.parent.y + node.parent.height,
          "buttonX": (node) => node.width / 2,
          "buttonY": (node) => node.height,
          "centerTransform": ({ root, rootMargin, centerY, scale, centerX }) => `translate(${centerX},${rootMargin}) scale(${scale})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node, compactViewIndex }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            ;
            return [width + siblingsMargin, height + childrenMargin];
          },
          "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
          "diagonal": this.diagonal.bind(this),
          "swap": (d) => {
          },
          "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width / 2},${y})`
        },
        "bottom": {
          "nodeLeftX": (node) => -node.width / 2,
          "nodeRightX": (node) => node.width / 2,
          "nodeTopY": (node) => -node.height,
          "nodeBottomY": (node) => 0,
          "nodeJoinX": (node) => node.x - node.width / 2,
          "nodeJoinY": (node) => node.y - node.height - node.height,
          "linkJoinX": (node) => node.x,
          "linkJoinY": (node) => node.y - node.height,
          "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y - node.height / 2,
          "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node) => node.firstCompactNode.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "compactDimension": {
            sizeColumn: (node) => node.width,
            sizeRow: (node) => node.height,
            reverse: (arr) => arr
          },
          "linkParentX": (node) => node.parent.x,
          "linkParentY": (node) => node.parent.y - node.parent.height,
          "buttonX": (node) => node.width / 2,
          "buttonY": (node) => 0,
          "centerTransform": ({ root, rootMargin, centerY, scale, centerX, chartHeight }) => `translate(${centerX},${chartHeight - rootMargin}) scale(${scale})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            ;
            return [width + siblingsMargin, height + childrenMargin];
          },
          "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
          "diagonal": this.diagonal.bind(this),
          "swap": (d) => {
            d.y = -d.y;
          },
          "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width / 2},${y - height})`
        },
        "right": {
          "nodeLeftX": (node) => -node.width,
          "nodeRightX": (node) => 0,
          "nodeTopY": (node) => -node.height / 2,
          "nodeBottomY": (node) => node.height / 2,
          "nodeJoinX": (node) => node.x - node.width - node.width,
          "nodeJoinY": (node) => node.y - node.height / 2,
          "linkJoinX": (node) => node.x - node.width,
          "linkJoinY": (node) => node.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkParentX": (node) => node.parent.x - node.parent.width,
          "linkParentY": (node) => node.parent.y,
          "buttonX": (node) => 0,
          "buttonY": (node) => node.height / 2,
          "linkCompactXStart": (node) => node.x - node.width / 2,
          //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
          "compactLinkMidX": (node, state) => node.firstCompactNode.x,
          // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "centerTransform": ({ root, rootMargin, centerY, scale, centerX, chartWidth }) => `translate(${chartWidth - rootMargin},${centerY}) scale(${scale})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            ;
            return [height + siblingsMargin, width + childrenMargin];
          },
          "compactDimension": {
            sizeColumn: (node) => node.height,
            sizeRow: (node) => node.width,
            reverse: (arr) => arr.slice().reverse()
          },
          "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
          "diagonal": this.hdiagonal.bind(this),
          "swap": (d) => {
            const x = d.x;
            d.x = -d.y;
            d.y = x;
          },
          "nodeUpdateTransform": ({ x, y, width, height }) => `translate(${x - width},${y - height / 2})`
        }
      }
    };
    this.getChartState = () => attrs;
    Object.keys(attrs).forEach((key) => {
      this[key] = function(_) {
        if (!arguments.length) {
          return attrs[key];
        } else {
          attrs[key] = _;
        }
        return this;
      };
    });
    this.initializeEnterExitUpdatePattern();
  }
  initializeEnterExitUpdatePattern() {
    d3.selection.prototype.patternify = function(params) {
      var container = this;
      var selector = params.selector;
      var elementTag = params.tag;
      var data = params.data || [selector];
      var selection = container.selectAll("." + selector).data(data, (d, i) => {
        if (typeof d === "object") {
          if (d.id) {
            return d.id;
          }
        }
        return i;
      });
      selection.exit().remove();
      selection = selection.enter().append(elementTag).merge(selection);
      selection.attr("class", selector);
      return selection;
    };
  }
  // This method retrieves passed node's children IDs (including node)
  getNodeChildren({ data, children, _children }, nodeStore) {
    nodeStore.push(data);
    if (children) {
      children.forEach((d) => {
        this.getNodeChildren(d, nodeStore);
      });
    }
    if (_children) {
      _children.forEach((d) => {
        this.getNodeChildren(d, nodeStore);
      });
    }
    return nodeStore;
  }
  // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale
  initialZoom(zoomLevel) {
    const attrs = this.getChartState();
    attrs.lastTransform.k = zoomLevel;
    return this;
  }
  render() {
    const attrs = this.getChartState();
    if (!attrs.data || attrs.data.length == 0) {
      console.log("ORG CHART - Data is empty");
      return this;
    }
    const container = d3.select(attrs.container);
    const containerRect = container.node().getBoundingClientRect();
    if (containerRect.width > 0)
      attrs.svgWidth = containerRect.width;
    const calc = {
      id: `ID${Math.floor(Math.random() * 1e6)}`,
      // id for event handlings,
      chartWidth: attrs.svgWidth,
      chartHeight: attrs.svgHeight
    };
    attrs.calc = calc;
    calc.centerX = calc.chartWidth / 2;
    calc.centerY = calc.chartHeight / 2;
    if (attrs.firstDraw) {
      const behaviors = {
        zoom: null
      };
      behaviors.zoom = d3.zoom().on("zoom", (event, d) => this.zoomed(event, d)).scaleExtent(attrs.scaleExtent);
      attrs.zoomBehavior = behaviors.zoom;
    }
    attrs.flexTreeLayout = flextree({
      nodeSize: (node) => {
        const width = attrs.nodeWidth(node);
        ;
        const height = attrs.nodeHeight(node);
        const siblingsMargin = attrs.siblingsMargin(node);
        const childrenMargin = attrs.childrenMargin(node);
        return attrs.layoutBindings[attrs.layout].nodeFlexSize({
          state: attrs,
          node,
          width,
          height,
          siblingsMargin,
          childrenMargin
        });
      }
    }).spacing((nodeA, nodeB) => nodeA.parent == nodeB.parent ? 0 : attrs.neightbourMargin(nodeA, nodeB));
    this.setLayouts({ expandNodesFirst: false });
    const svg = container.patternify({
      tag: "svg",
      selector: "svg-chart-container"
    }).style("background-color", attrs.backgroundColor).attr("width", attrs.svgWidth).attr("height", attrs.svgHeight).attr("font-family", attrs.defaultFont);
    if (attrs.firstDraw) {
      svg.call(attrs.zoomBehavior).on("dblclick.zoom", null).attr("cursor", "move");
    }
    attrs.svg = svg;
    const chart = svg.patternify({
      tag: "g",
      selector: "chart"
    });
    attrs.centerG = chart.patternify({
      tag: "g",
      selector: "center-group"
    });
    attrs.linksWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "links-wrapper"
    });
    attrs.nodesWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "nodes-wrapper"
    });
    attrs.connectionsWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "connections-wrapper"
    });
    attrs.defsWrapper = svg.patternify({
      tag: "g",
      selector: "defs-wrapper"
    });
    if (attrs.firstDraw) {
      attrs.centerG.attr("transform", () => {
        return attrs.layoutBindings[attrs.layout].centerTransform({
          centerX: calc.centerX,
          centerY: calc.centerY,
          scale: attrs.lastTransform.k,
          rootMargin: attrs.rootMargin,
          root: attrs.root,
          chartHeight: calc.chartHeight,
          chartWidth: calc.chartWidth
        });
      });
    }
    attrs.chart = chart;
    this.update(attrs.root);
    d3.select(window).on(`resize.${attrs.id}`, () => {
      const containerRect2 = d3.select(attrs.container).node().getBoundingClientRect();
      attrs.svg.attr("width", containerRect2.width);
    });
    if (attrs.firstDraw) {
      attrs.firstDraw = false;
    }
    return this;
  }
  // This function can be invoked via chart.addNode API, and it adds node in tree at runtime
  addNode(obj) {
    const attrs = this.getChartState();
    const nodeFound = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) === attrs.nodeId(obj))[0];
    const parentFound = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) === attrs.parentNodeId(obj))[0];
    if (nodeFound) {
      console.log(`ORG CHART - ADD - Node with id "${attrs.nodeId(obj)}" already exists in tree`);
      return this;
    }
    if (!parentFound) {
      console.log(`ORG CHART - ADD - Parent node with id "${attrs.parentNodeId(obj)}" not found in the tree`);
      return this;
    }
    if (obj._centered && !obj._expanded)
      obj._expanded = true;
    attrs.data.push(obj);
    this.updateNodesState();
    return this;
  }
  // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime
  removeNode(nodeId) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == nodeId)[0];
    if (!node) {
      console.log(`ORG CHART - REMOVE - Node with id "${nodeId}" not found in the tree`);
      return this;
    }
    node.descendants().forEach((d) => d.data._filteredOut = true);
    const descendants = this.getNodeChildren(node, [], attrs.nodeId);
    descendants.forEach((d) => d._filtered = true);
    attrs.data = attrs.data.filter((d) => !d._filtered);
    const updateNodesState = this.updateNodesState.bind(this);
    updateNodesState();
    return this;
  }
  groupBy(array, accessor, aggegator) {
    const grouped = {};
    array.forEach((item) => {
      const key = accessor(item);
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(item);
    });
    Object.keys(grouped).forEach((key) => {
      grouped[key] = aggegator(grouped[key]);
    });
    return Object.entries(grouped);
  }
  calculateCompactFlexDimensions(root) {
    const attrs = this.getChartState();
    root.eachBefore((node) => {
      node.firstCompact = null;
      node.compactEven = null;
      node.flexCompactDim = null;
      node.firstCompactNode = null;
    });
    root.eachBefore((node) => {
      if (node.children && node.children.length > 1) {
        const compactChildren = node.children.filter((d) => !d.children);
        if (compactChildren.length < 2)
          return;
        compactChildren.forEach((child, i) => {
          if (!i)
            child.firstCompact = true;
          if (i % 2)
            child.compactEven = false;
          else
            child.compactEven = true;
          child.row = Math.floor(i / 2);
        });
        const evenMaxColumnDimension = d3.max(compactChildren.filter((d) => d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
        const oddMaxColumnDimension = d3.max(compactChildren.filter((d) => !d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
        const columnSize = Math.max(evenMaxColumnDimension, oddMaxColumnDimension) * 2;
        const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d) + attrs.compactMarginBetween(d)));
        const rowSize = d3.sum(rowsMapNew.map((v) => v[1]));
        compactChildren.forEach((node2) => {
          node2.firstCompactNode = compactChildren[0];
          if (node2.firstCompact) {
            node2.flexCompactDim = [
              columnSize + attrs.compactMarginPair(node2),
              rowSize - attrs.compactMarginBetween(node2)
            ];
          } else {
            node2.flexCompactDim = [0, 0];
          }
        });
        node.flexCompactDim = null;
      }
    });
  }
  calculateCompactFlexPositions(root) {
    const attrs = this.getChartState();
    root.eachBefore((node) => {
      if (node.children) {
        const compactChildren = node.children.filter((d) => d.flexCompactDim);
        const fch = compactChildren[0];
        if (!fch)
          return;
        compactChildren.forEach((child, i, arr) => {
          if (i == 0)
            fch.x -= fch.flexCompactDim[0] / 2;
          if (i & i % 2 - 1)
            child.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(child) / 4;
          else if (i)
            child.x = fch.x + fch.flexCompactDim[0] * 0.75 + attrs.compactMarginPair(child) / 4;
        });
        const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
        fch.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(fch) / 4;
        const offsetX = node.x - centerX;
        if (Math.abs(offsetX) < 10) {
          compactChildren.forEach((d) => d.x += offsetX);
        }
        const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d)));
        const cumSum = d3.cumsum(rowsMapNew.map((d) => d[1] + attrs.compactMarginBetween(d)));
        compactChildren.forEach((node2, i) => {
          if (node2.row) {
            node2.y = fch.y + cumSum[node2.row - 1];
          } else {
            node2.y = fch.y;
          }
        });
      }
    });
  }
  // This function basically redraws visible graph, based on nodes state
  update({ x0, y0, x = 0, y = 0, width, height }) {
    const attrs = this.getChartState();
    const calc = attrs.calc;
    if (attrs.compact) {
      this.calculateCompactFlexDimensions(attrs.root);
    }
    const treeData = attrs.flexTreeLayout(attrs.root);
    if (attrs.compact) {
      this.calculateCompactFlexPositions(attrs.root);
    }
    const nodes = treeData.descendants();
    const links = treeData.descendants().slice(1);
    nodes.forEach(attrs.layoutBindings[attrs.layout].swap);
    const connections = attrs.connections;
    const allNodesMap = {};
    attrs.allNodes.forEach((d) => allNodesMap[attrs.nodeId(d.data)] = d);
    const visibleNodesMap = {};
    nodes.forEach((d) => visibleNodesMap[attrs.nodeId(d.data)] = d);
    connections.forEach((connection) => {
      const source = allNodesMap[connection.from];
      const target = allNodesMap[connection.to];
      connection._source = source;
      connection._target = target;
    });
    const visibleConnections = connections.filter((d) => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
    const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
    const existingString = attrs.defsWrapper.html();
    if (defsString !== existingString) {
      attrs.defsWrapper.html(defsString);
    }
    const linkSelection = attrs.linksWrapper.selectAll("path.link").data(links, (d) => attrs.nodeId(d.data));
    const linkEnter = linkSelection.enter().insert("path", "g").attr("class", "link").attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
      const o = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
    });
    const linkUpdate = linkEnter.merge(linkSelection);
    linkUpdate.attr("fill", "none");
    linkUpdate.each(attrs.linkUpdate);
    linkUpdate.transition().duration(attrs.duration).attr("d", (d) => {
      const n = attrs.compact && d.flexCompactDim ? {
        x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
        y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
      } : {
        x: attrs.layoutBindings[attrs.layout].linkX(d),
        y: attrs.layoutBindings[attrs.layout].linkY(d)
      };
      const p = {
        x: attrs.layoutBindings[attrs.layout].linkParentX(d),
        y: attrs.layoutBindings[attrs.layout].linkParentY(d)
      };
      const m = attrs.compact && d.flexCompactDim ? {
        x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
        y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d)
      } : n;
      return attrs.layoutBindings[attrs.layout].diagonal(n, p, m);
    });
    const linkExit = linkSelection.exit().transition().duration(attrs.duration).attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x, y, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x, y, width, height });
      const o = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o, o);
    }).remove();
    const connectionsSel = attrs.connectionsWrapper.selectAll("path.connection").data(visibleConnections);
    const connEnter = connectionsSel.enter().insert("path", "g").attr("class", "connection").attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
      const o = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o, o);
    });
    const connUpdate = connEnter.merge(connectionsSel);
    connUpdate.attr("fill", "none");
    connUpdate.transition().duration(attrs.duration).attr("d", (d) => {
      const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
      const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
      const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
      const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
      return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } });
    });
    connUpdate.each(attrs.connectionsUpdate);
    const connExit = connectionsSel.exit().transition().duration(attrs.duration).attr("opacity", 0).remove();
    const nodesSelection = attrs.nodesWrapper.selectAll("g.node").data(nodes, ({ data }) => attrs.nodeId(data));
    const nodeEnter = nodesSelection.enter().append("g").attr("class", "node").attr("transform", (d) => {
      if (d == attrs.root)
        return `translate(${x0},${y0})`;
      const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
      const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
      return `translate(${xj},${yj})`;
    }).attr("cursor", "pointer").on("click", (event, { data }) => {
      if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
        return;
      }
      attrs.onNodeClick(attrs.nodeId(data));
    });
    nodeEnter.patternify({
      tag: "rect",
      selector: "node-rect",
      data: (d) => [d]
    });
    const nodeUpdate = nodeEnter.merge(nodesSelection).style("font", "12px sans-serif");
    const fo = nodeUpdate.patternify({
      tag: "foreignObject",
      selector: "node-foreign-object",
      data: (d) => [d]
    }).style("overflow", "visible");
    fo.patternify({
      tag: "xhtml:div",
      selector: "node-foreign-object-div",
      data: (d) => [d]
    });
    this.restyleForeignObjectElements();
    const nodeButtonGroups = nodeEnter.patternify({
      tag: "g",
      selector: "node-button-g",
      data: (d) => [d]
    }).on("click", (event, d) => this.onButtonClick(event, d)).on("keydown", (event, d) => {
      if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
        this.onButtonClick(event, d);
      }
    });
    nodeButtonGroups.patternify({
      tag: "rect",
      selector: "node-button-rect",
      data: (d) => [d]
    }).attr("opacity", 0).attr("pointer-events", "all").attr("width", 40).attr("height", 40).attr("x", -20).attr("y", -20);
    const nodeFo = nodeButtonGroups.patternify({
      tag: "foreignObject",
      selector: "node-button-foreign-object",
      data: (d) => [d]
    }).attr("width", 40).attr("height", 40).attr("x", -20).attr("y", -20).style("overflow", "visible").patternify({
      tag: "xhtml:div",
      selector: "node-button-div",
      data: (d) => [d]
    }).style("pointer-events", "none").style("display", "flex").style("width", "100%").style("height", "100%");
    nodeUpdate.transition().attr("opacity", 0).duration(attrs.duration).attr("transform", ({ x: x2, y: y2, width: width2, height: height2 }) => {
      return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x: x2, y: y2, width: width2, height: height2 });
    }).attr("opacity", 1);
    nodeUpdate.select(".node-rect").attr("width", ({ width: width2 }) => width2).attr("height", ({ height: height2 }) => height2).attr("x", ({ width: width2 }) => 0).attr("y", ({ height: height2 }) => 0).attr("cursor", "pointer").attr("rx", 3).attr("fill", attrs.nodeDefaultBackground);
    nodeUpdate.select(".node-button-g").attr("transform", ({ data, width: width2, height: height2 }) => {
      const x2 = attrs.layoutBindings[attrs.layout].buttonX({ width: width2, height: height2 });
      const y2 = attrs.layoutBindings[attrs.layout].buttonY({ width: width2, height: height2 });
      return `translate(${x2},${y2})`;
    }).attr("display", ({ data }) => {
      return data._directSubordinates > 0 ? null : "none";
    }).attr("opacity", ({ children, _children }) => {
      if (children || _children) {
        return 1;
      }
      return 0;
    });
    nodeUpdate.select(".node-button-foreign-object .node-button-div").html((node) => {
      return attrs.buttonContent({ node, state: attrs });
    });
    nodeUpdate.select(".node-button-text").attr("text-anchor", "middle").attr("alignment-baseline", "middle").attr("fill", attrs.defaultTextFill).attr("font-size", ({ children }) => {
      if (children)
        return 40;
      return 26;
    }).text(({ children }) => {
      if (children)
        return "-";
      return "+";
    }).attr("y", this.isEdge() ? 10 : 0);
    nodeUpdate.each(attrs.nodeUpdate);
    const nodeExitTransition = nodesSelection.exit().attr("opacity", 1).transition().duration(attrs.duration).attr("transform", (d) => {
      const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x, y, width, height });
      const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x, y, width, height });
      return `translate(${ex},${ey})`;
    }).on("end", function() {
      d3.select(this).remove();
    }).attr("opacity", 0);
    nodes.forEach((d) => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
    const centeredNode = attrs.allNodes.filter((d) => d.data._centered)[0];
    if (centeredNode) {
      const centeredNodes = centeredNode.data._centeredWithDescendants ? centeredNode.descendants().filter((d, i) => i < 7) : [centeredNode];
      centeredNode.data._centeredWithDescendants = null;
      centeredNode.data._centered = null;
      this.fit({
        animate: true,
        scale: false,
        nodes: centeredNodes
      });
    }
  }
  // This function detects whether current browser is edge
  isEdge() {
    return window.navigator.userAgent.includes("Edge");
  }
  // Generate horizontal diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges-horizontal-d3-v3-v4-v5-v6
  hdiagonal(s, t, m) {
    const x = s.x;
    const y = s.y;
    const ex = t.x;
    const ey = t.y;
    let mx = m && m.x || x;
    let my = m && m.y || y;
    let xrvs = ex - x < 0 ? -1 : 1;
    let yrvs = ey - y < 0 ? -1 : 1;
    let rdef = 35;
    let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
    r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
    let h = Math.abs(ey - y) / 2 - r;
    let w = Math.abs(ex - x) / 2 - r;
    return `
                  M ${mx} ${my}
                  L ${mx} ${y}
                  L ${x} ${y}
                  L ${x + w * xrvs} ${y}
                  C ${x + w * xrvs + r * xrvs} ${y} 
                    ${x + w * xrvs + r * xrvs} ${y} 
                    ${x + w * xrvs + r * xrvs} ${y + r * yrvs}
                  L ${x + w * xrvs + r * xrvs} ${ey - r * yrvs} 
                  C ${x + w * xrvs + r * xrvs}  ${ey} 
                    ${x + w * xrvs + r * xrvs}  ${ey} 
                    ${ex - w * xrvs}  ${ey}
                  L ${ex} ${ey}
       `;
  }
  // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges
  diagonal(s, t, m) {
    const x = s.x;
    const y = s.y;
    const ex = t.x;
    const ey = t.y;
    let mx = m && m.x || x;
    let my = m && m.y || y;
    let xrvs = ex - x < 0 ? -1 : 1;
    let yrvs = ey - y < 0 ? -1 : 1;
    let rdef = 35;
    let r = Math.abs(ex - x) / 2 < rdef ? Math.abs(ex - x) / 2 : rdef;
    r = Math.abs(ey - y) / 2 < r ? Math.abs(ey - y) / 2 : r;
    let h = Math.abs(ey - y) / 2 - r;
    let w = Math.abs(ex - x) - r * 2;
    const path = `
                  M ${mx} ${my}
                  L ${x} ${my}
                  L ${x} ${y}
                  L ${x} ${y + h * yrvs}
                  C  ${x} ${y + h * yrvs + r * yrvs} ${x} ${y + h * yrvs + r * yrvs} ${x + r * xrvs} ${y + h * yrvs + r * yrvs}
                  L ${x + w * xrvs + r * xrvs} ${y + h * yrvs + r * yrvs}
                  C  ${ex}  ${y + h * yrvs + r * yrvs} ${ex}  ${y + h * yrvs + r * yrvs} ${ex} ${ey - h * yrvs}
                  L ${ex} ${ey}
       `;
    return path;
  }
  restyleForeignObjectElements() {
    const attrs = this.getChartState();
    attrs.svg.selectAll(".node-foreign-object").attr("width", ({ width }) => width).attr("height", ({ height }) => height).attr("x", ({ width }) => 0).attr("y", ({ height }) => 0);
    attrs.svg.selectAll(".node-foreign-object-div").style("width", ({ width }) => `${width}px`).style("height", ({ height }) => `${height}px`).html(function(d, i, arr) {
      return attrs.nodeContent.bind(this)(d, i, arr, attrs);
    });
  }
  // Toggle children on click.
  onButtonClick(event, d) {
    const attrs = this.getChartState();
    if (attrs.setActiveNodeCentered) {
      d.data._centered = true;
      d.data._centeredWithDescendants = true;
    }
    if (d.children) {
      d._children = d.children;
      d.children = null;
      this.setExpansionFlagToChildren(d, false);
    } else {
      d.children = d._children;
      d._children = null;
      if (d.children) {
        d.children.forEach(({ data }) => data._expanded = true);
      }
    }
    this.update(d);
  }
  // This function changes `expanded` property to descendants
  setExpansionFlagToChildren({ data, children, _children }, flag) {
    data._expanded = flag;
    if (children) {
      children.forEach((d) => {
        this.setExpansionFlagToChildren(d, flag);
      });
    }
    if (_children) {
      _children.forEach((d) => {
        this.setExpansionFlagToChildren(d, flag);
      });
    }
  }
  // Method which only expands nodes, which have property set "expanded=true"
  expandSomeNodes(d) {
    if (d.data._expanded) {
      let parent = d.parent;
      while (parent) {
        if (parent._children) {
          parent.children = parent._children;
        }
        parent = parent.parent;
      }
    }
    if (d._children) {
      d._children.forEach((ch) => this.expandSomeNodes(ch));
    }
    if (d.children) {
      d.children.forEach((ch) => this.expandSomeNodes(ch));
    }
  }
  // This function updates nodes state and redraws graph, usually after data change
  updateNodesState() {
    const attrs = this.getChartState();
    this.setLayouts({ expandNodesFirst: true });
    this.update(attrs.root);
  }
  setLayouts({ expandNodesFirst = true }) {
    const attrs = this.getChartState();
    attrs.root = d3.stratify().id((d) => attrs.nodeId(d)).parentId((d) => attrs.parentNodeId(d))(attrs.data);
    attrs.root.each((node, i, arr) => {
      let width = attrs.nodeWidth(node);
      let height = attrs.nodeHeight(node);
      Object.assign(node, { width, height });
    });
    attrs.root.x0 = 0;
    attrs.root.y0 = 0;
    attrs.allNodes = attrs.root.descendants();
    attrs.allNodes.forEach((d) => {
      Object.assign(d.data, {
        _directSubordinates: d.children ? d.children.length : 0,
        _totalSubordinates: d.descendants().length - 1
      });
    });
    if (attrs.root.children) {
      if (expandNodesFirst) {
        attrs.root.children.forEach(this.expand);
      }
      attrs.root.children.forEach((d) => this.collapse(d));
      if (attrs.expandLevel == 0) {
        attrs.root._children = attrs.root.children;
        attrs.root.children = null;
      }
      [attrs.root].forEach((ch) => this.expandSomeNodes(ch));
    }
  }
  // Function which collapses passed node and it's descendants
  collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach((ch) => this.collapse(ch));
      d.children = null;
    }
  }
  // Function which expands passed node and it's descendants
  expand(d) {
    if (d._children) {
      d.children = d._children;
      d.children.forEach((ch) => this.expand(ch));
      d._children = null;
    }
  }
  // Zoom handler function
  zoomed(event, d) {
    const attrs = this.getChartState();
    const chart = attrs.chart;
    const transform = event.transform;
    attrs.lastTransform = transform;
    chart.attr("transform", transform);
    if (this.isEdge()) {
      this.restyleForeignObjectElements();
    }
  }
  zoomTreeBounds({ x0, x1, y0, y1, params = { animate: true, scale: true } }) {
    const { centerG, svgWidth: w, svgHeight: h, svg, zoomBehavior, duration, lastTransform } = this.getChartState();
    let scaleVal = Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h));
    let identity2 = d3.zoomIdentity.translate(w / 2, h / 2);
    identity2 = identity2.scale(params.scale ? scaleVal : lastTransform.k);
    identity2 = identity2.translate(-(x0 + x1) / 2, -(y0 + y1) / 2);
    svg.transition().duration(params.animate ? duration : 0).call(zoomBehavior.transform, identity2);
    centerG.transition().duration(params.animate ? duration : 0).attr("transform", "translate(0,0)");
  }
  fit({ animate = true, nodes, scale = true } = {}) {
    const attrs = this.getChartState();
    const { root } = attrs;
    let descendants = nodes ? nodes : root.descendants();
    const minX = d3.min(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeLeftX(d));
    const maxX = d3.max(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeRightX(d));
    const minY = d3.min(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeTopY(d));
    const maxY = d3.max(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeBottomY(d));
    this.zoomTreeBounds({
      params: { animate, scale },
      x0: minX - 50,
      x1: maxX + 50,
      y0: minY - 50,
      y1: maxY + 50
    });
    return this;
  }
  // This function can be invoked via chart.setExpanded API, it expands or collapses particular node
  setExpanded(id, expandedFlag = true) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == id)[0];
    if (!node) {
      console.log(`ORG CHART - ${expandedFlag ? "EXPAND" : "COLLAPSE"} - Node with id (${id})  not found in the tree`);
      return this;
    }
    node.data._expanded = expandedFlag;
    return this;
  }
  setCentered(nodeId) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter((d) => attrs.nodeId(d.data) === nodeId)[0];
    if (!node) {
      console.log(`ORG CHART - CENTER - Node with id (${nodeId}) not found in the tree`);
      return this;
    }
    node.data._centered = true;
    node.data._expanded = true;
    return this;
  }
  setHighlighted(nodeId) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter((d) => attrs.nodeId(d.data) === nodeId)[0];
    if (!node) {
      console.log(`ORG CHART - HIGHLIGHT - Node with id (${nodeId})  not found in the tree`);
      return this;
    }
    node.data._highlighted = true;
    node.data._expanded = true;
    node.data._centered = true;
    return this;
  }
  setUpToTheRootHighlighted(nodeId) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter((d) => attrs.nodeId(d.data) === nodeId)[0];
    if (!node) {
      console.log(`ORG CHART - HIGHLIGHTROOT - Node with id (${nodeId}) not found in the tree`);
      return this;
    }
    node.data._upToTheRootHighlighted = true;
    node.data._expanded = true;
    node.ancestors().forEach((d) => d.data._upToTheRootHighlighted = true);
    return this;
  }
  clearHighlighting() {
    const attrs = this.getChartState();
    attrs.allNodes.forEach((d) => {
      d.data._highlighted = false;
      d.data._upToTheRootHighlighted = false;
    });
    this.update(attrs.root);
  }
  // It can take selector which would go fullscreen
  fullscreen(elem) {
    const attrs = this.getChartState();
    const el = d3.select(elem || attrs.container).node();
    d3.select(document).on("fullscreenchange." + attrs.id, function(d) {
      const fsElement = document.fullscreenElement || document.mozFullscreenElement || document.webkitFullscreenElement;
      if (fsElement == el) {
        setTimeout((d2) => {
          attrs.svg.attr("height", window.innerHeight - 40);
        }, 500);
      } else {
        attrs.svg.attr("height", attrs.svgHeight);
      }
    });
    if (el.requestFullscreen) {
      el.requestFullscreen();
    } else if (el.mozRequestFullScreen) {
      el.mozRequestFullScreen();
    } else if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
    } else if (el.msRequestFullscreen) {
      el.msRequestFullscreen();
    }
  }
  // Zoom in exposed method
  zoomIn() {
    const { svg, zoomBehavior } = this.getChartState();
    svg.transition().call(zoomBehavior.scaleBy, 1.3);
  }
  // Zoom out exposed method
  zoomOut() {
    const { svg, zoomBehavior } = this.getChartState();
    svg.transition().call(zoomBehavior.scaleBy, 0.78);
  }
  toDataURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      var reader = new FileReader();
      reader.onloadend = function() {
        callback(reader.result);
      };
      reader.readAsDataURL(xhr.response);
    };
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.send();
  }
  exportImg({ full = false, scale = 3, onLoad = (d) => d, save = true } = {}) {
    const that = this;
    const attrs = this.getChartState();
    const { svg: svgImg, root } = attrs;
    let count2 = 0;
    const selection = svgImg.selectAll("img");
    let total = selection.size();
    const exportImage = () => {
      const transform = JSON.parse(JSON.stringify(that.lastTransform()));
      const duration = that.duration();
      if (full) {
        that.fit();
      }
      const { svg } = that.getChartState();
      setTimeout((d) => {
        that.downloadImage({
          node: svg.node(),
          scale,
          isSvg: false,
          onAlreadySerialized: (d2) => {
            that.update(root);
          },
          onLoad,
          save
        });
      }, full ? duration + 10 : 0);
    };
    if (total > 0) {
      selection.each(function() {
        that.toDataURL(this.src, (dataUrl) => {
          this.src = dataUrl;
          if (++count2 == total) {
            exportImage();
          }
        });
      });
    } else {
      exportImage();
    }
  }
  exportSvg() {
    const { svg } = this.getChartState();
    this.downloadImage({ node: svg.node(), scale: 3, isSvg: true });
    return this;
  }
  expandAll() {
    const { allNodes, root } = this.getChartState();
    allNodes.forEach((d) => d.data._expanded = true);
    this.render();
    return this;
  }
  collapseAll() {
    const { allNodes, root } = this.getChartState();
    allNodes.forEach((d) => d.data._expanded = false);
    this.expandLevel(0);
    this.render();
    return this;
  }
  downloadImage({ node, scale = 2, isSvg = false, save = true, onAlreadySerialized = (d) => {
  }, onLoad = (d) => {
  } }) {
    const svgNode = node;
    if (isSvg) {
      let source = serializeString(svgNode);
      source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
      var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
      saveAs(url, "graph.svg");
      onAlreadySerialized();
      return;
    }
    const quality = scale;
    const image = document.createElement("img");
    image.onload = function() {
      const canvas = document.createElement("canvas");
      const rect = svgNode.getBoundingClientRect();
      canvas.width = rect.width * quality;
      canvas.height = rect.height * quality;
      const context = canvas.getContext("2d");
      context.fillStyle = "#FAFAFA";
      context.fillRect(0, 0, rect.width * quality, rect.height * quality);
      context.drawImage(image, 0, 0, rect.width * quality, rect.height * quality);
      let dt = canvas.toDataURL("image/png");
      if (onLoad) {
        onLoad(dt);
      }
      if (save) {
        saveAs(dt, "graph.png");
      }
    };
    var url = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(serializeString(svgNode));
    onAlreadySerialized();
    image.src = url;
    function saveAs(uri, filename) {
      var link = document.createElement("a");
      if (typeof link.download === "string") {
        document.body.appendChild(link);
        link.download = filename;
        link.href = uri;
        link.click();
        document.body.removeChild(link);
      } else {
        location.replace(uri);
      }
    }
    function serializeString(svg) {
      const xmlns = "http://www.w3.org/2000/xmlns/";
      const xlinkns = "http://www.w3.org/1999/xlink";
      const svgns = "http://www.w3.org/2000/svg";
      svg = svg.cloneNode(true);
      const fragment = window.location.href + "#";
      const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false);
      while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
          if (attr.value.includes(fragment)) {
            attr.value = attr.value.replace(fragment, "#");
          }
        }
      }
      svg.setAttributeNS(xmlns, "xmlns", svgns);
      svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);
      const serializer = new XMLSerializer();
      const string = serializer.serializeToString(svg);
      return string;
    }
  }
  // Calculate what size text will take
  getTextWidth(text, {
    fontSize = 14,
    fontWeight = 400,
    defaultFont = "Helvetice",
    ctx
  } = {}) {
    ctx.font = `${fontWeight || ""} ${fontSize}px ${defaultFont} `;
    const measurement = ctx.measureText(text);
    return measurement.width;
  }
};
export {
  OrgChart
};
//# sourceMappingURL=d3-org-chart.js.map
