{
  "version": 3,
  "sources": ["../../../../../node_modules/@datadog/browser-rum-core/src/domain/tracing/tracer.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/configuration.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/commonContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/boot/rumPublicApi.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/domMutationObservable.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/resource/resourceUtils.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/htmlDomUtils.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/tracing/getDocumentTraceId.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/performanceCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/syntheticsContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/ciTestContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/viewportObservable.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/displayContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/limitModification.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/assembly.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/internalContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/lifeCycle.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/viewContexts.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/requestCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/trackEventCounts.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/waitPageActivityEnd.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/clickChain.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/getActionNameFromElement.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/getSelectorFromElement.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/listenActionEvents.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/computeFrustration.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/trackClickActions.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/action/actionCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/error/trackConsoleError.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/error/trackReportError.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/error/errorCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/longTask/longTaskCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/resource/matchRequestTiming.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/resource/resourceCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/foregroundContexts.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackFirstHidden.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackInitialViewTimings.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/scroll.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackViewMetrics.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackViewEventCounts.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/trackViews.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/viewCollection.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumSessionManager.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/transport/startRumBatch.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/transport/startRumEventBridge.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/urlContexts.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/browser/locationChangeObservable.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/featureFlagContext.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/startCustomerDataTelemetry.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/contexts/pageStateHistory.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/rumEventsCollection/view/startWebVitalTelemetryDebug.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/boot/startRum.ts", "../../../../../node_modules/@datadog/browser-rum-core/src/domain/getSessionReplayUrl.ts", "../../../../../node_modules/@datadog/browser-rum/src/types/sessionReplayConstants.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/assembly.ts", "../../../../../node_modules/@datadog/browser-rum/src/constants.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/privacy.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializationUtils.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializeStyleSheets.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializeAttribute.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializeAttributes.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializeNode.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/serialization/serializeDocument.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/eventsUtils.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/viewports.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/moveObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/scrollObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/mouseInteractionObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/inputObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/styleSheetObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/mediaInteractionObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/frustrationObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/viewportResizeObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/mutationBatch.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/mutationObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/focusObserver.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/recordIds.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/observers/observers.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/elementsScrollPositions.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/shadowRootsController.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/record/record.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/segmentCollection/buildReplayPayload.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/replayStats.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/segmentCollection/segment.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/segmentCollection/segmentCollection.ts", "../../../../../node_modules/@datadog/browser-worker/esm/entries/string.js", "../../../../../node_modules/@datadog/browser-rum/src/domain/segmentCollection/startDeflateWorker.ts", "../../../../../node_modules/@datadog/browser-rum/src/boot/startRecording.ts", "../../../../../node_modules/@datadog/browser-rum/src/boot/isBrowserSupported.ts", "../../../../../node_modules/@datadog/browser-rum/src/domain/getSessionReplayLink.ts", "../../../../../node_modules/@datadog/browser-rum/src/boot/recorderApi.ts", "../../../../../node_modules/@datadog/browser-rum/src/entries/main.ts"],
  "sourcesContent": ["import {\n  objectEntries,\n  shallowClone,\n  performDraw,\n  isNumber,\n  assign,\n  find,\n  getType,\n  isMatchOption,\n  matchList,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchResolveContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { PropagatorType, TracingOption } from './tracer.types'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchResolveContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\nexport function isTracingOption(item: unknown): item is TracingOption {\n  const expectedItem = item as TracingOption\n  return (\n    getType(expectedItem) === 'object' &&\n    isMatchOption(expectedItem.match) &&\n    Array.isArray(expectedItem.propagatorTypes)\n  )\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchResolveContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: Array<[string, string]> = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders))\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  const tracingOption = find(configuration.allowedTracingUrls, (tracingOption: TracingOption) =>\n    matchList([tracingOption.match], context.url!, true)\n  )\n  if (!tracingOption) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n  context.traceSampled = !isNumber(configuration.traceSampleRate) || performDraw(configuration.traceSampleRate)\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(\n  traceId: TraceIdentifier,\n  spanId: TraceIdentifier,\n  traceSampled: boolean,\n  propagatorTypes: PropagatorType[]\n): TracingHeaders {\n  const tracingHeaders: TracingHeaders = {}\n\n  propagatorTypes.forEach((propagatorType) => {\n    switch (propagatorType) {\n      case 'datadog': {\n        assign(tracingHeaders, {\n          'x-datadog-origin': 'rum',\n          'x-datadog-parent-id': spanId.toDecimalString(),\n          'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n          'x-datadog-trace-id': traceId.toDecimalString(),\n        })\n        break\n      }\n      // https://www.w3.org/TR/trace-context/\n      case 'tracecontext': {\n        assign(tracingHeaders, {\n          traceparent: `00-0000000000000000${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-0${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      // https://github.com/openzipkin/b3-propagation\n      case 'b3': {\n        assign(tracingHeaders, {\n          b3: `${traceId.toPaddedHexadecimalString()}-${spanId.toPaddedHexadecimalString()}-${\n            traceSampled ? '1' : '0'\n          }`,\n        })\n        break\n      }\n      case 'b3multi': {\n        assign(tracingHeaders, {\n          'X-B3-TraceId': traceId.toPaddedHexadecimalString(),\n          'X-B3-SpanId': spanId.toPaddedHexadecimalString(),\n          'X-B3-Sampled': traceSampled ? '1' : '0',\n        })\n        break\n      }\n    }\n  })\n  return tracingHeaders\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  /**\n   * Format used by OTel headers\n   */\n  toPaddedHexadecimalString() {\n    const traceId = this.toString(16)\n    return Array(17 - traceId.length).join('0') + traceId\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n", "import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  getType,\n  arrayFrom,\n  getOrigin,\n  isMatchOption,\n  serializeConfiguration,\n  assign,\n  DefaultPrivacyLevel,\n  display,\n  isPercentage,\n  objectHasValue,\n  validateAndBuildConfiguration,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { isTracingOption } from './tracing/tracer'\nimport type { PropagatorType, TracingOption } from './tracing/tracer.types'\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  applicationId: string\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => void | boolean) | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  premiumSampleRate?: number | undefined\n  excludedActivityUrls?: MatchOption[] | undefined\n\n  // tracing options\n  /**\n   * @deprecated use allowedTracingUrls instead\n   */\n  allowedTracingOrigins?: MatchOption[] | undefined\n  allowedTracingUrls?: Array<MatchOption | TracingOption> | undefined\n  /**\n   * @deprecated use traceSampleRate instead\n   */\n  tracingSampleRate?: number | undefined\n  traceSampleRate?: number | undefined\n\n  // replay options\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  subdomain?: string\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  replaySampleRate?: number | undefined\n  sessionReplaySampleRate?: number | undefined\n\n  // action options\n  /**\n   * @deprecated use trackUserInteractions instead\n   */\n  trackInteractions?: boolean | undefined\n  trackUserInteractions?: boolean | undefined\n  trackFrustrations?: boolean | undefined\n  actionNameAttribute?: string | undefined\n\n  // view options\n  trackViewsManually?: boolean | undefined\n\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  traceSampleRate: number | undefined\n  allowedTracingUrls: TracingOption[]\n  excludedActivityUrls: MatchOption[]\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  oldPlansBehavior: boolean\n  sessionReplaySampleRate: number\n  trackUserInteractions: boolean\n  trackFrustrations: boolean\n  trackViewsManually: boolean\n  trackResources: boolean | undefined\n  trackLongTasks: boolean | undefined\n  version?: string\n  subdomain?: string\n  customerDataTelemetrySampleRate: number\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    initConfiguration.sessionReplaySampleRate !== undefined &&\n    !isPercentage(initConfiguration.sessionReplaySampleRate)\n  ) {\n    display.error('Session Replay Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // TODO remove fallback in next major\n  let premiumSampleRate = initConfiguration.premiumSampleRate ?? initConfiguration.replaySampleRate\n  if (premiumSampleRate !== undefined && initConfiguration.sessionReplaySampleRate !== undefined) {\n    display.warn('Ignoring Premium Sample Rate because Session Replay Sample Rate is set')\n    premiumSampleRate = undefined\n  }\n\n  if (premiumSampleRate !== undefined && !isPercentage(premiumSampleRate)) {\n    display.error('Premium Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  const traceSampleRate = initConfiguration.traceSampleRate ?? initConfiguration.tracingSampleRate\n  if (traceSampleRate !== undefined && !isPercentage(traceSampleRate)) {\n    display.error('Trace Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const allowedTracingUrls = validateAndBuildTracingOptions(initConfiguration)\n  if (!allowedTracingUrls) {\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  const trackUserInteractions = !!(initConfiguration.trackUserInteractions ?? initConfiguration.trackInteractions)\n  const trackFrustrations = !!initConfiguration.trackFrustrations\n\n  return assign(\n    {\n      applicationId: initConfiguration.applicationId,\n      version: initConfiguration.version,\n      actionNameAttribute: initConfiguration.actionNameAttribute,\n      sessionReplaySampleRate: initConfiguration.sessionReplaySampleRate ?? premiumSampleRate ?? 100,\n      oldPlansBehavior: initConfiguration.sessionReplaySampleRate === undefined,\n      traceSampleRate,\n      allowedTracingUrls,\n      excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n      trackUserInteractions: trackUserInteractions || trackFrustrations,\n      trackFrustrations,\n      trackViewsManually: !!initConfiguration.trackViewsManually,\n      trackResources: initConfiguration.trackResources,\n      trackLongTasks: initConfiguration.trackLongTasks,\n      subdomain: initConfiguration.subdomain,\n      defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n        ? initConfiguration.defaultPrivacyLevel\n        : DefaultPrivacyLevel.MASK_USER_INPUT,\n      customerDataTelemetrySampleRate: 1,\n    },\n    baseConfiguration\n  )\n}\n\n/**\n * Handles allowedTracingUrls and processes legacy allowedTracingOrigins\n */\nfunction validateAndBuildTracingOptions(initConfiguration: RumInitConfiguration): TracingOption[] | undefined {\n  // Advise about parameters precedence.\n  if (initConfiguration.allowedTracingUrls !== undefined && initConfiguration.allowedTracingOrigins !== undefined) {\n    display.warn(\n      'Both allowedTracingUrls and allowedTracingOrigins (deprecated) have been defined. The parameter allowedTracingUrls will override allowedTracingOrigins.'\n    )\n  }\n  // Handle allowedTracingUrls first\n  if (initConfiguration.allowedTracingUrls !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingUrls)) {\n      display.error('Allowed Tracing URLs should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingUrls.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service needs to be configured when tracing is enabled')\n      return\n    }\n    // Convert from (MatchOption | TracingOption) to TracingOption, remove unknown properties\n    const tracingOptions: TracingOption[] = []\n    initConfiguration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        tracingOptions.push({ match: option, propagatorTypes: ['datadog'] })\n      } else if (isTracingOption(option)) {\n        tracingOptions.push(option)\n      } else {\n        display.warn(\n          'Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter',\n          option\n        )\n      }\n    })\n\n    return tracingOptions\n  }\n\n  // Handle conversion of allowedTracingOrigins to allowedTracingUrls\n  if (initConfiguration.allowedTracingOrigins !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingOrigins)) {\n      display.error('Allowed Tracing Origins should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingOrigins.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service needs to be configured when tracing is enabled')\n      return\n    }\n\n    const tracingOptions: TracingOption[] = []\n    initConfiguration.allowedTracingOrigins.forEach((legacyMatchOption) => {\n      const tracingOption = convertLegacyMatchOptionToTracingOption(legacyMatchOption)\n      if (tracingOption) {\n        tracingOptions.push(tracingOption)\n      }\n    })\n    return tracingOptions\n  }\n\n  return []\n}\n\n/**\n * Converts parameters from the deprecated allowedTracingOrigins\n * to allowedTracingUrls. Handles the change from origin to full URLs.\n */\nfunction convertLegacyMatchOptionToTracingOption(item: MatchOption): TracingOption | undefined {\n  let match: MatchOption | undefined\n  if (typeof item === 'string') {\n    match = item\n  } else if (item instanceof RegExp) {\n    match = (url) => item.test(getOrigin(url))\n  } else if (typeof item === 'function') {\n    match = (url) => item(getOrigin(url))\n  }\n\n  if (match === undefined) {\n    display.warn('Allowed Tracing Origins parameters should be a string, RegExp or function. Ignoring parameter', item)\n    return undefined\n  }\n\n  return { match, propagatorTypes: ['datadog'] }\n}\n\n/**\n * Combines the selected tracing propagators from the different options in allowedTracingUrls,\n * and assumes 'datadog' has been selected when using allowedTracingOrigins\n */\nfunction getSelectedTracingPropagators(configuration: RumInitConfiguration): PropagatorType[] {\n  const usedTracingPropagators = new Set<PropagatorType>()\n\n  if (Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0) {\n    configuration.allowedTracingUrls.forEach((option) => {\n      if (isMatchOption(option)) {\n        usedTracingPropagators.add('datadog')\n      } else if (getType(option) === 'object' && Array.isArray(option.propagatorTypes)) {\n        // Ensure we have an array, as we cannot rely on types yet (configuration is provided by users)\n        option.propagatorTypes.forEach((propagatorType) => usedTracingPropagators.add(propagatorType))\n      }\n    })\n  }\n\n  if (Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0) {\n    usedTracingPropagators.add('datadog')\n  }\n\n  return arrayFrom(usedTracingPropagators)\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      premium_sample_rate: configuration.premiumSampleRate,\n      replay_sample_rate: configuration.replaySampleRate,\n      session_replay_sample_rate: configuration.sessionReplaySampleRate,\n      trace_sample_rate: configuration.traceSampleRate ?? configuration.tracingSampleRate,\n      action_name_attribute: configuration.actionNameAttribute,\n      use_allowed_tracing_origins:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      use_allowed_tracing_urls:\n        Array.isArray(configuration.allowedTracingUrls) && configuration.allowedTracingUrls.length > 0,\n      selected_tracing_propagators: getSelectedTracingPropagators(configuration),\n      default_privacy_level: configuration.defaultPrivacyLevel,\n      use_excluded_activity_urls:\n        Array.isArray(configuration.excludedActivityUrls) && configuration.excludedActivityUrls.length > 0,\n      track_frustrations: configuration.trackFrustrations,\n      track_views_manually: configuration.trackViewsManually,\n      track_user_interactions: configuration.trackUserInteractions ?? configuration.trackInteractions,\n    },\n    baseSerializedConfiguration\n  )\n}\n", "import type { Context, ContextManager, User } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../boot/rumPublicApi'\n\nexport interface CommonContext {\n  user: User\n  context: Context\n  hasReplay: true | undefined\n}\n\nexport function buildCommonContext(\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  recorderApi: RecorderApi\n): CommonContext {\n  return {\n    context: globalContextManager.getContext(),\n    user: userContextManager.getContext(),\n    hasReplay: recorderApi.isRecording() ? true : undefined,\n  }\n}\n", "import type { Context, InitConfiguration, TimeStamp, RelativeTime, User, Observable } from '@datadog/browser-core'\nimport {\n  noop,\n  CustomerDataType,\n  willSyntheticsInjectRum,\n  assign,\n  BoundedBuffer,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  timeStampNow,\n  display,\n  callMonitored,\n  createHandlingStack,\n  canUseEventBridge,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport type { startRum } from './startRum'\n\nexport type RumPublicApi = ReturnType<typeof makeRumPublicApi>\n\nexport type StartRum = typeof startRum\n\ntype StartRumResult = ReturnType<typeof startRum>\n\nexport interface RecorderApi {\n  start: () => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n  getSessionReplayLink: (\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => string | undefined\n  getSerializedNodeId: (node: Node) => number | undefined\n  recorderStartObservable: Observable<RelativeTime>\n}\ninterface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  { ignoreInitIfSyntheticsWillInjectRum = true }: RumPublicApiOptions = {}\n) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager(CustomerDataType.GlobalContext)\n  const userContextManager = createContextManager(CustomerDataType.User)\n\n  let getInternalContextStrategy: StartRumResult['getInternalContext'] = () => undefined\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n  let stopSessionStrategy: () => void = noop\n  let getSessionReplayLinkStrategy: () => string | undefined = () => undefined\n\n  let bufferApiCalls = new BoundedBuffer()\n  let addTimingStrategy: StartRumResult['addTiming'] = (name, time = timeStampNow()) => {\n    bufferApiCalls.add(() => addTimingStrategy(name, time))\n  }\n  let startViewStrategy: StartRumResult['startView'] = (options, startClocks = clocksNow()) => {\n    bufferApiCalls.add(() => startViewStrategy(options, startClocks))\n  }\n  let addActionStrategy: StartRumResult['addAction'] = (\n    action,\n    commonContext = buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  ) => {\n    bufferApiCalls.add(() => addActionStrategy(action, commonContext))\n  }\n  let addErrorStrategy: StartRumResult['addError'] = (\n    providedError,\n    commonContext = buildCommonContext(globalContextManager, userContextManager, recorderApi)\n  ) => {\n    bufferApiCalls.add(() => addErrorStrategy(providedError, commonContext))\n  }\n\n  let addFeatureFlagEvaluationStrategy: StartRumResult['addFeatureFlagEvaluation'] = (key: string, value: any) => {\n    bufferApiCalls.add(() => addFeatureFlagEvaluationStrategy(key, value))\n  }\n\n  function initRum(initConfiguration: RumInitConfiguration) {\n    // This function should be available, regardless of initialization success.\n    getInitConfigurationStrategy = () => deepClone<InitConfiguration>(initConfiguration)\n\n    // If we are in a Synthetics test configured to automatically inject a RUM instance, we want to\n    // completely discard the customer application RUM instance by ignoring their init() call.  But,\n    // we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n    // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n    if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n      return\n    }\n\n    const eventBridgeAvailable = canUseEventBridge()\n    if (eventBridgeAvailable) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    }\n\n    if (!canInitRum(initConfiguration)) {\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!eventBridgeAvailable && !configuration.sessionStoreStrategyType) {\n      display.warn('No storage available for session. We will not send any data.')\n      return\n    }\n\n    if (!configuration.trackViewsManually) {\n      doStartRum(initConfiguration, configuration)\n    } else {\n      // drain beforeInitCalls by buffering them until we start RUM\n      // if we get a startView, drain re-buffered calls before continuing to drain beforeInitCalls\n      // in order to ensure that calls are processed in order\n      const beforeInitCalls = bufferApiCalls\n      bufferApiCalls = new BoundedBuffer()\n\n      startViewStrategy = (options) => {\n        doStartRum(initConfiguration, configuration, options)\n      }\n      beforeInitCalls.drain()\n    }\n\n    isAlreadyInitialized = true\n  }\n\n  function doStartRum(\n    initConfiguration: RumInitConfiguration,\n    configuration: RumConfiguration,\n    initialViewOptions?: ViewOptions\n  ) {\n    const startRumResults = startRumImpl(\n      initConfiguration,\n      configuration,\n      recorderApi,\n      globalContextManager,\n      userContextManager,\n      initialViewOptions\n    )\n    getSessionReplayLinkStrategy = () =>\n      recorderApi.getSessionReplayLink(configuration, startRumResults.session, startRumResults.viewContexts)\n    ;({\n      startView: startViewStrategy,\n      addAction: addActionStrategy,\n      addError: addErrorStrategy,\n      addTiming: addTimingStrategy,\n      addFeatureFlagEvaluation: addFeatureFlagEvaluationStrategy,\n      getInternalContext: getInternalContextStrategy,\n      stopSession: stopSessionStrategy,\n    } = startRumResults)\n    bufferApiCalls.drain()\n\n    recorderApi.onRumStart(\n      startRumResults.lifeCycle,\n      configuration,\n      startRumResults.session,\n      startRumResults.viewContexts\n    )\n  }\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    startViewStrategy(sanitizedOptions)\n  })\n\n  const rumPublicApi = makePublicApi({\n    init: monitor(initRum),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addRumGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeRumGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    /** @deprecated: use getGlobalContext instead */\n    getRumGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setRumGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    getInternalContext: monitor((startTime?: number) => getInternalContextStrategy(startTime)),\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    addAction: monitor((name: string, context?: object) => {\n      addActionStrategy({\n        name: sanitize(name)!,\n        context: sanitize(context) as Context,\n        startClocks: clocksNow(),\n        type: ActionType.CUSTOM,\n      })\n    }),\n\n    addError: (error: unknown, context?: object) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        addErrorStrategy({\n          error, // Do not sanitize error here, it is needed unserialized by computeRawError()\n          handlingStack,\n          context: sanitize(context) as Context,\n          startClocks: clocksNow(),\n        })\n      })\n    },\n\n    addTiming: monitor((name: string, time?: number) => {\n      addTimingStrategy(sanitize(name)!, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser: User) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(userContextManager.getContext),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor(userContextManager.removeContextProperty),\n\n    /** @deprecated: renamed to clearUser */\n    removeUser: monitor(userContextManager.clearContext),\n    clearUser: monitor(userContextManager.clearContext),\n\n    startView,\n\n    stopSession: monitor(() => {\n      stopSessionStrategy()\n    }),\n\n    startSessionReplayRecording: monitor(recorderApi.start),\n    stopSessionReplayRecording: monitor(recorderApi.stop),\n\n    /**\n     * This feature is currently in beta. For more information see the full [feature flag tracking guide](https://docs.datadoghq.com/real_user_monitoring/feature_flag_tracking/).\n     */\n    addFeatureFlagEvaluation: monitor((key: string, value: any) => {\n      addFeatureFlagEvaluationStrategy(sanitize(key)!, sanitize(value))\n    }),\n    getSessionReplayLink: monitor(() => getSessionReplayLinkStrategy()),\n  })\n\n  return rumPublicApi\n\n  function canInitRum(initConfiguration: RumInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_RUM is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, {\n      applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n      clientToken: 'empty',\n      sessionSampleRate: 100,\n    })\n  }\n}\n", "import { monitor, noop, Observable, getZoneJsOriginalValue } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  const observable: Observable<void> = new Observable<void>(() => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n\n  return observable\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\n\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: unknown\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = getZoneJsOriginalValue(browserWindow, 'MutationObserver')\n\n    if (browserWindow.MutationObserver && constructor === browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as {\n        originalInstance?: { constructor: MutationObserverConstructor }\n      }\n\n      const originalInstance = getZoneJsOriginalValue(patchedInstance, 'originalInstance')\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n", "import type { RelativeTime, ServerDuration } from '@datadog/browser-core'\nimport {\n  assign,\n  addTelemetryDebug,\n  elapsed,\n  getPathName,\n  includes,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\n\nimport type { PerformanceResourceDetailsElement } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface PerformanceResourceDetails {\n  redirect?: PerformanceResourceDetailsElement\n  dns?: PerformanceResourceDetailsElement\n  connect?: PerformanceResourceDetailsElement\n  ssl?: PerformanceResourceDetailsElement\n  first_byte: PerformanceResourceDetailsElement\n  download: PerformanceResourceDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceKind(timing: RumPerformanceResourceTiming) {\n  const url = timing.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${timing.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(timing.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isRequestKind(timing: RumPerformanceResourceTiming) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch'\n}\n\nexport function computePerformanceResourceDuration(entry: RumPerformanceResourceTiming): ServerDuration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd))\n  }\n\n  return toServerDuration(duration)\n}\n\nexport function computePerformanceResourceDetails(\n  entry: RumPerformanceResourceTiming\n): PerformanceResourceDetails | undefined {\n  const validEntry = toValidEntry(entry)\n\n  if (!validEntry) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = validEntry\n\n  const details: PerformanceResourceDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a connection occurred\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  if (hasRedirection(entry)) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\nexport function toValidEntry(entry: RumPerformanceResourceTiming) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  if (\n    !areInOrder(\n      entry.startTime,\n      entry.fetchStart,\n      entry.domainLookupStart,\n      entry.domainLookupEnd,\n      entry.connectStart,\n      entry.connectEnd,\n      entry.requestStart,\n      entry.responseStart,\n      entry.responseEnd\n    )\n  ) {\n    return undefined\n  }\n\n  if (!hasRedirection(entry)) {\n    return entry\n  }\n\n  let { redirectStart, redirectEnd } = entry\n  // Firefox doesn't provide redirect timings on cross origin requests.\n  // Provide a default for those.\n  if (redirectStart < entry.startTime) {\n    redirectStart = entry.startTime\n  }\n  if (redirectEnd < entry.startTime) {\n    redirectEnd = entry.fetchStart\n  }\n\n  // Make sure redirect timings are in order\n  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n    return undefined\n  }\n\n  return assign({}, entry, {\n    redirectEnd,\n    redirectStart,\n  })\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  // The only time fetchStart is different than startTime is if a redirection occurred.\n  return entry.fetchStart !== entry.startTime\n}\n\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  return {\n    duration: toServerDuration(elapsed(start, end)),\n    start: toServerDuration(elapsed(origin, start)),\n  }\n}\n\nexport function computeSize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize\n  }\n  return undefined\n}\n\nexport function isAllowedRequestUrl(configuration: RumConfiguration, url: string) {\n  return url && !configuration.isIntakeUrl(url)\n}\n", "export function isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE\n}\n\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === Node.COMMENT_NODE\n}\n\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE\n}\n\nexport function isNodeShadowHost(node: Node): node is Element & { shadowRoot: ShadowRoot } {\n  return isElementNode(node) && Boolean(node.shadowRoot)\n}\n\nexport function isNodeShadowRoot(node: Node): node is ShadowRoot {\n  const shadowRoot = node as ShadowRoot\n  return !!shadowRoot.host && shadowRoot.nodeType === Node.DOCUMENT_FRAGMENT_NODE && isElementNode(shadowRoot.host)\n}\n\nexport function getChildNodes(node: Node) {\n  return isNodeShadowHost(node) ? node.shadowRoot.childNodes : node.childNodes\n}\n\n/**\n * Return `host` in case if the current node is a shadow root otherwise will return the `parentNode`\n */\nexport function getParentNode(node: Node): Node | null {\n  return isNodeShadowRoot(node) ? node.host : node.parentNode\n}\n", "import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\nimport { isCommentNode, isTextNode } from '../../browser/htmlDomUtils'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n", "import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  setTimeout,\n  relativeNow,\n  runOnReadyState,\n  addEventListener,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/rumEventsCollection/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\nimport type { PerformanceEntryRepresentation } from '../domainContext.types'\n\nexport interface RumPerformanceResourceTiming {\n  entryType: 'resource'\n  initiatorType: string\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  traceId?: string\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  entryType: 'longtask'\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): PerformanceEntryRepresentation\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: 'paint'\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: 'navigation'\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: 'largest-contentful-paint'\n  startTime: RelativeTime\n  size: number\n  element?: Element\n}\n\nexport interface RumFirstInputTiming {\n  entryType: 'first-input'\n  startTime: RelativeTime\n  processingStart: RelativeTime\n  target?: Node\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: 'layout-shift'\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n  sources?: Array<{\n    node?: Node\n  }>\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: string) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  retrieveInitialDocumentResourceTiming((timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = ['resource', 'navigation', 'longtask', 'paint']\n    const experimentalEntries = ['largest-contentful-paint', 'first-input', 'layout-shift']\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({ type, buffered: true })\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      addEventListener(performance, 'resourcetimingbufferfull', () => {\n        performance.clearResourceTimings()\n      })\n    }\n  }\n  if (!supportPerformanceTimingEvent('navigation')) {\n    retrieveNavigationTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent('first-input')) {\n    retrieveFirstInputTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(callback: (timing: RumPerformanceResourceTiming) => void) {\n  runOnReadyState('interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: 'resource' as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n    }\n    if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {\n      const navigationEntry = performance.getEntriesByType('navigation')[0]\n      timing = assign(navigationEntry.toJSON(), forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(callback: (timing: RumPerformanceNavigationTiming) => void) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: 'navigation' as const,\n      })\n    )\n  }\n\n  runOnReadyState('complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(sendFakeTiming)\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: 'first-input',\n        processingStart: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(timing: RumFirstInputTiming) {\n    addEventListeners(\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter(\n    (entry) =>\n      entry.entryType === 'resource' ||\n      entry.entryType === 'navigation' ||\n      entry.entryType === 'paint' ||\n      entry.entryType === 'longtask' ||\n      entry.entryType === 'largest-contentful-paint' ||\n      entry.entryType === 'first-input' ||\n      entry.entryType === 'layout-shift'\n  ) as RumPerformanceEntry[]\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === 'navigation' && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === 'resource' && !isAllowedRequestUrl(configuration, entry.name)\n}\n", "import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core'\n\nexport function getSyntheticsContext() {\n  const testId = getSyntheticsTestId()\n  const resultId = getSyntheticsResultId()\n\n  if (testId && resultId) {\n    return {\n      test_id: testId,\n      result_id: resultId,\n      injected: willSyntheticsInjectRum(),\n    }\n  }\n}\n", "export interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport function getCiTestContext() {\n  const testExecutionId = (window as CiTestWindow).Cypress?.env('traceId')\n\n  if (typeof testExecutionId === 'string') {\n    return {\n      test_execution_id: testExecutionId,\n    }\n  }\n}\n", "import { Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable() {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable()\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable() {\n  const observable = new Observable<ViewportDimension>(() => {\n    const { throttled: updateDimension } = throttle(() => {\n      observable.notify(getViewportDimension())\n    }, 200)\n\n    return addEventListener(window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true }).stop\n  })\n\n  return observable\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n", "import { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\n\nlet viewport: { width: number; height: number } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function getDisplayContext() {\n  if (!viewport) {\n    viewport = getViewportDimension()\n    stopListeners = initViewportObservable().subscribe((viewportDimension) => {\n      viewport = viewportDimension\n    }).unsubscribe\n  }\n\n  return {\n    viewport,\n  }\n}\n\nexport function resetDisplayContext() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  viewport = undefined\n}\n", "import { sanitize, deepClone, getType, objectEntries } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\n\nexport type ModifiableFieldPaths = Record<string, 'string' | 'object'>\n\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: ModifiableFieldPaths,\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n  objectEntries(modifiableFieldPaths).forEach(([fieldPath, fieldType]) => {\n    const newValue = get(clone, fieldPath)\n    const newType = getType(newValue)\n    if (newType === fieldType) {\n      set(object, fieldPath, sanitize(newValue))\n    } else if (fieldType === 'object' && (newType === 'undefined' || newType === 'null')) {\n      set(object, fieldPath, {})\n    }\n  })\n  return result\n}\n\nfunction get(object: unknown, path: string) {\n  let current = object\n  for (const field of path.split('.')) {\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    current = current[field]\n  }\n  return current\n}\n\nfunction set(object: unknown, path: string, value: unknown) {\n  let current = object\n  const fields = path.split('.')\n  for (let i = 0; i < fields.length; i += 1) {\n    const field = fields[i]\n    if (!isValidObject(current)) {\n      return\n    }\n    if (i !== fields.length - 1) {\n      current = current[field]\n    } else {\n      current[field] = value\n    }\n  }\n}\n\nfunction isValidObject(object: unknown): object is Record<string, unknown> {\n  return getType(object) === 'object'\n}\n\nfunction isValidObjectContaining(object: unknown, field: string): object is Record<string, unknown> {\n  return isValidObject(object) && Object.prototype.hasOwnProperty.call(object, field)\n}\n", "import type { Context, RawError, EventRateLimiter, User } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  timeStampNow,\n  currentDrift,\n  display,\n  createEventRateLimiter,\n  canUseEventBridge,\n  assign,\n  round,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type {\n  RawRumErrorEvent,\n  RawRumEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RumContext,\n} from '../rawRumEvent.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { getSyntheticsContext } from './contexts/syntheticsContext'\nimport { getCiTestContext } from './contexts/ciTestContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { ViewContexts } from './contexts/viewContexts'\nimport type { RumSessionManager } from './rumSessionManager'\nimport type { UrlContexts } from './contexts/urlContexts'\nimport type { RumConfiguration } from './configuration'\nimport type { ActionContexts } from './rumEventsCollection/action/actionCollection'\nimport { getDisplayContext } from './contexts/displayContext'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { ModifiableFieldPaths } from './limitModification'\nimport { limitModification } from './limitModification'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nconst VIEW_MODIFIABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  'view.url': 'string',\n  'view.referrer': 'string',\n}\n\nconst USER_CUSTOMIZABLE_FIELD_PATHS: ModifiableFieldPaths = {\n  context: 'object',\n}\n\nlet modifiableFieldPathsByEvent: { [key in RumEventType]: ModifiableFieldPaths }\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  urlContexts: UrlContexts,\n  actionContexts: ActionContexts,\n  buildCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  modifiableFieldPathsByEvent = {\n    [RumEventType.VIEW]: VIEW_MODIFIABLE_FIELD_PATHS,\n    [RumEventType.ERROR]: assign(\n      {\n        'error.message': 'string',\n        'error.stack': 'string',\n        'error.resource.url': 'string',\n        'error.fingerprint': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.RESOURCE]: assign(\n      {\n        'resource.url': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.ACTION]: assign(\n      {\n        'action.target.name': 'string',\n      },\n      USER_CUSTOMIZABLE_FIELD_PATHS,\n      VIEW_MODIFIABLE_FIELD_PATHS\n    ),\n    [RumEventType.LONG_TASK]: assign({}, USER_CUSTOMIZABLE_FIELD_PATHS, VIEW_MODIFIABLE_FIELD_PATHS),\n  }\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  const syntheticsContext = getSyntheticsContext()\n  const ciTestContext = getCiTestContext()\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n      const viewContext = viewContexts.findView(startTime)\n      const urlContext = urlContexts.findUrl(startTime)\n      const session = sessionManager.findTrackedSession(startTime)\n      if (session && viewContext && urlContext) {\n        const commonContext = savedCommonContext || buildCommonContext()\n        const actionId = actionContexts.findActionId(startTime)\n\n        const rumContext: RumContext = {\n          _dd: {\n            format_version: 2,\n            drift: currentDrift(),\n            session: {\n              plan: session.plan,\n            },\n            configuration: {\n              session_sample_rate: round(configuration.sessionSampleRate, 3),\n              session_replay_sample_rate: round(configuration.sessionReplaySampleRate, 3),\n            },\n            browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n          },\n          application: {\n            id: configuration.applicationId,\n          },\n          date: timeStampNow(),\n          service: viewContext.service || configuration.service,\n          version: viewContext.version || configuration.version,\n          source: 'browser',\n          session: {\n            id: session.id,\n            type: syntheticsContext ? SessionType.SYNTHETICS : ciTestContext ? SessionType.CI_TEST : SessionType.USER,\n          },\n          view: {\n            id: viewContext.id,\n            name: viewContext.name,\n            url: urlContext.url,\n            referrer: urlContext.referrer,\n          },\n          action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n          synthetics: syntheticsContext,\n          ci_test: ciTestContext,\n          display: getDisplayContext(),\n        }\n\n        const serverRumEvent = combine(rumContext as RumContext & Context, rawRumEvent) as RumEvent & Context\n        serverRumEvent.context = combine(commonContext.context, customerContext)\n\n        if (!('has_replay' in serverRumEvent.session)) {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).has_replay = commonContext.hasReplay\n        }\n\n        if (!isEmptyObject(commonContext.user)) {\n          ;(serverRumEvent.usr as Mutable<RumEvent['usr']>) = commonContext.user as User & Context\n        }\n\n        if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n          if (isEmptyObject(serverRumEvent.context)) {\n            delete serverRumEvent.context\n          }\n          lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n        }\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(event, modifiableFieldPathsByEvent[event.type], (event) =>\n      beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n  return !rateLimitReached\n}\n\nfunction needToAssembleWithAction(\n  event: RawRumEvent\n): event is RawRumErrorEvent | RawRumResourceEvent | RawRumLongTaskEvent {\n  return [RumEventType.ERROR, RumEventType.RESOURCE, RumEventType.LONG_TASK].indexOf(event.type) !== -1\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../rumEventsCollection/action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewContexts } from './viewContexts'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewContexts.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n", "import type { Context, PageExitEvent, RawError, RelativeTime } from '@datadog/browser-core'\nimport { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { RumPerformanceEntry } from '../browser/performanceCollection'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { CommonContext } from './contexts/commonContext'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './rumEventsCollection/action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent } from './rumEventsCollection/view/trackViews'\n\nexport const enum LifeCycleEventType {\n  PERFORMANCE_ENTRIES_COLLECTED,\n  AUTO_ACTION_COMPLETED,\n  VIEW_CREATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n\n  SESSION_RENEWED,\n  PAGE_EXITED,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\n// This is a workaround for an issue occurring when the Browser SDK is included in a TypeScript\n// project configured with `isolatedModules: true`. Even if the const enum is declared in this\n// module, we cannot use it directly to define the EventMap interface keys (TS error: \"Cannot access\n// ambient const enums when the '--isolatedModules' flag is provided.\").\n//\n// Using a plain enum would fix the issue, but would also add 2KB to the minified bundle. By using\n// this workaround, we can keep using a const enum without impacting the bundle size (since it is a\n// \"declare\" statement, it will only be used during typecheck and completely ignored when building\n// JavaScript).\n//\n// See issues:\n// * https://github.com/DataDog/browser-sdk/issues/2208\n// * https://github.com/microsoft/TypeScript/issues/54152\ndeclare const LifeCycleEventTypeAsConst: {\n  PERFORMANCE_ENTRIES_COLLECTED: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED\n  AUTO_ACTION_COMPLETED: LifeCycleEventType.AUTO_ACTION_COMPLETED\n  VIEW_CREATED: LifeCycleEventType.VIEW_CREATED\n  VIEW_UPDATED: LifeCycleEventType.VIEW_UPDATED\n  VIEW_ENDED: LifeCycleEventType.VIEW_ENDED\n  REQUEST_STARTED: LifeCycleEventType.REQUEST_STARTED\n  REQUEST_COMPLETED: LifeCycleEventType.REQUEST_COMPLETED\n  SESSION_EXPIRED: LifeCycleEventType.SESSION_EXPIRED\n  SESSION_RENEWED: LifeCycleEventType.SESSION_RENEWED\n  PAGE_EXITED: LifeCycleEventType.PAGE_EXITED\n  RAW_RUM_EVENT_COLLECTED: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED\n  RUM_EVENT_COLLECTED: LifeCycleEventType.RUM_EVENT_COLLECTED\n  RAW_ERROR_COLLECTED: LifeCycleEventType.RAW_ERROR_COLLECTED\n}\n\n// Note: this interface needs to be exported even if it is not used outside of this module, else TS\n// fails to build the rum-core package with error TS4058\nexport interface LifeCycleEventMap {\n  [LifeCycleEventTypeAsConst.PERFORMANCE_ENTRIES_COLLECTED]: RumPerformanceEntry[]\n  [LifeCycleEventTypeAsConst.AUTO_ACTION_COMPLETED]: AutoAction\n  [LifeCycleEventTypeAsConst.VIEW_CREATED]: ViewCreatedEvent\n  [LifeCycleEventTypeAsConst.VIEW_UPDATED]: ViewEvent\n  [LifeCycleEventTypeAsConst.VIEW_ENDED]: ViewEndedEvent\n  [LifeCycleEventTypeAsConst.REQUEST_STARTED]: RequestStartEvent\n  [LifeCycleEventTypeAsConst.REQUEST_COMPLETED]: RequestCompleteEvent\n  [LifeCycleEventTypeAsConst.SESSION_EXPIRED]: void\n  [LifeCycleEventTypeAsConst.SESSION_RENEWED]: void\n  [LifeCycleEventTypeAsConst.PAGE_EXITED]: PageExitEvent\n  [LifeCycleEventTypeAsConst.RAW_RUM_EVENT_COLLECTED]: RawRumEventCollectedData\n  [LifeCycleEventTypeAsConst.RUM_EVENT_COLLECTED]: RumEvent & Context\n  [LifeCycleEventTypeAsConst.RAW_ERROR_COLLECTED]: {\n    error: RawError\n    savedCommonContext?: CommonContext\n    customerContext?: Context\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  savedCommonContext?: CommonContext\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n", "import type { RelativeTime, ClocksState } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ValueHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { ViewCreatedEvent } from '../rumEventsCollection/view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewContext {\n  service?: string\n  version?: string\n  id: string\n  name?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewContexts {\n  findView: (startTime?: RelativeTime) => ViewContext | undefined\n  stop: () => void\n}\n\nexport function startViewContexts(lifeCycle: LifeCycle): ViewContexts {\n  const viewContextHistory = new ValueHistory<ViewContext>(VIEW_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    viewContextHistory.add(buildViewContext(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    viewContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewContextHistory.reset()\n  })\n\n  function buildViewContext(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      id: view.id,\n      name: view.name,\n      startClocks: view.startClocks,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewContextHistory.find(startTime),\n    stop: () => {\n      viewContextHistory.stop()\n    },\n  }\n}\n", "import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchResolveContext,\n} from '@datadog/browser-core'\nimport {\n  RequestType,\n  initFetchObservable,\n  initXhrObservable,\n  readBytesFromStream,\n  elapsed,\n  timeStampNow,\n  tryToClone,\n} from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchResolveContext extends FetchResolveContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: unknown\n  init?: RequestInit\n  error?: Error\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable().subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchResolveContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'resolve':\n        waitForResponseToComplete(context, (duration: Duration) => {\n          tracer.clearTracingIfNeeded(context)\n          lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n            duration,\n            method: context.method,\n            requestIndex: context.requestIndex,\n            responseType: context.responseType,\n            spanId: context.spanId,\n            startClocks: context.startClocks,\n            status: context.status,\n            traceId: context.traceId,\n            traceSampled: context.traceSampled,\n            type: RequestType.FETCH,\n            url: context.url,\n            response: context.response,\n            init: context.init,\n            input: context.input,\n          })\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n\nfunction waitForResponseToComplete(context: RumFetchResolveContext, callback: (duration: Duration) => void) {\n  const clonedResponse = context.response && tryToClone(context.response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // do not try to wait for the response if the clone failed, fetch error or null body\n    callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n  } else {\n    readBytesFromStream(\n      clonedResponse.body,\n      () => {\n        callback(elapsed(context.startClocks.timeStamp, timeStampNow()))\n      },\n      {\n        bytesLimit: Number.POSITIVE_INFINITY,\n        collectStreamBody: false,\n      }\n    )\n  }\n}\n", "import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumActionEvent, RumErrorEvent, RumLongTaskEvent, RumResourceEvent } from '../rumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts({\n  lifeCycle,\n  isChildEvent,\n  onChange: callback = noop,\n}: {\n  lifeCycle: LifeCycle\n  isChildEvent: (event: RumActionEvent | RumErrorEvent | RumLongTaskEvent | RumResourceEvent) => boolean\n  onChange?: () => void\n}) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    if (event.type === 'view' || !isChildEvent(event)) {\n      return\n    }\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback()\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback()\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback()\n        break\n      case RumEventType.RESOURCE:\n        eventCounts.resourceCount += 1\n        callback()\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n", "import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport {\n  instrumentMethodAndCallOriginal,\n  matchList,\n  monitor,\n  Observable,\n  timeStampNow,\n  setTimeout,\n  clearTimeout,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration !== undefined\n      ? setTimeout(\n          monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n          maxDuration\n        )\n      : undefined\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  const observable = new Observable<PageActivityEvent>(() => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (entries.some((entry) => entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n\n  return observable\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethodAndCallOriginal(window, 'open', { before: callback })\n}\n", "import type { TimeoutId } from '@datadog/browser-core'\nimport { ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeoutId: TimeoutId | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    maxDurationBetweenClicksTimeoutId = setTimeout(dontAcceptMoreClick, MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeoutId)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n", "import { safeTruncate, isIE, find } from '@datadog/browser-core'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\n\nexport function getActionNameFromElement(element: Element, userProgrammaticAttribute?: string): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return (\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = element.parentElement\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute) => getTextualContent(element, userProgrammaticAttribute),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[]\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = element.parentElement\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(element: Element | HTMLElement, userProgrammaticAttribute: string | undefined) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n", "import { cssEscape } from '@datadog/browser-core'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\ntype SelectorGetter = (element: Element, actionNameAttribute: string | undefined) => string | undefined\n\n// Selectors to use if they target a single element on the whole document. Those selectors are\n// considered as \"stable\" and uniquely identify an element regardless of the page state. If we find\n// one, we should consider the selector \"complete\" and stop iterating over ancestors.\nconst GLOBALLY_UNIQUE_SELECTOR_GETTERS: SelectorGetter[] = [getStableAttributeSelector, getIDSelector]\n\n// Selectors to use if they target a single element among an element descendants. Those selectors\n// are more brittle than \"globally unique\" selectors and should be combined with ancestor selectors\n// to improve specificity.\nconst UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS: SelectorGetter[] = [\n  getStableAttributeSelector,\n  getClassSelector,\n  getTagNameSelector,\n]\n\nexport function getSelectorFromElement(targetElement: Element, actionNameAttribute: string | undefined) {\n  let targetElementSelector = ''\n  let element: Element | null = targetElement\n\n  while (element && element.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      element,\n      GLOBALLY_UNIQUE_SELECTOR_GETTERS,\n      isSelectorUniqueGlobally,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    if (globallyUniqueSelector) {\n      return globallyUniqueSelector\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      element,\n      UNIQUE_AMONG_CHILDREN_SELECTOR_GETTERS,\n      isSelectorUniqueAmongSiblings,\n      actionNameAttribute,\n      targetElementSelector\n    )\n    targetElementSelector =\n      uniqueSelectorAmongChildren || combineSelector(getPositionSelector(element), targetElementSelector)\n\n    element = element.parentElement\n  }\n\n  return targetElementSelector\n}\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value)\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  if (element.classList.length > 0) {\n    for (let i = 0; i < element.classList.length; i += 1) {\n      const className = element.classList[i]\n      if (isGeneratedValue(className)) {\n        continue\n      }\n\n      return `${element.tagName}.${cssEscape(className)}`\n    }\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return element.tagName\n}\n\nfunction getStableAttributeSelector(element: Element, actionNameAttribute: string | undefined): string | undefined {\n  if (actionNameAttribute) {\n    const selector = getAttributeSelector(actionNameAttribute)\n    if (selector) {\n      return selector\n    }\n  }\n\n  for (const attributeName of STABLE_ATTRIBUTES) {\n    const selector = getAttributeSelector(attributeName)\n    if (selector) {\n      return selector\n    }\n  }\n\n  function getAttributeSelector(attributeName: string) {\n    if (element.hasAttribute(attributeName)) {\n      return `${element.tagName}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n    }\n  }\n}\n\nfunction getPositionSelector(element: Element): string {\n  let sibling = element.parentElement!.firstElementChild\n  let elementIndex = 1\n\n  while (sibling && sibling !== element) {\n    if (sibling.tagName === element.tagName) {\n      elementIndex += 1\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return `${element.tagName}:nth-of-type(${elementIndex})`\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: SelectorGetter[],\n  predicate: (element: Element, selector: string) => boolean,\n  actionNameAttribute: string | undefined,\n  childSelector?: string\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element, actionNameAttribute)\n    if (!elementSelector) {\n      continue\n    }\n    const fullSelector = combineSelector(elementSelector, childSelector)\n    if (predicate(element, fullSelector)) {\n      return fullSelector\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element: Element, selector: string): boolean {\n  return element.ownerDocument.querySelectorAll(selector).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element: Element, selector: string): boolean {\n  return (\n    element.parentElement!.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector)\n      .length === 1\n  )\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n", "import { addEventListener, DOM_EVENT } from '@datadog/browser-core'\n\nexport type MouseEventOnElement = PointerEvent & { target: Element }\n\nexport interface UserActivity {\n  selection: boolean\n  input: boolean\n}\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onPointerUp: (context: ClickContext, event: MouseEventOnElement, getUserActivity: () => UserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>({ onPointerDown, onPointerUp }: ActionEventsHooks<ClickContext>) {\n  let selectionEmptyAtPointerDown: boolean\n  let userActivity: UserActivity = {\n    selection: false,\n    input: false,\n  }\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event)) {\n          selectionEmptyAtPointerDown = isSelectionEmpty()\n          userActivity = {\n            selection: false,\n            input: false,\n          }\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          userActivity.selection = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.POINTER_UP,\n      (event: PointerEvent) => {\n        if (isValidPointerEvent(event) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const localUserActivity = userActivity\n          onPointerUp(clickContext, event, () => localUserActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        userActivity.input = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isValidPointerEvent(event: PointerEvent): event is MouseEventOnElement {\n  return (\n    event.target instanceof Element &&\n    // Only consider 'primary' pointer events for now. Multi-touch support could be implemented in\n    // the future.\n    event.isPrimary !== false\n  )\n}\n", "import { elementMatches, ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../../rawRumEvent.types'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // contenteditable and their descendants don't always trigger meaningful changes when manipulated\n  '[contenteditable],' +\n  '[contenteditable] *,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input) {\n    return false\n  }\n  return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n", "import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  includes,\n  timeStampNow,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ValueHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../../rawRumEvent.types'\nimport { ActionType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { PAGE_ACTIVITY_VALIDATION_DELAY, waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport { getSelectorFromElement } from './getSelectorFromElement'\nimport type { MouseEventOnElement, UserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ValueHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ValueHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<{\n    clickActionBase: ClickActionBase\n    hadActivityOnPointerDown: () => boolean\n  }>({\n    onPointerDown: (pointerDownEvent) =>\n      processPointerDown(configuration, lifeCycle, domMutationObservable, history, pointerDownEvent),\n    onPointerUp: ({ clickActionBase, hadActivityOnPointerDown }, startEvent, getUserActivity) =>\n      startClickAction(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        startEvent,\n        getUserActivity,\n        hadActivityOnPointerDown\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) =>\n      configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  pointerDownEvent: MouseEventOnElement\n) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return\n  }\n\n  let hadActivityOnPointerDown = false\n\n  waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      hadActivityOnPointerDown = pageActivityEndEvent.hadActivity\n    },\n    // We don't care about the activity duration, we just want to know whether an activity did happen\n    // within the \"validation delay\" or not. Limit the duration so the callback is called sooner.\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n\n  return { clickActionBase, hadActivityOnPointerDown: () => hadActivityOnPointerDown }\n}\n\nfunction startClickAction(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement,\n  getUserActivity: () => UserActivity,\n  hadActivityOnPointerDown: () => boolean\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent)\n\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        if (pageActivityEndEvent.hadActivity) {\n          click.stop(pageActivityEndEvent.end)\n        } else if (hadActivityOnPointerDown()) {\n          click.stop(\n            // using the click start as activity end, so the click will have some activity but its\n            // duration will be 0 (as the activity started before the click start)\n            click.startClocks.timeStamp\n          )\n        } else {\n          click.stop()\n        }\n\n        // Validate or discard the click only if we don't track frustrations. It'll be done when\n        // the click chain is finalized.\n        if (!configuration.trackFrustrations) {\n          if (!pageActivityEndEvent.hadActivity) {\n            // If we are not tracking frustrations, we should discard the click to keep backward\n            // compatibility.\n            click.discard()\n          } else {\n            click.validate()\n          }\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  const rect = event.target.getBoundingClientRect()\n  return {\n    type: ActionType.CLICK,\n    target: {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height),\n      selector: getSelectorFromElement(event.target, actionNameAttribute),\n    },\n    position: {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    },\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: () => UserActivity,\n  clickActionBase: ClickActionBase,\n  startEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) =>\n      event.action !== undefined &&\n      (Array.isArray(event.action.id) ? includes(event.action.id, id) : event.action.id === id),\n  })\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: startEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [startEvent],\n          event: startEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n", "import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, assign, combine, toServerDuration, generateUUID } from '@datadog/browser-core'\n\nimport type { RawRumActionEvent } from '../../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumConfiguration } from '../../configuration'\nimport type { CommonContext } from '../../contexts/commonContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action, pageStateHistory))\n  )\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  if (configuration.trackUserInteractions) {\n    actionContexts = trackClickActions(lifeCycle, domMutationObservable, configuration).actionContexts\n  }\n\n  return {\n    addAction: (action: CustomAction, savedCommonContext?: CommonContext) => {\n      lifeCycle.notify(\n        LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n        assign(\n          {\n            savedCommonContext,\n          },\n          processAction(action, pageStateHistory)\n        )\n      )\n    },\n    actionContexts,\n  }\n}\n\nfunction processAction(\n  action: AutoAction | CustomAction,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: toServerDuration(action.duration),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n          },\n        },\n      }\n    : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: {\n        id: generateUUID(),\n        target: {\n          name: action.name,\n        },\n        type: action.type,\n      },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION as const,\n      view: { in_foreground: pageStateHistory.isInActivePageStateAt(action.startClocks.relative) },\n    },\n    autoActionProperties\n  )\n\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    startTime: action.startClocks.relative,\n    domainContext: isAutoAction(action) ? { event: action.event, events: action.events } : {},\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n", "import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, initConsoleObservable, ErrorSource, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: consoleError.message,\n      stack: consoleError.stack,\n      fingerprint: consoleError.fingerprint,\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      handlingStack: consoleError.handlingStack,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n", "import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, ErrorSource, initReportObservable, RawReportType } from '@datadog/browser-core'\n\nexport function trackReportError(errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable([RawReportType.cspViolation, RawReportType.intervention]).subscribe(\n    (reportError) =>\n      errorObservable.notify({\n        startClocks: clocksNow(),\n        message: reportError.message,\n        stack: reportError.stack,\n        type: reportError.subtype,\n        source: ErrorSource.REPORT,\n        handling: ErrorHandling.UNHANDLED,\n      })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n", "import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  isEmptyObject,\n  assign,\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  Observable,\n  trackRuntimeError,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\nimport type { RawRumErrorEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { FeatureFlagContexts } from '../../contexts/featureFlagContext'\nimport type { CommonContext } from '../../contexts/commonContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startErrorCollection(\n  lifeCycle: LifeCycle,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts)\n}\n\nexport function doStartErrorCollection(\n  lifeCycle: LifeCycle,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext, savedCommonContext }) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      assign(\n        {\n          customerContext,\n          savedCommonContext,\n        },\n        processError(error, pageStateHistory, featureFlagContexts)\n      )\n    )\n  })\n\n  return {\n    addError: (\n      { error, handlingStack, startClocks, context: customerContext }: ProvidedError,\n      savedCommonContext?: CommonContext\n    ) => {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        handlingStack,\n        startClocks,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        savedCommonContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(\n  error: RawError,\n  pageStateHistory: PageStateHistory,\n  featureFlagContexts: FeatureFlagContexts\n): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n      fingerprint: error.fingerprint,\n    },\n    type: RumEventType.ERROR as const,\n    view: { in_foreground: pageStateHistory.isInActivePageStateAt(error.startClocks.relative) },\n  }\n\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(error.startClocks.relative)\n  if (featureFlagContext && !isEmptyObject(featureFlagContext)) {\n    rawRumEvent.feature_flags = featureFlagContext\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext: {\n      error: error.originalError,\n    },\n  }\n}\n", "import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumSessionManager } from '../../rumSessionManager'\n\nexport function startLongTaskCollection(lifeCycle: LifeCycle, sessionManager: RumSessionManager) {\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== 'longtask') {\n        break\n      }\n      const session = sessionManager.findTrackedSession(entry.startTime)\n      if (!session || !session.longTaskAllowed) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        domainContext: { performanceEntry: entry.toJSON() },\n      })\n    }\n  })\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport { toValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource')\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .map((entry) => entry.toJSON() as RumPerformanceResourceTiming)\n    .filter(toValidEntry)\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    return candidates[0]\n  }\n\n  return\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n", "import {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  assign,\n  isNumber,\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\nimport type { ClocksState, Duration } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RumPerformanceEntry, RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type {\n  PerformanceEntryRepresentation,\n  RumXhrResourceEventDomainContext,\n  RumFetchResourceEventDomainContext,\n} from '../../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport { PageState } from '../../contexts/pageStateHistory'\nimport { matchRequestTiming } from './matchRequestTiming'\nimport {\n  computePerformanceResourceDetails,\n  computePerformanceResourceDuration,\n  computeResourceKind,\n  computeSize,\n  isRequestKind,\n} from './resourceUtils'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processRequest(request, configuration, sessionManager, pageStateHistory)\n    )\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'resource' && !isRequestKind(entry)) {\n        lifeCycle.notify(\n          LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n          processResourceEntry(entry, configuration, sessionManager, pageStateHistory)\n        )\n      }\n    }\n  })\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const matchingTiming = matchRequestTiming(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined\n\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const duration = computeRequestDuration(pageStateHistory, startClocks, request.duration)\n  const pageStateInfo = computePageStateInfo(\n    pageStateHistory,\n    startClocks,\n    matchingTiming?.duration ?? request.duration\n  )\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration,\n        method: request.method,\n        status_code: request.status,\n        url: request.url,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    correspondingTimingOverrides,\n    indexingInfo,\n    pageStateInfo\n  )\n\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming && toPerformanceEntryRepresentation(matchingTiming),\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = computeResourceKind(entry)\n  const entryMetrics = computePerformanceEntryMetrics(entry)\n  const startClocks = relativeToClocks(entry.startTime)\n\n  const tracingInfo = computeEntryTracingInfo(entry, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n  const pageStateInfo = computePageStateInfo(pageStateHistory, startClocks, entry.duration)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        url: entry.name,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    entryMetrics,\n    indexingInfo,\n    pageStateInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: toPerformanceEntryRepresentation(entry),\n    },\n  }\n}\n\nfunction computePerformanceEntryMetrics(timing: RumPerformanceResourceTiming) {\n  return {\n    resource: assign(\n      {\n        duration: computePerformanceResourceDuration(timing),\n        size: computeSize(timing),\n      },\n      computePerformanceResourceDetails(timing)\n    ),\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toDecimalString(),\n      trace_id: request.traceId!.toDecimalString(),\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\nfunction computeEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\n// TODO next major: use directly PerformanceEntry type in domain context\nfunction toPerformanceEntryRepresentation(entry: RumPerformanceEntry): PerformanceEntryRepresentation {\n  return entry as PerformanceEntryRepresentation\n}\n\n/**\n * @returns number between 0 and 1 which represents trace sample rate\n */\nfunction getRulePsr(configuration: RumConfiguration) {\n  return isNumber(configuration.traceSampleRate) ? configuration.traceSampleRate / 100 : undefined\n}\n\nfunction computeIndexingInfo(sessionManager: RumSessionManager, resourceStart: ClocksState) {\n  const session = sessionManager.findTrackedSession(resourceStart.relative)\n  return {\n    _dd: {\n      discarded: !session || !session.resourceAllowed,\n    },\n  }\n}\n\nfunction computePageStateInfo(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.RESOURCE_PAGE_STATES)) {\n    return\n  }\n\n  return {\n    _dd: {\n      page_states: pageStateHistory.findAll(startClocks.relative, duration),\n      page_was_discarded: String((document as any).wasDiscarded),\n    },\n  }\n}\n\nfunction computeRequestDuration(pageStateHistory: PageStateHistory, startClocks: ClocksState, duration: Duration) {\n  // TODO remove FF in next major\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.NO_RESOURCE_DURATION_FROZEN_STATE)) {\n    return toServerDuration(duration)\n  }\n\n  const requestCrossedFrozenState = pageStateHistory\n    .findAll(startClocks.relative, duration)\n    ?.some((pageState) => pageState.state === PageState.FROZEN)\n\n  return !requestCrossedFrozenState ? toServerDuration(duration) : undefined\n}\n", "import type { RelativeTime, Duration, ServerDuration } from '@datadog/browser-core'\nimport { toServerDuration } from '@datadog/browser-core'\nimport type { InForegroundPeriod, PageStateServerEntry } from '../../rawRumEvent.types'\nimport { PageState } from './pageStateHistory'\n\nexport interface ForegroundPeriod {\n  start: RelativeTime\n  end?: RelativeTime\n}\n\n// Todo: Remove in the next major release\nexport function mapToForegroundPeriods(\n  pageStateServerEntries: PageStateServerEntry[],\n  duration: Duration\n): InForegroundPeriod[] {\n  const foregroundPeriods: InForegroundPeriod[] = []\n  for (let i = 0; i < pageStateServerEntries.length; i++) {\n    const current = pageStateServerEntries[i]\n    const next = pageStateServerEntries[i + 1]\n\n    if (current.state === PageState.ACTIVE) {\n      const start = current.start >= 0 ? current.start : (0 as ServerDuration)\n      const end = next ? next.start : toServerDuration(duration)\n      foregroundPeriods.push({\n        start,\n        duration: (end - start) as ServerDuration,\n      })\n    }\n  }\n\n  return foregroundPeriods\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\n\nlet trackFirstHiddenSingleton: { timeStamp: RelativeTime } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function trackFirstHidden(eventTarget: Window = window) {\n  if (!trackFirstHiddenSingleton) {\n    if (document.visibilityState === 'hidden') {\n      trackFirstHiddenSingleton = {\n        timeStamp: 0 as RelativeTime,\n      }\n    } else {\n      trackFirstHiddenSingleton = {\n        timeStamp: Infinity as RelativeTime,\n      }\n      ;({ stop: stopListeners } = addEventListeners(\n        eventTarget,\n        [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n        (event) => {\n          if (event.type === 'pagehide' || document.visibilityState === 'hidden') {\n            trackFirstHiddenSingleton!.timeStamp = event.timeStamp as RelativeTime\n            stopListeners!()\n          }\n        },\n        { capture: true }\n      ))\n    }\n  }\n\n  return trackFirstHiddenSingleton\n}\n\nexport function resetFirstHidden() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  trackFirstHiddenSingleton = undefined\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  setTimeout,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  elapsed,\n  ONE_MINUTE,\n  find,\n  findLast,\n  relativeNow,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type {\n  RumFirstInputTiming,\n  RumLargestContentfulPaintTiming,\n  RumPerformancePaintTiming,\n} from '../../../browser/performanceCollection'\nimport { trackFirstHidden } from './trackFirstHidden'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\n/**\n * The initial view can finish quickly, before some metrics can be produced (ex: before the page load\n * event, or the first input). Also, we don't want to trigger a view update indefinitely, to avoid\n * updates on views that ended a long time ago. Keep watching for metrics after the view ends for a\n * limited amount of time.\n */\nexport const KEEP_TRACKING_TIMINGS_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport interface Timings {\n  firstContentfulPaint?: Duration\n  firstByte?: Duration\n  domInteractive?: Duration\n  domContentLoaded?: Duration\n  domComplete?: Duration\n  loadEvent?: Duration\n  largestContentfulPaint?: Duration\n  firstInputDelay?: Duration\n  firstInputTime?: Duration\n}\n\nexport function trackInitialViewTimings(\n  lifeCycle: LifeCycle,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  setLoadEvent: (loadEnd: Duration) => void,\n  scheduleViewUpdate: () => void\n) {\n  const timings: Timings = {}\n\n  function setTimings(newTimings: Partial<Timings>) {\n    assign(timings, newTimings)\n    scheduleViewUpdate()\n  }\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, (newTimings) => {\n    setLoadEvent(newTimings.loadEvent)\n    setTimings(newTimings)\n  })\n  const { stop: stopFCPTracking } = trackFirstContentfulPaintTiming(lifeCycle, (firstContentfulPaint) =>\n    setTimings({ firstContentfulPaint })\n  )\n  const { stop: stopLCPTracking } = trackLargestContentfulPaintTiming(\n    lifeCycle,\n    window,\n    (largestContentfulPaint, lcpElement) => {\n      webVitalTelemetryDebug.addWebVitalTelemetryDebug('LCP', lcpElement, largestContentfulPaint)\n\n      setTimings({\n        largestContentfulPaint,\n      })\n    }\n  )\n\n  const { stop: stopFIDTracking } = trackFirstInputTimings(\n    lifeCycle,\n    ({ firstInputDelay, firstInputTime, firstInputTarget }) => {\n      webVitalTelemetryDebug.addWebVitalTelemetryDebug('FID', firstInputTarget, firstInputTime)\n\n      setTimings({\n        firstInputDelay,\n        firstInputTime,\n      })\n    }\n  )\n\n  function stop() {\n    stopNavigationTracking()\n    stopFCPTracking()\n    stopLCPTracking()\n    stopFIDTracking()\n  }\n\n  return {\n    stop,\n    timings,\n    scheduleStop: () => {\n      setTimeout(stop, KEEP_TRACKING_TIMINGS_AFTER_VIEW_DELAY)\n    },\n  }\n}\n\ninterface NavigationTimings {\n  domComplete: Duration\n  domContentLoaded: Duration\n  domInteractive: Duration\n  loadEvent: Duration\n  firstByte: Duration | undefined\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: NavigationTimings) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n\nexport function trackFirstContentfulPaintTiming(lifeCycle: LifeCycle, callback: (fcpTiming: RelativeTime) => void) {\n  const firstHidden = trackFirstHidden()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const fcpEntry = find(\n      entries,\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.entryType === 'paint' &&\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < TIMING_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return { stop }\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  eventTarget: Window,\n  callback: (lcpTiming: RelativeTime, lcpElement?: Element) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    eventTarget,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === 'largest-contentful-paint' &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < TIMING_MAXIMUM_DELAY\n      )\n      if (lcpEntry) {\n        callback(lcpEntry.startTime, lcpEntry.element)\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(\n  lifeCycle: LifeCycle,\n  callback: ({\n    firstInputDelay,\n    firstInputTime,\n    firstInputTarget,\n  }: {\n    firstInputDelay: Duration\n    firstInputTime: RelativeTime\n    firstInputTarget: Node | undefined\n  }) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const firstInputEntry = find(\n      entries,\n      (entry): entry is RumFirstInputTiming =>\n        entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        firstInputTime: firstInputEntry.startTime,\n        firstInputTarget: firstInputEntry.target,\n      })\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n", "export function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n", "import type { ClocksState, Duration, Observable, RelativeTime } from '@datadog/browser-core'\nimport {\n  ExperimentalFeature,\n  isExperimentalFeatureEnabled,\n  DOM_EVENT,\n  ONE_SECOND,\n  addEventListener,\n  elapsed,\n  noop,\n  relativeNow,\n  round,\n  throttle,\n  find,\n} from '@datadog/browser-core'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\n\nimport { getScrollY } from '../../../browser/scroll'\nimport { getViewportDimension } from '../../../browser/viewportObservable'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport interface ScrollMetrics {\n  maxDepth: number\n  maxDepthScrollHeight: number\n  maxDepthScrollTop: number\n  maxDepthTime: Duration\n}\n\n/** Arbitrary scroll throttle duration */\nexport const THROTTLE_SCROLL_DURATION = ONE_SECOND\n\nexport interface ViewMetrics {\n  loadingTime?: Duration\n  cumulativeLayoutShift?: number\n}\n\nexport function trackViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug\n) {\n  const viewMetrics: ViewMetrics = {}\n\n  let scrollMetrics: ScrollMetrics | undefined\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      viewMetrics.loadingTime = newLoadingTime\n\n      // We compute scroll metrics at loading time to ensure we have scroll data when loading the view initially\n      // This is to ensure that we have the depth data even if the user didn't scroll or if the view is not scrollable.\n      if (isExperimentalFeatureEnabled(ExperimentalFeature.SCROLLMAP)) {\n        const { scrollHeight, scrollDepth, scrollTop } = computeScrollValues()\n\n        scrollMetrics = {\n          maxDepth: scrollDepth,\n          maxDepthScrollHeight: scrollHeight,\n          maxDepthTime: newLoadingTime,\n          maxDepthScrollTop: scrollTop,\n        }\n      }\n      scheduleViewUpdate()\n    }\n  )\n\n  const { stop: stopScrollMetricsTracking } = trackScrollMetrics(\n    viewStart,\n    (newScrollMetrics) => {\n      scrollMetrics = newScrollMetrics\n    },\n    computeScrollValues\n  )\n\n  let stopCLSTracking: () => void\n  let clsAttributionCollected = false\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0\n    ;({ stop: stopCLSTracking } = trackCumulativeLayoutShift(\n      lifeCycle,\n      (cumulativeLayoutShift, largestLayoutShiftNode, largestLayoutShiftTime) => {\n        viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n\n        if (!clsAttributionCollected) {\n          clsAttributionCollected = true\n          webVitalTelemetryDebug.addWebVitalTelemetryDebug('CLS', largestLayoutShiftNode, largestLayoutShiftTime)\n        }\n        scheduleViewUpdate()\n      }\n    ))\n  } else {\n    stopCLSTracking = noop\n  }\n\n  return {\n    stop: () => {\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n      stopScrollMetricsTracking()\n    },\n    setLoadEvent,\n    viewMetrics,\n    getScrollMetrics: () => scrollMetrics,\n  }\n}\n\nexport function trackScrollMetrics(\n  viewStart: ClocksState,\n  callback: (scrollMetrics: ScrollMetrics) => void,\n  getScrollValues = computeScrollValues\n) {\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.SCROLLMAP)) {\n    return { stop: noop }\n  }\n  let maxDepth = 0\n  const handleScrollEvent = throttle(\n    () => {\n      const { scrollHeight, scrollDepth, scrollTop } = getScrollValues()\n\n      if (scrollDepth > maxDepth) {\n        const now = relativeNow()\n        const maxDepthTime = elapsed(viewStart.relative, now)\n        maxDepth = scrollDepth\n        callback({\n          maxDepth,\n          maxDepthScrollHeight: scrollHeight,\n          maxDepthTime,\n          maxDepthScrollTop: scrollTop,\n        })\n      }\n    },\n    THROTTLE_SCROLL_DURATION,\n    { leading: false, trailing: true }\n  )\n\n  const { stop } = addEventListener(window, DOM_EVENT.SCROLL, handleScrollEvent.throttled, { passive: true })\n\n  return {\n    stop: () => {\n      handleScrollEvent.cancel()\n      stop()\n    },\n  }\n}\n\nfunction computeScrollValues() {\n  const scrollTop = getScrollY()\n\n  const { height } = getViewportDimension()\n\n  const scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight)\n  const scrollDepth = Math.round(height + scrollTop)\n\n  return {\n    scrollHeight,\n    scrollDepth,\n    scrollTop,\n  }\n}\n\nfunction trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(\n  lifeCycle: LifeCycle,\n  callback: (layoutShift: number, largestShiftNode: Node | undefined, largestShiftTime: RelativeTime) => void\n) {\n  let maxClsValue = 0\n\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry)\n\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          callback(round(maxClsValue, 4), window.largestLayoutShiftNode(), window.largestLayoutShiftTime())\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n\n  let largestLayoutShift = 0\n  let largestLayoutShiftNode: Node | undefined\n  let largestLayoutShiftTime: RelativeTime\n\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n        largestLayoutShift = 0\n        largestLayoutShiftNode = undefined\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n\n      if (entry.value > largestLayoutShift) {\n        largestLayoutShift = entry.value\n        largestLayoutShiftTime = entry.startTime\n\n        if (entry.sources?.length) {\n          const largestLayoutShiftSource = find(entry.sources, (s) => s.node?.nodeType === 1) || entry.sources[0]\n          largestLayoutShiftNode = largestLayoutShiftSource.node\n        } else {\n          largestLayoutShiftNode = undefined\n        }\n      }\n    },\n    value: () => value,\n    largestLayoutShiftNode: () => largestLayoutShiftNode,\n    largestLayoutShiftTime: () => largestLayoutShiftTime,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift')\n}\n", "import { ONE_MINUTE, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\n\n// Some events are not being counted as they transcend views. To reduce the occurrence;\n// an arbitrary delay is added for stopping event counting after the view ends.\n//\n// Ideally, we would not stop and keep counting events until the end of the session.\n// But this might have a small performance impact if there are many many views:\n// we would need to go through each event to see if the related view matches.\n// So let's have a fairly short delay to avoid impacting performances too much.\n//\n// In the future, we could have views stored in a data structure similar to ContextHistory. Whenever\n// a child event is collected, we could look into this history to find the matching view and\n// increase the associated and increase its counter. Having a centralized data structure for it\n// would allow us to look for views more efficiently.\n//\n// For now, having a small cleanup delay will already improve the situation in most cases.\n\nexport const KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY = 5 * ONE_MINUTE\n\nexport function trackViewEventCounts(lifeCycle: LifeCycle, viewId: string, onChange: () => void) {\n  const { stop, eventCounts } = trackEventCounts({\n    lifeCycle,\n    isChildEvent: (event) => event.view.id === viewId,\n    onChange,\n  })\n\n  return {\n    scheduleStop: () => {\n      setTimeout(stop, KEEP_TRACKING_EVENT_COUNTS_AFTER_VIEW_DELAY)\n    },\n    eventCounts,\n  }\n}\n", "import type { Duration, ClocksState, TimeStamp, Observable, Subscription, RelativeTime } from '@datadog/browser-core'\nimport {\n  noop,\n  PageExitReason,\n  shallowClone,\n  assign,\n  elapsed,\n  generateUUID,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n  setInterval,\n  clearInterval,\n} from '@datadog/browser-core'\n\nimport type { ViewCustomTimings } from '../../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { Timings } from './trackInitialViewTimings'\nimport { trackInitialViewTimings } from './trackInitialViewTimings'\nimport type { ScrollMetrics } from './trackViewMetrics'\nimport { trackViewMetrics } from './trackViewMetrics'\nimport { trackViewEventCounts } from './trackViewEventCounts'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  location: Readonly<Location>\n  timings: Timings\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  sessionIsActive: boolean\n  loadingTime?: Duration\n  loadingType: ViewLoadingType\n  cumulativeLayoutShift?: number\n  scrollMetrics?: ScrollMetrics\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: string\n  version?: string\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  initialViewOptions?: ViewOptions\n) {\n  let currentView = startNewView(ViewLoadingType.INITIAL_LOAD, clocksOrigin(), initialViewOptions)\n\n  startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n  }\n\n  function startNewView(loadingType: ViewLoadingType, startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    return newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      loadingType,\n      webVitalTelemetryDebug,\n      startClocks,\n      viewOptions\n    )\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // Renew view on session renewal\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n      })\n    })\n\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n      currentView.end({ sessionIsActive: false })\n    })\n\n    // End the current view on page unload\n    lifeCycle.subscribe(LifeCycleEventType.PAGE_EXITED, (pageExitEvent) => {\n      if (pageExitEvent.reason === PageExitReason.UNLOADING || pageExitEvent.reason === PageExitReason.PAGEHIDE) {\n        currentView.end()\n      }\n    })\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView = startNewView(ViewLoadingType.ROUTE_CHANGE)\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end({ endClocks: startClocks })\n      currentView = startNewView(ViewLoadingType.ROUTE_CHANGE, startClocks, options)\n    },\n    stop: () => {\n      locationChangeSubscription?.unsubscribe()\n      currentView.end()\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n\n  let sessionIsActive = true\n  let name: string | undefined\n  let service: string | undefined\n  let version: string | undefined\n  if (viewOptions) {\n    name = viewOptions.name\n    service = viewOptions.service\n    version = viewOptions.version\n  }\n\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, {\n    id,\n    name,\n    startClocks,\n    service,\n    version,\n  })\n\n  // Update the view every time the measures are changing\n  const { throttled: scheduleViewUpdate, cancel: cancelScheduleViewUpdate } = throttle(\n    triggerViewUpdate,\n    THROTTLE_VIEW_UPDATE_PERIOD,\n    {\n      leading: false,\n    }\n  )\n\n  const {\n    setLoadEvent,\n    stop: stopViewMetricsTracking,\n    viewMetrics,\n    getScrollMetrics,\n  } = trackViewMetrics(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    scheduleViewUpdate,\n    loadingType,\n    startClocks,\n    webVitalTelemetryDebug\n  )\n\n  const { scheduleStop: scheduleStopInitialViewTimingsTracking, timings } =\n    loadingType === ViewLoadingType.INITIAL_LOAD\n      ? trackInitialViewTimings(lifeCycle, webVitalTelemetryDebug, setLoadEvent, scheduleViewUpdate)\n      : { scheduleStop: noop, timings: {} as Timings }\n\n  const { scheduleStop: scheduleStopEventCountsTracking, eventCounts } = trackViewEventCounts(\n    lifeCycle,\n    id,\n    scheduleViewUpdate\n  )\n\n  // Session keep alive\n  const keepAliveIntervalId = setInterval(triggerViewUpdate, SESSION_KEEP_ALIVE_INTERVAL)\n\n  // Initial view update\n  triggerViewUpdate()\n\n  function triggerViewUpdate() {\n    cancelScheduleViewUpdate()\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n\n    lifeCycle.notify(\n      LifeCycleEventType.VIEW_UPDATED,\n      assign(\n        {\n          customTimings,\n          documentVersion,\n          id,\n          name,\n          service,\n          version,\n          loadingType,\n          location,\n          startClocks,\n          timings,\n          duration: elapsed(startClocks.timeStamp, currentEnd),\n          isActive: endClocks === undefined,\n          sessionIsActive,\n          eventCounts,\n          scrollMetrics: getScrollMetrics(),\n        },\n        viewMetrics\n      )\n    )\n  }\n\n  return {\n    name,\n    service,\n    version,\n    end(options: { endClocks?: ClocksState; sessionIsActive?: boolean } = {}) {\n      if (endClocks) {\n        // view already ended\n        return\n      }\n      endClocks = options.endClocks ?? clocksNow()\n      sessionIsActive = options.sessionIsActive ?? true\n\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      clearInterval(keepAliveIntervalId)\n      stopViewMetricsTracking()\n      scheduleStopInitialViewTimingsTracking()\n      scheduleStopEventCountsTracking()\n      triggerViewUpdate()\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      if (endClocks) {\n        return\n      }\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n      scheduleViewUpdate()\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substr(1)\n  return !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n", "import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport {\n  isExperimentalFeatureEnabled,\n  ExperimentalFeature,\n  isEmptyObject,\n  mapValues,\n  toServerDuration,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RawRumViewEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { mapToForegroundPeriods } from '../../contexts/foregroundContexts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { FeatureFlagContexts } from '../../contexts/featureFlagContext'\nimport type { PageStateHistory } from '../../contexts/pageStateHistory'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport { trackViews } from './trackViews'\nimport type { WebVitalTelemetryDebug } from './startWebVitalTelemetryDebug'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  featureFlagContexts: FeatureFlagContexts,\n  pageStateHistory: PageStateHistory,\n  recorderApi: RecorderApi,\n  webVitalTelemetryDebug: WebVitalTelemetryDebug,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processViewUpdate(view, configuration, featureFlagContexts, recorderApi, pageStateHistory)\n    )\n  )\n  const trackViewResult = trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    webVitalTelemetryDebug,\n    initialViewOptions\n  )\n\n  return trackViewResult\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  configuration: RumConfiguration,\n  featureFlagContexts: FeatureFlagContexts,\n  recorderApi: RecorderApi,\n  pageStateHistory: PageStateHistory\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations(view.startClocks.relative)\n  const pageStatesEnabled = isExperimentalFeatureEnabled(ExperimentalFeature.PAGE_STATES)\n  const pageStates = pageStateHistory.findAll(view.startClocks.relative, view.duration)\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n      page_states: pageStatesEnabled ? pageStates : undefined,\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.cumulativeLayoutShift,\n      first_byte: toServerDuration(view.timings.firstByte),\n      dom_complete: toServerDuration(view.timings.domComplete),\n      dom_content_loaded: toServerDuration(view.timings.domContentLoaded),\n      dom_interactive: toServerDuration(view.timings.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.timings.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.timings.firstInputDelay),\n      first_input_time: toServerDuration(view.timings.firstInputTime),\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.timings.largestContentfulPaint),\n      load_event: toServerDuration(view.timings.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n      in_foreground_periods:\n        !pageStatesEnabled && pageStates ? mapToForegroundPeriods(pageStates, view.duration) : undefined, // Todo: Remove in the next major release\n    },\n    feature_flags: featureFlagContext && !isEmptyObject(featureFlagContext) ? featureFlagContext : undefined,\n    display: view.scrollMetrics\n      ? {\n          scroll: {\n            max_depth: view.scrollMetrics.maxDepth,\n            max_depth_scroll_height: view.scrollMetrics.maxDepthScrollHeight,\n            max_depth_scroll_top: view.scrollMetrics.maxDepthScrollTop,\n            max_depth_time: toServerDuration(view.scrollMetrics.maxDepthTime),\n          },\n        }\n      : undefined,\n    session: {\n      has_replay: replayStats ? true : undefined,\n      is_active: view.sessionIsActive ? undefined : false,\n    },\n    privacy: {\n      replay_level: configuration.defaultPrivacyLevel,\n    },\n  }\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n\nfunction discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, noop, performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n  expire: () => void\n  expireObservable: Observable<void>\n}\n\nexport type RumSession = {\n  id: string\n  plan: RumSessionPlan\n  sessionReplayAllowed: boolean\n  longTaskAllowed: boolean\n  resourceAllowed: boolean\n}\n\nexport const enum RumSessionPlan {\n  WITHOUT_SESSION_REPLAY = 1,\n  WITH_SESSION_REPLAY = 2,\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = '0',\n  // Note: the \"tracking type\" value (stored in the session cookie) does not match the \"session\n  // plan\" value (sent in RUM events). This is expected, and was done to keep retrocompatibility\n  // with active sessions when upgrading the SDK.\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport function startRumSessionManager(configuration: RumConfiguration, lifeCycle: LifeCycle): RumSessionManager {\n  const sessionManager = startSessionManager(\n    // TODO - Improve configuration type and remove assertion\n    configuration.sessionStoreStrategyType!,\n    RUM_SESSION_KEY,\n    (rawTrackingType) => computeSessionState(configuration, rawTrackingType)\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      if (!session || !isTypeTracked(session.trackingType)) {\n        return\n      }\n      const plan =\n        session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n          ? RumSessionPlan.WITH_SESSION_REPLAY\n          : RumSessionPlan.WITHOUT_SESSION_REPLAY\n      return {\n        id: session.id,\n        plan,\n        sessionReplayAllowed: plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        longTaskAllowed:\n          configuration.trackLongTasks !== undefined\n            ? configuration.trackLongTasks\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        resourceAllowed:\n          configuration.trackResources !== undefined\n            ? configuration.trackResources\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n      }\n    },\n    expire: sessionManager.expire,\n    expireObservable: sessionManager.expireObservable,\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    plan: RumSessionPlan.WITHOUT_SESSION_REPLAY, // plan value should not be taken into account for mobile\n    sessionReplayAllowed: false,\n    longTaskAllowed: true,\n    resourceAllowed: true,\n  }\n  return {\n    findTrackedSession: () => session,\n    expire: noop,\n    expireObservable: new Observable(),\n  }\n}\n\nfunction computeSessionState(configuration: RumConfiguration, rawTrackingType?: string) {\n  let trackingType: RumTrackingType\n  if (hasValidRumSession(rawTrackingType)) {\n    trackingType = rawTrackingType\n  } else if (!performDraw(configuration.sessionSampleRate)) {\n    trackingType = RumTrackingType.NOT_TRACKED\n  } else if (!performDraw(configuration.sessionReplaySampleRate)) {\n    trackingType = RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  } else {\n    trackingType = RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  }\n  return {\n    trackingType,\n    isTracked: isTypeTracked(trackingType),\n  }\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n\nfunction isTypeTracked(rumSessionType: RumTrackingType | undefined) {\n  return (\n    rumSessionType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY ||\n    rumSessionType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  )\n}\n", "import type {\n  Context,\n  EndpointBuilder,\n  TelemetryEvent,\n  Observable,\n  RawError,\n  PageExitEvent,\n  FlushEvent,\n} from '@datadog/browser-core'\nimport {\n  createFlushController,\n  Batch,\n  combine,\n  createHttpRequest,\n  isTelemetryReplicationAllowed,\n} from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  telemetryEventObservable: Observable<TelemetryEvent & Context>,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const batch = makeRumBatch(configuration, reportError, pageExitObservable, sessionExpireObservable)\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)))\n\n  return batch\n}\n\nexport interface RumBatch {\n  flushObservable: Observable<FlushEvent>\n  add: (message: Context, replicated?: boolean) => void\n  upsert: (message: Context, key: string) => void\n}\n\nfunction makeRumBatch(\n  configuration: RumConfiguration,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n): RumBatch {\n  const { batch: primaryBatch, flushController: primaryFlushController } = createRumBatch(\n    configuration.rumEndpointBuilder\n  )\n  let replicaBatch: Batch | undefined\n  const replica = configuration.replica\n  if (replica !== undefined) {\n    replicaBatch = createRumBatch(replica.rumEndpointBuilder).batch\n  }\n\n  function createRumBatch(endpointBuilder: EndpointBuilder) {\n    const flushController = createFlushController({\n      messagesLimit: configuration.batchMessagesLimit,\n      bytesLimit: configuration.batchBytesLimit,\n      durationLimit: configuration.flushTimeout,\n      pageExitObservable,\n      sessionExpireObservable,\n    })\n\n    const batch = new Batch(\n      createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError),\n      flushController,\n      configuration.messageBytesLimit\n    )\n\n    return {\n      batch,\n      flushController,\n    }\n  }\n\n  function withReplicaApplicationId(message: Context) {\n    return combine(message, { application: { id: replica!.applicationId } })\n  }\n\n  return {\n    flushObservable: primaryFlushController.flushObservable,\n    add: (message: Context, replicated = true) => {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(withReplicaApplicationId(message))\n      }\n    },\n    upsert: (message: Context, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(withReplicaApplicationId(message), key)\n      }\n    },\n  }\n}\n", "import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n", "import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, ValueHistory } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = new ValueHistory<UrlContext>(URL_CONTEXT_TIME_OUT_DELAY)\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n", "import {\n  addEventListener,\n  DOM_EVENT,\n  instrumentMethodAndCallOriginal,\n  Observable,\n  shallowClone,\n} from '@datadog/browser-core'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(location: Location) {\n  let currentLocation = shallowClone(location)\n  const observable = new Observable<LocationChange>(() => {\n    const { stop: stopHistoryTracking } = trackHistory(onLocationChange)\n    const { stop: stopHashTracking } = trackHash(onLocationChange)\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n\n  function onLocationChange() {\n    if (currentLocation.href === location.href) {\n      return\n    }\n    const newLocation = shallowClone(location)\n    observable.notify({\n      newLocation,\n      oldLocation: currentLocation,\n    })\n    currentLocation = newLocation\n  }\n\n  return observable\n}\n\nfunction trackHistory(onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethodAndCallOriginal(history, 'pushState', {\n    after: onHistoryChange,\n  })\n  const { stop: stopInstrumentingReplaceState } = instrumentMethodAndCallOriginal(history, 'replaceState', {\n    after: onHistoryChange,\n  })\n  const { stop: removeListener } = addEventListener(window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(onHashChange: () => void) {\n  return addEventListener(window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n", "import type { RelativeTime, ContextValue, Context } from '@datadog/browser-core'\nimport {\n  CustomerDataType,\n  warnIfCustomerDataLimitReached,\n  throttle,\n  jsonStringify,\n  computeBytesCount,\n  noop,\n  isExperimentalFeatureEnabled,\n  SESSION_TIME_OUT_DELAY,\n  ValueHistory,\n  ExperimentalFeature,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\nexport const FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\nexport const BYTES_COMPUTATION_THROTTLING_DELAY = 200\n\nexport type FeatureFlagContext = Context\n\nexport interface FeatureFlagContexts {\n  findFeatureFlagEvaluations: (startTime?: RelativeTime) => FeatureFlagContext | undefined\n  getFeatureFlagBytesCount: () => number\n  addFeatureFlagEvaluation: (key: string, value: ContextValue) => void\n  stop: () => void\n}\n\n/**\n * Start feature flag contexts\n *\n * Feature flag contexts follow the life of views.\n * A new context is added when a view is created and ended when the view is ended\n *\n * Note: we choose not to add a new context at each evaluation to save memory\n */\nexport function startFeatureFlagContexts(\n  lifeCycle: LifeCycle,\n  computeBytesCountImpl = computeBytesCount\n): FeatureFlagContexts {\n  if (!isExperimentalFeatureEnabled(ExperimentalFeature.FEATURE_FLAGS)) {\n    return {\n      findFeatureFlagEvaluations: () => undefined,\n      getFeatureFlagBytesCount: () => 0,\n      addFeatureFlagEvaluation: noop,\n      stop: noop,\n    }\n  }\n\n  const featureFlagContexts = new ValueHistory<FeatureFlagContext>(FEATURE_FLAG_CONTEXT_TIME_OUT_DELAY)\n  let bytesCountCache = 0\n  let alreadyWarned = false\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    featureFlagContexts.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    featureFlagContexts.add({}, startClocks.relative)\n    bytesCountCache = 0\n  })\n\n  // Throttle the bytes computation to minimize the impact on performance.\n  // Especially useful if the user call addFeatureFlagEvaluation API synchronously multiple times in a row\n  const { throttled: computeBytesCountThrottled, cancel: cancelPendingComputation } = throttle((context: Context) => {\n    bytesCountCache = computeBytesCountImpl(jsonStringify(context)!)\n    if (!alreadyWarned) {\n      alreadyWarned = warnIfCustomerDataLimitReached(bytesCountCache, CustomerDataType.FeatureFlag)\n    }\n  }, BYTES_COMPUTATION_THROTTLING_DELAY)\n\n  return {\n    findFeatureFlagEvaluations: (startTime?: RelativeTime) => featureFlagContexts.find(startTime),\n    getFeatureFlagBytesCount: () => {\n      const currentContext = featureFlagContexts.find()\n      if (!currentContext) {\n        return 0\n      }\n\n      return bytesCountCache\n    },\n    addFeatureFlagEvaluation: (key: string, value: ContextValue) => {\n      const currentContext = featureFlagContexts.find()\n      if (currentContext) {\n        currentContext[key] = value\n        computeBytesCountThrottled(currentContext)\n      }\n    },\n    stop: cancelPendingComputation,\n  }\n}\n", "import type { Context, ContextManager, FlushEvent, Observable, Telemetry } from '@datadog/browser-core'\nimport { isEmptyObject, includes, performDraw, ONE_SECOND, addTelemetryDebug, setInterval } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RumConfiguration } from './configuration'\nimport type { FeatureFlagContexts } from './contexts/featureFlagContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const MEASURES_PERIOD_DURATION = 10 * ONE_SECOND\n\ntype Measure = {\n  min: number\n  max: number\n  sum: number\n}\n\ntype CurrentPeriodMeasures = {\n  batchCount: number\n  batchBytesCount: Measure\n  batchMessagesCount: Measure\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\ntype CurrentBatchMeasures = {\n  globalContextBytes: Measure\n  userContextBytes: Measure\n  featureFlagBytes: Measure\n}\n\nlet currentPeriodMeasures: CurrentPeriodMeasures\nlet currentBatchMeasures: CurrentBatchMeasures\nlet batchHasRumEvent: boolean\n\nexport function startCustomerDataTelemetry(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  lifeCycle: LifeCycle,\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  featureFlagContexts: FeatureFlagContexts,\n  batchFlushObservable: Observable<FlushEvent>\n) {\n  const customerDataTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n  if (!customerDataTelemetryEnabled) {\n    return\n  }\n\n  initCurrentPeriodMeasures()\n  initCurrentBatchMeasures()\n\n  // We measure the data of every view updates even if there could only be one per batch due to the upsert\n  // It means that contexts bytes count sums can be higher than it really is\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event: RumEvent & Context) => {\n    batchHasRumEvent = true\n    updateMeasure(\n      currentBatchMeasures.globalContextBytes,\n      !isEmptyObject(globalContextManager.get()) ? globalContextManager.getBytesCount() : 0\n    )\n\n    updateMeasure(\n      currentBatchMeasures.userContextBytes,\n      !isEmptyObject(userContextManager.get()) ? userContextManager.getBytesCount() : 0\n    )\n\n    const featureFlagContext = featureFlagContexts.findFeatureFlagEvaluations()\n    const hasFeatureFlagContext =\n      includes([RumEventType.VIEW, RumEventType.ERROR], event.type) &&\n      featureFlagContext &&\n      !isEmptyObject(featureFlagContext)\n    updateMeasure(\n      currentBatchMeasures.featureFlagBytes,\n      hasFeatureFlagContext ? featureFlagContexts.getFeatureFlagBytesCount() : 0\n    )\n  })\n\n  batchFlushObservable.subscribe(({ bytesCount, messagesCount }) => {\n    // Don't measure batch that only contains telemetry events to avoid batch sending loop\n    // It could happen because after each batch we are adding a customer data measures telemetry event to the next one\n    if (!batchHasRumEvent) {\n      return\n    }\n    currentPeriodMeasures.batchCount += 1\n    updateMeasure(currentPeriodMeasures.batchBytesCount, bytesCount)\n    updateMeasure(currentPeriodMeasures.batchMessagesCount, messagesCount)\n    mergeMeasure(currentPeriodMeasures.globalContextBytes, currentBatchMeasures.globalContextBytes)\n    mergeMeasure(currentPeriodMeasures.userContextBytes, currentBatchMeasures.userContextBytes)\n    mergeMeasure(currentPeriodMeasures.featureFlagBytes, currentBatchMeasures.featureFlagBytes)\n    initCurrentBatchMeasures()\n  })\n\n  setInterval(sendCurrentPeriodMeasures, MEASURES_PERIOD_DURATION)\n}\n\nfunction sendCurrentPeriodMeasures() {\n  if (currentPeriodMeasures.batchCount === 0) {\n    return\n  }\n\n  addTelemetryDebug('Customer data measures', currentPeriodMeasures)\n  initCurrentPeriodMeasures()\n}\n\nfunction createMeasure(): Measure {\n  return { min: Infinity, max: 0, sum: 0 }\n}\n\nfunction updateMeasure(measure: Measure, value: number) {\n  measure.sum += value\n  measure.min = Math.min(measure.min, value)\n  measure.max = Math.max(measure.max, value)\n}\n\nfunction mergeMeasure(target: Measure, source: Measure) {\n  target.sum += source.sum\n  target.min = Math.min(target.min, source.min)\n  target.max = Math.max(target.max, source.max)\n}\n\nfunction initCurrentPeriodMeasures() {\n  currentPeriodMeasures = {\n    batchCount: 0,\n    batchBytesCount: createMeasure(),\n    batchMessagesCount: createMeasure(),\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n\nfunction initCurrentBatchMeasures() {\n  batchHasRumEvent = false\n  currentBatchMeasures = {\n    globalContextBytes: createMeasure(),\n    userContextBytes: createMeasure(),\n    featureFlagBytes: createMeasure(),\n  }\n}\n", "import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport {\n  elapsed,\n  ValueHistory,\n  SESSION_TIME_OUT_DELAY,\n  toServerDuration,\n  addEventListeners,\n  relativeNow,\n  DOM_EVENT,\n} from '@datadog/browser-core'\nimport type { PageStateServerEntry } from '../../rawRumEvent.types'\n\n// Arbitrary value to cap number of element for memory consumption in the browser\nexport const MAX_PAGE_STATE_ENTRIES = 4000\n// Arbitrary value to cap number of element for backend & to save bandwidth\nexport const MAX_PAGE_STATE_ENTRIES_SELECTABLE = 500\n\nexport const PAGE_STATE_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport const enum PageState {\n  ACTIVE = 'active',\n  PASSIVE = 'passive',\n  HIDDEN = 'hidden',\n  FROZEN = 'frozen',\n  TERMINATED = 'terminated',\n}\n\nexport type PageStateEntry = { state: PageState; startTime: RelativeTime }\n\nexport interface PageStateHistory {\n  findAll: (startTime: RelativeTime, duration: Duration) => PageStateServerEntry[] | undefined\n  isInActivePageStateAt: (startTime: RelativeTime) => boolean\n  addPageState(nextPageState: PageState, startTime?: RelativeTime): void\n  stop: () => void\n}\n\nexport function startPageStateHistory(\n  maxPageStateEntriesSelectable = MAX_PAGE_STATE_ENTRIES_SELECTABLE\n): PageStateHistory {\n  const pageStateHistory = new ValueHistory<PageStateEntry>(PAGE_STATE_CONTEXT_TIME_OUT_DELAY, MAX_PAGE_STATE_ENTRIES)\n\n  let currentPageState: PageState\n  addPageState(getPageState(), relativeNow())\n\n  const { stop: stopEventListeners } = addEventListeners(\n    window,\n    [\n      DOM_EVENT.PAGE_SHOW,\n      DOM_EVENT.FOCUS,\n      DOM_EVENT.BLUR,\n      DOM_EVENT.VISIBILITY_CHANGE,\n      DOM_EVENT.RESUME,\n      DOM_EVENT.FREEZE,\n      DOM_EVENT.PAGE_HIDE,\n    ],\n    (event) => {\n      // Only get events fired by the browser to avoid false currentPageState changes done with custom events\n      // cf: developer extension auto flush: https://github.com/DataDog/browser-sdk/blob/2f72bf05a672794c9e33965351964382a94c72ba/developer-extension/src/panel/flushEvents.ts#L11-L12\n      if (event.isTrusted) {\n        addPageState(computePageState(event), event.timeStamp as RelativeTime)\n      }\n    },\n    { capture: true }\n  )\n\n  function addPageState(nextPageState: PageState, startTime = relativeNow()) {\n    if (nextPageState === currentPageState) {\n      return\n    }\n\n    currentPageState = nextPageState\n    pageStateHistory.closeActive(startTime)\n    pageStateHistory.add({ state: currentPageState, startTime }, startTime)\n  }\n\n  return {\n    findAll: (eventStartTime: RelativeTime, duration: Duration): PageStateServerEntry[] | undefined => {\n      const pageStateEntries = pageStateHistory.findAll(eventStartTime, duration)\n\n      if (pageStateEntries.length === 0) {\n        return\n      }\n\n      const pageStateServerEntries = []\n      // limit the number of entries to return\n      const limit = Math.max(0, pageStateEntries.length - maxPageStateEntriesSelectable)\n\n      // loop page state entries backward to return the selected ones in desc order\n      for (let index = pageStateEntries.length - 1; index >= limit; index--) {\n        const pageState = pageStateEntries[index]\n        // compute the start time relative to the event start time (ex: to be relative to the view start time)\n        const relativeStartTime = elapsed(eventStartTime, pageState.startTime)\n\n        pageStateServerEntries.push({\n          state: pageState.state,\n          start: toServerDuration(relativeStartTime),\n        })\n      }\n\n      return pageStateServerEntries\n    },\n    isInActivePageStateAt: (startTime: RelativeTime) => {\n      const pageStateEntry = pageStateHistory.find(startTime)\n      return pageStateEntry !== undefined && pageStateEntry.state === PageState.ACTIVE\n    },\n    addPageState,\n    stop: () => {\n      stopEventListeners()\n      pageStateHistory.stop()\n    },\n  }\n}\n\nfunction computePageState(event: Event) {\n  if (event.type === DOM_EVENT.FREEZE) {\n    return PageState.FROZEN\n  } else if (event.type === DOM_EVENT.PAGE_HIDE) {\n    return (event as PageTransitionEvent).persisted ? PageState.FROZEN : PageState.TERMINATED\n  }\n  return getPageState()\n}\n\nfunction getPageState() {\n  if (document.visibilityState === 'hidden') {\n    return PageState.HIDDEN\n  }\n\n  if (document.hasFocus()) {\n    return PageState.ACTIVE\n  }\n\n  return PageState.PASSIVE\n}\n", "import { addTelemetryDebug, elapsed, noop, performDraw, relativeNow, toServerDuration } from '@datadog/browser-core'\nimport type { Telemetry, RelativeTime } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport type { RumConfiguration } from '../../configuration'\n\nexport type WebVitalTelemetryDebug = ReturnType<typeof startWebVitalTelemetryDebug>\n\nexport function startWebVitalTelemetryDebug(\n  configuration: RumConfiguration,\n  telemetry: Telemetry,\n  recorderApi: RecorderApi,\n  session: RumSessionManager\n) {\n  const webVitalTelemetryEnabled = telemetry.enabled && performDraw(configuration.customerDataTelemetrySampleRate)\n\n  if (!webVitalTelemetryEnabled) {\n    return {\n      addWebVitalTelemetryDebug: noop,\n    }\n  }\n  return {\n    addWebVitalTelemetryDebug(webVitalName: string, webVitalNode: Node | undefined, webVitalTime: RelativeTime) {\n      const computationTime = relativeNow()\n      if (!recorderApi.isRecording()) {\n        recorderApi.recorderStartObservable.subscribe((recordingStartTime) => {\n          addTelemetryDebug(`${webVitalName} attribution recording delay`, {\n            computationDelay: toServerDuration(elapsed(webVitalTime, computationTime)),\n            recordingDelay: toServerDuration(elapsed(webVitalTime, recordingStartTime)),\n            hasNode: !!webVitalNode,\n            serializedDomNode: webVitalNode ? recorderApi.getSerializedNodeId(webVitalNode) : undefined,\n          })\n        })\n      }\n\n      addTelemetryDebug(`${webVitalName} attribution`, {\n        computationDelay: toServerDuration(elapsed(webVitalTime, computationTime)),\n        hasNode: !!webVitalNode,\n        replayRecording: recorderApi.isRecording(),\n        replaySampled: session.findTrackedSession()?.sessionReplayAllowed,\n        serializedDomNode: webVitalNode ? recorderApi.getSerializedNodeId(webVitalNode) : undefined,\n      })\n    },\n  }\n}\n", "import type { Observable, TelemetryEvent, RawError, ContextManager } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  TelemetryService,\n  addTelemetryConfiguration,\n  startTelemetry,\n  canUseEventBridge,\n  getEventBridge,\n  addTelemetryDebug,\n} from '@datadog/browser-core'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { startPerformanceCollection } from '../browser/performanceCollection'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewContexts } from '../domain/contexts/viewContexts'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/rumEventsCollection/action/actionCollection'\nimport { startErrorCollection } from '../domain/rumEventsCollection/error/errorCollection'\nimport { startLongTaskCollection } from '../domain/rumEventsCollection/longTask/longTaskCollection'\nimport { startResourceCollection } from '../domain/rumEventsCollection/resource/resourceCollection'\nimport { startViewCollection } from '../domain/rumEventsCollection/view/viewCollection'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport type { LocationChange } from '../browser/locationChangeObservable'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { serializeRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport { startFeatureFlagContexts } from '../domain/contexts/featureFlagContext'\nimport { startCustomerDataTelemetry } from '../domain/startCustomerDataTelemetry'\nimport { startPageStateHistory } from '../domain/contexts/pageStateHistory'\nimport type { CommonContext } from '../domain/contexts/commonContext'\nimport { buildCommonContext } from '../domain/contexts/commonContext'\nimport { startWebVitalTelemetryDebug } from '../domain/rumEventsCollection/view/startWebVitalTelemetryDebug'\nimport type { RecorderApi } from './rumPublicApi'\n\nexport function startRum(\n  initConfiguration: RumInitConfiguration,\n  configuration: RumConfiguration,\n  recorderApi: RecorderApi,\n  globalContextManager: ContextManager,\n  userContextManager: ContextManager,\n  initialViewOptions?: ViewOptions\n) {\n  const lifeCycle = new LifeCycle()\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event) => sendToExtension('rum', event))\n\n  const telemetry = startRumTelemetry(configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: configuration.applicationId,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: viewContexts.findView()?.id,\n    },\n    action: {\n      id: actionContexts.findActionId(),\n    },\n  }))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n  const featureFlagContexts = startFeatureFlagContexts(lifeCycle)\n\n  const pageExitObservable = createPageExitObservable()\n  pageExitObservable.subscribe((event) => {\n    lifeCycle.notify(LifeCycleEventType.PAGE_EXITED, event)\n  })\n\n  const session = !canUseEventBridge() ? startRumSessionManager(configuration, lifeCycle) : startRumSessionManagerStub()\n  if (!canUseEventBridge()) {\n    const batch = startRumBatch(\n      configuration,\n      lifeCycle,\n      telemetry.observable,\n      reportError,\n      pageExitObservable,\n      session.expireObservable\n    )\n    startCustomerDataTelemetry(\n      configuration,\n      telemetry,\n      lifeCycle,\n      globalContextManager,\n      userContextManager,\n      featureFlagContexts,\n      batch.flushObservable\n    )\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(location)\n\n  const { viewContexts, pageStateHistory, urlContexts, actionContexts, addAction } = startRumEventCollection(\n    lifeCycle,\n    configuration,\n    location,\n    session,\n    locationChangeObservable,\n    domMutationObservable,\n    () => buildCommonContext(globalContextManager, userContextManager, recorderApi),\n    reportError\n  )\n\n  addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n\n  startLongTaskCollection(lifeCycle, session)\n  startResourceCollection(lifeCycle, configuration, session, pageStateHistory)\n\n  const webVitalTelemetryDebug = startWebVitalTelemetryDebug(configuration, telemetry, recorderApi, session)\n  const { addTiming, startView } = startViewCollection(\n    lifeCycle,\n    configuration,\n    location,\n    domMutationObservable,\n    locationChangeObservable,\n    featureFlagContexts,\n    pageStateHistory,\n    recorderApi,\n    webVitalTelemetryDebug,\n    initialViewOptions\n  )\n  const { addError } = startErrorCollection(lifeCycle, pageStateHistory, featureFlagContexts)\n\n  startRequestCollection(lifeCycle, configuration, session)\n  startPerformanceCollection(lifeCycle, configuration)\n\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewContexts,\n    actionContexts,\n    urlContexts\n  )\n\n  return {\n    addAction,\n    addError,\n    addTiming,\n    addFeatureFlagEvaluation: featureFlagContexts.addFeatureFlagEvaluation,\n    startView,\n    lifeCycle,\n    viewContexts,\n    session,\n    stopSession: () => session.expire(),\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startRumTelemetry(configuration: RumConfiguration) {\n  const telemetry = startTelemetry(TelemetryService.RUM, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  }\n  return telemetry\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  sessionManager: RumSessionManager,\n  locationChangeObservable: Observable<LocationChange>,\n  domMutationObservable: Observable<void>,\n  buildCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const viewContexts = startViewContexts(lifeCycle)\n  const urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location)\n\n  const pageStateHistory = startPageStateHistory()\n\n  const { addAction, actionContexts } = startActionCollection(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    pageStateHistory\n  )\n\n  startRumAssembly(\n    configuration,\n    lifeCycle,\n    sessionManager,\n    viewContexts,\n    urlContexts,\n    actionContexts,\n    buildCommonContext,\n    reportError\n  )\n\n  return {\n    viewContexts,\n    pageStateHistory,\n    urlContexts,\n    addAction,\n    actionContexts,\n    stop: () => {\n      viewContexts.stop()\n      pageStateHistory.stop()\n    },\n  }\n}\n", "import { INTAKE_SITE_STAGING, INTAKE_SITE_US1, INTAKE_SITE_EU1 } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { ViewContext } from './contexts/viewContexts'\nimport type { RumSession } from './rumSessionManager'\n\nexport function getSessionReplayUrl(\n  configuration: RumConfiguration,\n  {\n    session,\n    viewContext,\n    errorType,\n  }: {\n    session?: RumSession\n    viewContext?: ViewContext\n    errorType?: string\n  }\n): string {\n  const sessionId = session ? session.id : 'no-session-id'\n  const parameters: string[] = []\n  if (errorType !== undefined) {\n    parameters.push(`error-type=${errorType}`)\n  }\n  if (viewContext) {\n    parameters.push(`seed=${viewContext.id}`)\n    parameters.push(`from=${viewContext.startClocks.timeStamp}`)\n  }\n\n  const origin = getDatadogSiteUrl(configuration)\n  const path = `/rum/replay/sessions/${sessionId}`\n  return `${origin}${path}?${parameters.join('&')}`\n}\n\nexport function getDatadogSiteUrl(rumConfiguration: RumConfiguration) {\n  const site = rumConfiguration.site\n  const subdomain = rumConfiguration.subdomain || getSiteDefaultSubdomain(rumConfiguration)\n  return `https://${subdomain ? `${subdomain}.` : ''}${site}`\n}\n\nfunction getSiteDefaultSubdomain(configuration: RumConfiguration): string | undefined {\n  switch (configuration.site) {\n    case INTAKE_SITE_US1:\n    case INTAKE_SITE_EU1:\n      return 'app'\n    case INTAKE_SITE_STAGING:\n      return 'dd'\n    default:\n      return undefined\n  }\n}\n", "import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n} as const\n\nexport type RecordType = (typeof RecordType)[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n  DocumentFragment: SessionReplay.DocumentFragmentNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n  DocumentFragment: 11,\n} as const\n\nexport type NodeType = (typeof NodeType)[keyof typeof NodeType]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = (typeof IncrementalSource)[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = (typeof MouseInteractionType)[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = (typeof MediaInteractionType)[keyof typeof MediaInteractionType]\n", "import { assign, timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: assign(\n      {\n        source,\n      },\n      data\n    ) as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n", "import { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nexport const NodePrivacyLevel = {\n  IGNORE: 'ignore',\n  HIDDEN: 'hidden',\n  ALLOW: DefaultPrivacyLevel.ALLOW,\n  MASK: DefaultPrivacyLevel.MASK,\n  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n} as const\nexport type NodePrivacyLevel = (typeof NodePrivacyLevel)[keyof typeof NodePrivacyLevel]\n\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy'\n\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow'\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask'\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input'\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden'\n\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_ALLOW = 'dd-privacy-allow'\nexport const PRIVACY_CLASS_MASK = 'dd-privacy-mask'\nexport const PRIVACY_CLASS_MASK_USER_INPUT = 'dd-privacy-mask-user-input'\nexport const PRIVACY_CLASS_HIDDEN = 'dd-privacy-hidden'\n\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***'\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=='\n\nexport const FORM_PRIVATE_TAG_NAMES: { [tagName: string]: true } = {\n  INPUT: true,\n  OUTPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  OPTION: true,\n  DATALIST: true,\n  OPTGROUP: true,\n}\n", "import { isElementNode, getParentNode, isTextNode } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_ALLOW,\n  PRIVACY_ATTR_VALUE_MASK,\n  PRIVACY_ATTR_VALUE_MASK_USER_INPUT,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  PRIVACY_CLASS_ALLOW,\n  PRIVACY_CLASS_MASK,\n  PRIVACY_CLASS_MASK_USER_INPUT,\n  PRIVACY_CLASS_HIDDEN,\n  FORM_PRIVATE_TAG_NAMES,\n  CENSORED_STRING_MARK,\n} from '../../constants'\n\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100_000\n\nconst TEXT_MASKING_CHAR = 'x'\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node: Node, defaultPrivacyLevel: NodePrivacyLevel): NodePrivacyLevel {\n  const parentNode = getParentNode(node)\n  const parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElementNode(node)) {\n    return\n  }\n\n  const privAttr = node.getAttribute(PRIVACY_ATTR_NAME)\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isStyle = parentTagName === 'STYLE' ? true : undefined\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (\n    shouldMaskNode(textNode, nodePrivacyLevel) &&\n    // Style tags are `overruled` (Use `hide` to enforce privacy)\n    !isStyle\n  ) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Link as script - Ignore only when rel=preload, modulepreload or prefetch\n      (/preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n", "import { buildUrl } from '@datadog/browser-core'\nimport { getParentNode, isNodeShadowRoot } from '@datadog/browser-rum-core'\nimport type { NodePrivacyLevel } from '../../../constants'\nimport { CENSORED_STRING_MARK } from '../../../constants'\nimport { shouldMaskNode } from '../privacy'\nimport type { NodeWithSerializedNode } from './serialization.types'\n\nconst serializedNodeIds = new WeakMap<Node, number>()\n\nexport function hasSerializedNode(node: Node): node is NodeWithSerializedNode {\n  return serializedNodeIds.has(node)\n}\n\nexport function nodeAndAncestorsHaveSerializedNode(node: Node): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n      return false\n    }\n    current = getParentNode(current)\n  }\n  return true\n}\n\nexport function getSerializedNodeId(node: NodeWithSerializedNode): number\nexport function getSerializedNodeId(node: Node): number | undefined\nexport function getSerializedNodeId(node: Node) {\n  return serializedNodeIds.get(node)\n}\n\nexport function setSerializedNodeId(node: Node, serializeNodeId: number) {\n  serializedNodeIds.set(node, serializeNodeId)\n}\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nexport function makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch (_) {\n    return url\n  }\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nexport function getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n", "import type { StyleSheet } from '../../../types'\n\nexport function serializeStyleSheets(cssStyleSheets: CSSStyleSheet[] | undefined): StyleSheet[] | undefined {\n  if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n    return undefined\n  }\n  return cssStyleSheets.map((cssStyleSheet) => {\n    const rules = cssStyleSheet.cssRules || cssStyleSheet.rules\n    const cssRules = Array.from(rules, (cssRule) => cssRule.cssText)\n\n    const styleSheet: StyleSheet = {\n      cssRules,\n      disabled: cssStyleSheet.disabled || undefined,\n      media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n    }\n    return styleSheet\n  })\n}\n", "import { startsWith } from '@datadog/browser-core'\nimport { STABLE_ATTRIBUTES } from '@datadog/browser-rum-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK } from '../../../constants'\nimport { MAX_ATTRIBUTE_VALUE_CHAR_LENGTH } from '../privacy'\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n    // mask image URLs\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK\n      }\n    }\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  // Minimum Fix for customer.\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated'\n  }\n\n  return attributeValue\n}\n", "import { ExperimentalFeature, isExperimentalFeatureEnabled } from '@datadog/browser-core'\n\nimport { NodePrivacyLevel } from '../../../constants'\nimport { shouldMaskNode } from '../privacy'\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { SerializationContextStatus } from './serialization.types'\nimport { serializeAttribute } from './serializeAttribute'\n\nexport function serializeAttributes(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i)!\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet)\n    if (cssText && stylesheet && !isExperimentalFeatureEnabled(ExperimentalFeature.DISABLE_REPLAY_INLINE_CSS)) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (element as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !((element as HTMLStyleElement).innerText || element.textContent || '').trim().length\n  ) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      delete safeAttrs.checked\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n\nfunction getCssRulesString(cssStyleSheet: CSSStyleSheet | undefined | null): string | null {\n  if (!cssStyleSheet) {\n    return null\n  }\n  let rules: CSSRuleList | undefined\n  try {\n    rules = cssStyleSheet.rules || cssStyleSheet.cssRules\n  } catch {\n    // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n  }\n  if (!rules) {\n    return null\n  }\n  const styleSheetCssText = Array.from(rules, getCssRuleString).join('')\n  return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href)\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n", "import { isNodeShadowRoot, isNodeShadowHost } from '@datadog/browser-rum-core'\nimport { assign } from '@datadog/browser-core'\nimport type {\n  DocumentFragmentNode,\n  DocumentNode,\n  SerializedNode,\n  SerializedNodeWithId,\n  CDataNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n} from '../../../types'\nimport { NodeType } from '../../../types'\nimport { NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN } from '../../../constants'\nimport { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent } from '../privacy'\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils'\nimport type { SerializeOptions } from './serialization.types'\nimport { serializeStyleSheets } from './serializeStyleSheets'\nimport { serializeAttributes } from './serializeAttributes'\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nlet _nextId = 1\nexport function generateNextId(): number {\n  return _nextId++\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n  node.childNodes.forEach((childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n  return result\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragmentNode(node as DocumentFragment, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n    adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n  }\n}\n\nfunction serializeDocumentFragmentNode(\n  element: DocumentFragment,\n  options: SerializeOptions\n): DocumentFragmentNode | undefined {\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    childNodes = serializeChildNodes(element, options)\n  }\n\n  const isShadowRoot = isNodeShadowRoot(element)\n  if (isShadowRoot) {\n    options.serializationContext.shadowRootsController.addShadowRoot(element)\n  }\n\n  return {\n    type: NodeType.DocumentFragment,\n    childNodes,\n    isShadowRoot,\n    adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\n\nfunction serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = serializeAttributes(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  if (isNodeShadowHost(element)) {\n    const shadowRoot = serializeNodeWithId(element.shadowRoot, options)\n    if (shadowRoot !== null) {\n      childNodes.push(shadowRoot)\n    }\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\n\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (textContent === undefined) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n", "import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { SerializedNodeWithId } from '../../../types'\nimport type { SerializationContext } from './serialization.types'\nimport { serializeNodeWithId } from './serializeNode'\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n", "import { isNodeShadowHost } from '@datadog/browser-rum-core'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function getEventTarget(event: Event): Node {\n  if (event.composed === true && isNodeShadowHost(event.target as Node)) {\n    return event.composedPath()[0] as Node\n  }\n  return event.target as Node\n}\n", "/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport: VisualViewport) {\n  return (\n    Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visualViewport = window.visualViewport\n  const normalized: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visualViewport) {\n    // On old browsers, we cannot normalize, so fallback to clientX/Y\n    return normalized\n  } else if (isVisualViewportFactoredIn(visualViewport)) {\n    // Typically Mobile Devices\n    normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft)\n    normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft)\n    normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop)\n  }\n  return normalized\n}\n\nexport const getVisualViewport = (visualViewport: VisualViewport): VisualViewportRecord['data'] => ({\n  scale: visualViewport.scale,\n  offsetLeft: visualViewport.offsetLeft,\n  offsetTop: visualViewport.offsetTop,\n  pageLeft: visualViewport.pageLeft,\n  pageTop: visualViewport.pageTop,\n  height: visualViewport.height,\n  width: visualViewport.width,\n})\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport { addEventListeners, addTelemetryDebug, DOM_EVENT, throttle } from '@datadog/browser-core'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { MousePosition } from '../../../types'\nimport { IncrementalSource } from '../../../types'\nimport { getEventTarget, isTouchEvent } from '../eventsUtils'\nimport { convertMouseEventToLayoutCoordinates } from '../viewports'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\n\nexport type MousemoveCallBack = (\n  p: MousePosition[],\n  source: typeof IncrementalSource.MouseMove | typeof IncrementalSource.TouchMove\n) => void\n\nexport function initMoveObserver(cb: MousemoveCallBack): ListenerHandler {\n  const { throttled: updatePosition } = throttle(\n    (event: MouseEvent | TouchEvent) => {\n      const target = getEventTarget(event)\n      if (hasSerializedNode(target)) {\n        const coordinates = tryToComputeCoordinates(event)\n        if (!coordinates) {\n          return\n        }\n        const position: MousePosition = {\n          id: getSerializedNodeId(target),\n          timeOffset: 0,\n          x: coordinates.x,\n          y: coordinates.y,\n        }\n\n        cb([position], isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove)\n      }\n    },\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  return addEventListeners(document, [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE], updatePosition, {\n    capture: true,\n    passive: true,\n  }).stop\n}\n\nexport function tryToComputeCoordinates(event: MouseEvent | TouchEvent) {\n  let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event\n  if (window.visualViewport) {\n    const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y)\n    x = visualViewportX\n    y = visualViewportY\n  }\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    if (event.isTrusted) {\n      addTelemetryDebug('mouse/touch event without x/y')\n    }\n    return undefined\n  }\n  return { x, y }\n}\n", "import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, throttle, addEventListener } from '@datadog/browser-core'\nimport { getScrollX, getScrollY } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport type { ScrollPosition } from '../../../types'\nimport { NodePrivacyLevel } from '../../../constants'\n\nconst SCROLL_OBSERVER_THRESHOLD = 100\n\nexport type ScrollCallback = (p: ScrollPosition) => void\n\nexport function initScrollObserver(\n  cb: ScrollCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel,\n  elementsScrollPositions: ElementsScrollPositions\n): ListenerHandler {\n  const { throttled: updatePosition } = throttle((event: Event) => {\n    const target = getEventTarget(event) as HTMLElement | Document\n    if (\n      !target ||\n      getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const scrollPositions =\n      target === document\n        ? {\n            scrollTop: getScrollY(),\n            scrollLeft: getScrollX(),\n          }\n        : {\n            scrollTop: Math.round((target as HTMLElement).scrollTop),\n            scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n          }\n    elementsScrollPositions.set(target, scrollPositions)\n    cb({\n      id,\n      x: scrollPositions.scrollLeft,\n      y: scrollPositions.scrollTop,\n    })\n  }, SCROLL_OBSERVER_THRESHOLD)\n  return addEventListener(document, DOM_EVENT.SCROLL, updatePosition, { capture: true, passive: true }).stop\n}\n", "import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { assign, addEventListeners, DOM_EVENT } from '@datadog/browser-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { MouseInteraction, MouseInteractionData, BrowserIncrementalSnapshotRecord } from '../../../types'\nimport { IncrementalSource, MouseInteractionType } from '../../../types'\nimport { assembleIncrementalSnapshot } from '../assembly'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\nimport { tryToComputeCoordinates } from './moveObserver'\nimport type { RecordIds } from './recordIds'\n\nconst eventTypeToMouseInteraction = {\n  // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n  // allows to reference such records from Frustration records.\n  //\n  // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n  // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n  // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n  // convey such interaction. This would cleanly solve the issue since we would have\n  // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n  [DOM_EVENT.POINTER_UP]: MouseInteractionType.MouseUp,\n\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\n\nexport type MouseInteractionCallBack = (record: BrowserIncrementalSnapshotRecord) => void\n\nexport function initMouseInteractionObserver(\n  cb: MouseInteractionCallBack,\n  defaultPrivacyLevel: DefaultPrivacyLevel,\n  recordIds: RecordIds\n): ListenerHandler {\n  const handler = (event: MouseEvent | TouchEvent | FocusEvent) => {\n    const target = getEventTarget(event)\n    if (getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN || !hasSerializedNode(target)) {\n      return\n    }\n    const id = getSerializedNodeId(target)\n    const type = eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction]\n\n    let interaction: MouseInteraction\n    if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n      const coordinates = tryToComputeCoordinates(event as MouseEvent | TouchEvent)\n      if (!coordinates) {\n        return\n      }\n      interaction = { id, type, x: coordinates.x, y: coordinates.y }\n    } else {\n      interaction = { id, type }\n    }\n\n    const record = assign(\n      { id: recordIds.getIdForEvent(event) },\n      assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, interaction)\n    )\n    cb(record)\n  }\n  return addEventListeners(\n    document,\n    Object.keys(eventTypeToMouseInteraction) as Array<keyof typeof eventTypeToMouseInteraction>,\n    handler,\n    {\n      capture: true,\n      passive: true,\n    }\n  ).stop\n}\n", "import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { instrumentSetter, assign, DOM_EVENT, addEventListeners, forEach, noop } from '@datadog/browser-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { InputState } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel, shouldMaskNode } from '../privacy'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization'\n\nexport type InputCallback = (v: InputState & { id: number }) => void\n\nexport function initInputObserver(\n  cb: InputCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel,\n  target: Document | ShadowRoot = document\n): ListenerHandler {\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  const isShadowRoot = target !== document\n\n  const { stop: stopEventListeners } = addEventListeners(\n    target,\n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [DOM_EVENT.CHANGE] : [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      const target = getEventTarget(event)\n      if (\n        target instanceof HTMLInputElement ||\n        target instanceof HTMLTextAreaElement ||\n        target instanceof HTMLSelectElement\n      ) {\n        onElementChange(target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  let stopPropertySetterInstrumentation: () => void\n  if (!isShadowRoot) {\n    const instrumentationStoppers = [\n      instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n      instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n    ]\n    stopPropertySetterInstrumentation = () => {\n      instrumentationStoppers.forEach((stopper) => stopper.stop())\n    }\n  } else {\n    stopPropertySetterInstrumentation = noop\n  }\n\n  return () => {\n    stopPropertySetterInstrumentation()\n    stopEventListeners()\n  }\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      forEach(document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`), (el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      cb(\n        assign(\n          {\n            id: getSerializedNodeId(target),\n          },\n          inputState\n        )\n      )\n    }\n  }\n}\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport { instrumentMethodAndCallOriginal } from '@datadog/browser-core'\nimport type { StyleSheetRule } from '../../../types'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\nexport type StyleSheetCallback = (s: StyleSheetRule) => void\n\nexport function initStyleSheetObserver(cb: StyleSheetCallback): ListenerHandler {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'insertRule', {\n      before(rule, index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, adds: [{ rule, index }] }))\n      },\n    }),\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'deleteRule', {\n      before(index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, removes: [{ index }] }))\n      },\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethodAndCallOriginal(cls.prototype, 'insertRule', {\n        before(rule, index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index || 0)\n              cb({ id, adds: [{ rule, index: path }] })\n            }\n          })\n        },\n      }),\n      instrumentMethodAndCallOriginal(cls.prototype, 'deleteRule', {\n        before(index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index)\n              cb({ id, removes: [{ index: path }] })\n            }\n          })\n        },\n      })\n    )\n  }\n\n  return () => instrumentationStoppers.forEach((stopper) => stopper.stop())\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n", "import type { DefaultPrivacyLevel, ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type { MediaInteraction } from '../../../types'\nimport { MediaInteractionType } from '../../../types'\nimport { getEventTarget } from '../eventsUtils'\nimport { getNodePrivacyLevel } from '../privacy'\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization'\n\nexport type MediaInteractionCallback = (p: MediaInteraction) => void\n\nexport function initMediaInteractionObserver(\n  mediaInteractionCb: MediaInteractionCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel\n): ListenerHandler {\n  const handler = (event: Event) => {\n    const target = getEventTarget(event)\n    if (\n      !target ||\n      getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    mediaInteractionCb({\n      id: getSerializedNodeId(target),\n      type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n    })\n  }\n  return addEventListeners(document, [DOM_EVENT.PLAY, DOM_EVENT.PAUSE], handler, { capture: true, passive: true }).stop\n}\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport type { LifeCycle } from '@datadog/browser-rum-core'\nimport { ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { FrustrationRecord } from '../../../types'\nimport { RecordType } from '../../../types'\nimport type { RecordIds } from './recordIds'\n\nexport type FrustrationCallback = (record: FrustrationRecord) => void\n\nexport function initFrustrationObserver(\n  lifeCycle: LifeCycle,\n  frustrationCb: FrustrationCallback,\n  recordIds: RecordIds\n): ListenerHandler {\n  return lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events?.length\n    ) {\n      frustrationCb({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n        },\n      })\n    }\n  }).unsubscribe\n}\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport { throttle, DOM_EVENT, addEventListeners, noop } from '@datadog/browser-core'\nimport { initViewportObservable } from '@datadog/browser-rum-core'\nimport type { ViewportResizeDimension, VisualViewportRecord } from '../../../types'\nimport { getVisualViewport } from '../viewports'\n\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nexport type ViewportResizeCallback = (d: ViewportResizeDimension) => void\n\nexport type VisualViewportResizeCallback = (data: VisualViewportRecord['data']) => void\n\nexport function initViewportResizeObserver(cb: ViewportResizeCallback): ListenerHandler {\n  return initViewportObservable().subscribe(cb).unsubscribe\n}\n\nexport function initVisualViewportResizeObserver(cb: VisualViewportResizeCallback): ListenerHandler {\n  const visualViewport = window.visualViewport\n  if (!visualViewport) {\n    return noop\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    () => {\n      cb(getVisualViewport(visualViewport))\n    },\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const removeListener = addEventListeners(visualViewport, [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL], updateDimension, {\n    capture: true,\n    passive: true,\n  }).stop\n\n  return function stop() {\n    removeListener()\n    cancelThrottle()\n  }\n}\n", "import { noop, monitor } from '@datadog/browser-core'\nimport type { RumMutationRecord } from './observers'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n    },\n  }\n}\n\n/**\n * Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n * browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n * fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n * browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes efficiently.\n *\n * Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.\n */\nfunction requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  if (window.requestIdleCallback && window.cancelIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n", "import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport {\n  getChildNodes,\n  isNodeShadowHost,\n  getMutationObserverConstructor,\n  getParentNode,\n} from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../../constants'\nimport type {\n  AddedNodeMutation,\n  AttributeMutation,\n  BrowserMutationPayload,\n  RemovedNodeMutation,\n  TextMutation,\n} from '../../../types'\nimport { getNodePrivacyLevel, getTextContent } from '../privacy'\nimport type { NodeWithSerializedNode } from '../serialization'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n  serializeNodeWithId,\n  SerializationContextStatus,\n  serializeAttribute,\n} from '../serialization'\nimport { createMutationBatch } from '../mutationBatch'\nimport type { ShadowRootCallBack, ShadowRootsController } from '../shadowRootsController'\n\nexport type MutationCallBack = (m: BrowserMutationPayload) => void\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function initMutationObserver(\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop, flush: noop }\n  }\n\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(\n      mutations.concat(observer.takeRecords() as RumMutationRecord[]),\n      mutationCallback,\n      configuration,\n      shadowRootsController,\n      target\n    )\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(target, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n    flush: () => {\n      mutationBatch.flush()\n    },\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController,\n  target: Node\n) {\n  mutations\n    .filter((mutation): mutation is RumChildListMutationRecord => mutation.type === 'childList')\n    .forEach((mutation) => {\n      mutation.removedNodes.forEach((removedNode) => {\n        traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot)\n      })\n    })\n\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      target.contains(mutation.target) &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration,\n    shadowRootsController\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback({\n    adds,\n    removes,\n    texts,\n    attributes,\n  })\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration,\n  shadowRootsController: ShadowRootsController\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    mutation.addedNodes.forEach((node) => {\n      addedAndMovedNodes.add(node)\n    })\n    mutation.removedNodes.forEach((node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode!, configuration.defaultPrivacyLevel)\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION, shadowRootsController },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    const parentNode = getParentNode(node)!\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(parentNode)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(\n      getParentNode(mutation.target)!,\n      configuration.defaultPrivacyLevel\n    )\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\nfunction traverseRemovedShadowDom(removedNode: Node, shadowDomRemovedCallback: ShadowRootCallBack) {\n  if (isNodeShadowHost(removedNode)) {\n    shadowDomRemovedCallback(removedNode.shadowRoot)\n  }\n  getChildNodes(removedNode).forEach((child) => traverseRemovedShadowDom(child, shadowDomRemovedCallback))\n}\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport { DOM_EVENT, addEventListeners } from '@datadog/browser-core'\nimport type { FocusRecord } from '../../../types'\n\nexport type FocusCallback = (data: FocusRecord['data']) => void\n\nexport function initFocusObserver(focusCb: FocusCallback): ListenerHandler {\n  return addEventListeners(window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    focusCb({ has_focus: document.hasFocus() })\n  }).stop\n}\n", "export type RecordIds = ReturnType<typeof initRecordIds>\n\nexport function initRecordIds() {\n  const recordIds = new WeakMap<Event, number>()\n  let nextId = 1\n\n  return {\n    getIdForEvent(event: Event): number {\n      if (!recordIds.has(event)) {\n        recordIds.set(event, nextId++)\n      }\n      return recordIds.get(event)!\n    },\n  }\n}\n", "import type { ListenerHandler } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport type { ElementsScrollPositions } from '../elementsScrollPositions'\nimport type { ShadowRootsController } from '../shadowRootsController'\nimport type { MousemoveCallBack } from './moveObserver'\nimport { initMoveObserver } from './moveObserver'\nimport type { ScrollCallback } from './scrollObserver'\nimport { initScrollObserver } from './scrollObserver'\nimport type { MouseInteractionCallBack } from './mouseInteractionObserver'\nimport { initMouseInteractionObserver } from './mouseInteractionObserver'\nimport type { InputCallback } from './inputObserver'\nimport { initInputObserver } from './inputObserver'\nimport type { StyleSheetCallback } from './styleSheetObserver'\nimport { initStyleSheetObserver } from './styleSheetObserver'\nimport type { MediaInteractionCallback } from './mediaInteractionObserver'\nimport { initMediaInteractionObserver } from './mediaInteractionObserver'\nimport type { FrustrationCallback } from './frustrationObserver'\nimport { initFrustrationObserver } from './frustrationObserver'\nimport type { ViewportResizeCallback, VisualViewportResizeCallback } from './viewportResizeObserver'\nimport { initViewportResizeObserver, initVisualViewportResizeObserver } from './viewportResizeObserver'\nimport type { MutationCallBack } from './mutationObserver'\nimport { initMutationObserver } from './mutationObserver'\nimport type { FocusCallback } from './focusObserver'\nimport { initFocusObserver } from './focusObserver'\nimport { initRecordIds } from './recordIds'\n\ninterface ObserverParam {\n  lifeCycle: LifeCycle\n  configuration: RumConfiguration\n  elementsScrollPositions: ElementsScrollPositions\n  mutationCb: MutationCallBack\n  mousemoveCb: MousemoveCallBack\n  mouseInteractionCb: MouseInteractionCallBack\n  scrollCb: ScrollCallback\n  viewportResizeCb: ViewportResizeCallback\n  visualViewportResizeCb: VisualViewportResizeCallback\n  inputCb: InputCallback\n  mediaInteractionCb: MediaInteractionCallback\n  styleSheetCb: StyleSheetCallback\n  focusCb: FocusCallback\n  frustrationCb: FrustrationCallback\n  shadowRootsController: ShadowRootsController\n}\n\nexport function initObservers(o: ObserverParam): { stop: ListenerHandler; flush: ListenerHandler } {\n  const recordIds = initRecordIds()\n  const mutationHandler = initMutationObserver(o.mutationCb, o.configuration, o.shadowRootsController, document)\n  const mousemoveHandler = initMoveObserver(o.mousemoveCb)\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.configuration.defaultPrivacyLevel,\n    recordIds\n  )\n  const scrollHandler = initScrollObserver(o.scrollCb, o.configuration.defaultPrivacyLevel, o.elementsScrollPositions)\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb)\n  const inputHandler = initInputObserver(o.inputCb, o.configuration.defaultPrivacyLevel)\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.configuration.defaultPrivacyLevel\n  )\n  const styleSheetObserver = initStyleSheetObserver(o.styleSheetCb)\n  const focusHandler = initFocusObserver(o.focusCb)\n  const visualViewportResizeHandler = initVisualViewportResizeObserver(o.visualViewportResizeCb)\n  const frustrationHandler = initFrustrationObserver(o.lifeCycle, o.frustrationCb, recordIds)\n\n  return {\n    flush: () => {\n      mutationHandler.flush()\n    },\n    stop: () => {\n      mutationHandler.stop()\n      mousemoveHandler()\n      mouseInteractionHandler()\n      scrollHandler()\n      viewportResizeHandler()\n      inputHandler()\n      mediaInteractionHandler()\n      styleSheetObserver()\n      focusHandler()\n      visualViewportResizeHandler()\n      frustrationHandler()\n    },\n  }\n}\n", "export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport type ScrollPositions = { scrollLeft: number; scrollTop: number }\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n", "import type { RumConfiguration } from '@datadog/browser-rum-core'\nimport type { InputCallback, MutationCallBack } from './observers'\nimport { initInputObserver, initMutationObserver } from './observers'\n\ninterface ShadowRootController {\n  stop: () => void\n  flush: () => void\n}\n\nexport type ShadowRootCallBack = (shadowRoot: ShadowRoot) => void\n\nexport interface ShadowRootsController {\n  addShadowRoot: ShadowRootCallBack\n  removeShadowRoot: ShadowRootCallBack\n  stop: () => void\n  flush: () => void\n}\n\nexport const initShadowRootsController = (\n  configuration: RumConfiguration,\n  {\n    mutationCb,\n    inputCb,\n  }: {\n    mutationCb: MutationCallBack\n    inputCb: InputCallback\n  }\n): ShadowRootsController => {\n  const controllerByShadowRoot = new Map<ShadowRoot, ShadowRootController>()\n\n  const shadowRootsController: ShadowRootsController = {\n    addShadowRoot: (shadowRoot: ShadowRoot) => {\n      const { stop: stopMutationObserver, flush } = initMutationObserver(\n        mutationCb,\n        configuration,\n        shadowRootsController,\n        shadowRoot\n      )\n      // the change event no do bubble up across the shadow root, we have to listen on the shadow root\n      const stopInputObserver = initInputObserver(inputCb, configuration.defaultPrivacyLevel, shadowRoot)\n      controllerByShadowRoot.set(shadowRoot, {\n        flush,\n        stop: () => {\n          stopMutationObserver()\n          stopInputObserver()\n        },\n      })\n    },\n    removeShadowRoot: (shadowRoot: ShadowRoot) => {\n      const entry = controllerByShadowRoot.get(shadowRoot)\n      if (!entry) {\n        // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n        return\n      }\n      entry.stop()\n      controllerByShadowRoot.delete(shadowRoot)\n    },\n    stop: () => {\n      controllerByShadowRoot.forEach(({ stop }) => stop())\n    },\n    flush: () => {\n      controllerByShadowRoot.forEach(({ flush }) => flush())\n    },\n  }\n  return shadowRootsController\n}\n", "import type { TimeStamp } from '@datadog/browser-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport { getViewportDimension, getScrollX, getScrollY } from '@datadog/browser-rum-core'\nimport type {\n  BrowserMutationData,\n  BrowserMutationPayload,\n  BrowserRecord,\n  InputData,\n  MediaInteractionData,\n  MousemoveData,\n  ScrollData,\n  StyleSheetRuleData,\n  ViewportResizeData,\n} from '../../types'\nimport { RecordType, IncrementalSource } from '../../types'\nimport { assembleIncrementalSnapshot } from './assembly'\nimport { SerializationContextStatus, serializeDocument } from './serialization'\nimport { initObservers } from './observers'\nimport { getVisualViewport } from './viewports'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\nimport type { ShadowRootsController } from './shadowRootsController'\nimport { initShadowRootsController } from './shadowRootsController'\nimport type { InputCallback } from './observers'\n\nexport interface RecordOptions {\n  emit?: (record: BrowserRecord) => void\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  takeSubsequentFullSnapshot: (timestamp?: TimeStamp) => void\n  flushMutations: () => void\n  shadowRootsController: ShadowRootsController\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emit } = options\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required')\n  }\n\n  const elementsScrollPositions = createElementsScrollPositions()\n\n  const mutationCb = (mutation: BrowserMutationPayload) => {\n    emit(assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, mutation))\n  }\n  const inputCb: InputCallback = (s) => emit(assembleIncrementalSnapshot<InputData>(IncrementalSource.Input, s))\n\n  const shadowRootsController = initShadowRootsController(options.configuration, { mutationCb, inputCb })\n\n  const takeFullSnapshot = (\n    timestamp = timeStampNow(),\n    serializationContext = {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT,\n      elementsScrollPositions,\n      shadowRootsController,\n    }\n  ) => {\n    const { width, height } = getViewportDimension()\n    emit({\n      data: {\n        height,\n        href: window.location.href,\n        width,\n      },\n      type: RecordType.Meta,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        has_focus: document.hasFocus(),\n      },\n      type: RecordType.Focus,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        node: serializeDocument(document, options.configuration, serializationContext),\n        initialOffset: {\n          left: getScrollX(),\n          top: getScrollY(),\n        },\n      },\n      type: RecordType.FullSnapshot,\n      timestamp,\n    })\n\n    if (window.visualViewport) {\n      emit({\n        data: getVisualViewport(window.visualViewport),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n  }\n\n  takeFullSnapshot()\n\n  const { stop: stopObservers, flush: flushMutationsFromObservers } = initObservers({\n    lifeCycle: options.lifeCycle,\n    configuration: options.configuration,\n    elementsScrollPositions,\n    inputCb,\n    mediaInteractionCb: (p) =>\n      emit(assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, p)),\n    mouseInteractionCb: (mouseInteractionRecord) => emit(mouseInteractionRecord),\n    mousemoveCb: (positions, source) => emit(assembleIncrementalSnapshot<MousemoveData>(source, { positions })),\n    mutationCb,\n    scrollCb: (p) => emit(assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, p)),\n    styleSheetCb: (r) => emit(assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, r)),\n    viewportResizeCb: (d) => emit(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, d)),\n\n    frustrationCb: (frustrationRecord) => emit(frustrationRecord),\n    focusCb: (data) =>\n      emit({\n        data,\n        type: RecordType.Focus,\n        timestamp: timeStampNow(),\n      }),\n    visualViewportResizeCb: (data) => {\n      emit({\n        data,\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n    shadowRootsController,\n  })\n\n  function flushMutations() {\n    shadowRootsController.flush()\n    flushMutationsFromObservers()\n  }\n\n  return {\n    stop: () => {\n      shadowRootsController.stop()\n      stopObservers()\n    },\n    takeSubsequentFullSnapshot: (timestamp) => {\n      flushMutations()\n      takeFullSnapshot(timestamp, {\n        shadowRootsController,\n        status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT,\n        elementsScrollPositions,\n      })\n    },\n    flushMutations,\n    shadowRootsController,\n  }\n}\n", "import type { Payload } from '@datadog/browser-core'\nimport { assign } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../../types'\n\nexport type BrowserSegmentMetadataAndSegmentSizes = BrowserSegmentMetadata & {\n  raw_segment_size: number\n  compressed_segment_size: number\n}\n\nexport function buildReplayPayload(\n  data: Uint8Array,\n  metadata: BrowserSegmentMetadata,\n  rawSegmentBytesCount: number\n): Payload {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  const metadataAndSegmentSizes: BrowserSegmentMetadataAndSegmentSizes = assign(\n    {\n      raw_segment_size: rawSegmentBytesCount,\n      compressed_segment_size: data.byteLength,\n    },\n    metadata\n  )\n  const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes)\n  formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }))\n\n  return { data: formData, bytesCount: data.byteLength }\n}\n", "import type { ReplayStats } from '@datadog/browser-rum-core'\n\nexport const MAX_STATS_HISTORY = 10\nlet statsPerView: Map<string, ReplayStats> | undefined\n\nexport function getSegmentsCount(viewId: string) {\n  return getOrCreateReplayStats(viewId).segments_count\n}\n\nexport function addSegment(viewId: string) {\n  getOrCreateReplayStats(viewId).segments_count += 1\n}\n\nexport function addRecord(viewId: string) {\n  getOrCreateReplayStats(viewId).records_count += 1\n}\n\nexport function addWroteData(viewId: string, additionalBytesCount: number) {\n  getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount\n}\n\nexport function getReplayStats(viewId: string) {\n  return statsPerView?.get(viewId)\n}\n\nexport function resetReplayStats() {\n  statsPerView = undefined\n}\n\nfunction getOrCreateReplayStats(viewId: string) {\n  if (!statsPerView) {\n    statsPerView = new Map()\n  }\n\n  let replayStats: ReplayStats\n  if (statsPerView.has(viewId)) {\n    replayStats = statsPerView.get(viewId)!\n  } else {\n    replayStats = {\n      records_count: 0,\n      segments_count: 0,\n      segments_total_raw_size: 0,\n    }\n    statsPerView.set(viewId, replayStats)\n    if (statsPerView.size > MAX_STATS_HISTORY) {\n      deleteOldestStats()\n    }\n  }\n\n  return replayStats\n}\n\nfunction deleteOldestStats() {\n  if (!statsPerView) {\n    return\n  }\n  if (statsPerView.keys) {\n    statsPerView.delete(statsPerView.keys().next().value)\n  } else {\n    // IE11 doesn't support map.keys\n    let isFirst = true\n    statsPerView.forEach((_value, key) => {\n      if (isFirst) {\n        statsPerView!.delete(key)\n        isFirst = false\n      }\n    })\n  }\n}\n", "import { addTelemetryDebug, assign, sendToExtension, addEventListener, concatBuffers } from '@datadog/browser-core'\nimport type { DeflateWorkerResponse } from '@datadog/browser-worker'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { DeflateWorker } from './startDeflateWorker'\n\n// Arbitrary id, will be replaced when we have multiple parallel streams.\nconst STREAM_ID = 1\nlet nextId = 0\n\nexport type FlushReason = Exclude<CreationReason, 'init'> | 'stop'\n\nexport class Segment {\n  public flushReason: FlushReason | undefined\n\n  public readonly metadata: BrowserSegmentMetadata\n\n  private id = nextId++\n  private pendingWriteCount = 0\n\n  constructor(\n    private worker: DeflateWorker,\n    context: SegmentContext,\n    creationReason: CreationReason,\n    initialRecord: BrowserRecord,\n    onWrote: (compressedBytesCount: number) => void,\n    onFlushed: (data: Uint8Array, rawBytesCount: number) => void\n  ) {\n    const viewId = context.view.id\n\n    this.metadata = assign(\n      {\n        start: initialRecord.timestamp,\n        end: initialRecord.timestamp,\n        creation_reason: creationReason,\n        records_count: 1,\n        has_full_snapshot: initialRecord.type === RecordType.FullSnapshot,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser' as const,\n      },\n      context\n    )\n\n    replayStats.addSegment(viewId)\n    replayStats.addRecord(viewId)\n    let rawBytesCount = 0\n    let compressedBytesCount = 0\n    const compressedData: Uint8Array[] = []\n\n    const { stop: removeMessageListener } = addEventListener(\n      worker,\n      'message',\n      ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n        if (data.type !== 'wrote') {\n          return\n        }\n\n        if (data.id === this.id) {\n          this.pendingWriteCount -= 1\n          replayStats.addWroteData(viewId, data.additionalBytesCount)\n          rawBytesCount += data.additionalBytesCount\n          compressedBytesCount += data.result.length\n          compressedData.push(data.result)\n          if (this.flushReason && this.pendingWriteCount === 0) {\n            compressedData.push(data.trailer)\n            onFlushed(concatBuffers(compressedData), rawBytesCount)\n            removeMessageListener()\n          } else {\n            onWrote(compressedBytesCount)\n          }\n        } else if (data.id > this.id) {\n          // Messages should be received in the same order as they are sent, so if we receive a\n          // message with an id superior to this Segment instance id, we know that another, more\n          // recent Segment instance is being used.\n          //\n          // In theory, a \"flush\" response should have been received at this point, so the listener\n          // should already have been removed. But if something goes wrong and we didn't receive a\n          // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n          // help investigate the issue.\n          removeMessageListener()\n          addTelemetryDebug(\"Segment did not receive a 'flush' response before being replaced.\")\n        }\n      }\n    )\n    sendToExtension('record', { record: initialRecord, segment: this.metadata })\n    this.write(`{\"records\":[${JSON.stringify(initialRecord)}`)\n  }\n\n  addRecord(record: BrowserRecord): void {\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp)\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp)\n    this.metadata.records_count += 1\n    replayStats.addRecord(this.metadata.view.id)\n    this.metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n    sendToExtension('record', { record, segment: this.metadata })\n    this.write(`,${JSON.stringify(record)}`)\n  }\n\n  flush(reason: FlushReason) {\n    this.write(`],${JSON.stringify(this.metadata).slice(1)}\\n`)\n    this.worker.postMessage({\n      action: 'reset',\n      streamId: STREAM_ID,\n    })\n    this.flushReason = reason\n  }\n\n  private write(data: string) {\n    this.pendingWriteCount += 1\n    this.worker.postMessage({\n      data,\n      id: this.id,\n      streamId: STREAM_ID,\n      action: 'write',\n    })\n  }\n}\n", "import type { HttpRequest, TimeoutId } from '@datadog/browser-core'\nimport { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, CreationReason, SegmentContext } from '../../types'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport type { FlushReason } from './segment'\nimport { Segment } from './segment'\nimport type { DeflateWorker } from './startDeflateWorker'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(applicationId, sessionManager, viewContexts),\n    httpRequest,\n    worker\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  httpRequest: HttpRequest,\n  worker: DeflateWorker\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribePageExited } = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    (pageExitEvent) => {\n      flushSegment(pageExitEvent.reason as FlushReason)\n    }\n  )\n\n  function flushSegment(flushReason: FlushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush(flushReason)\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  function createNewSegment(creationReason: CreationReason, initialRecord: BrowserRecord) {\n    const context = getSegmentContext()\n    if (!context) {\n      return\n    }\n\n    const segment = new Segment(\n      worker,\n      context,\n      creationReason,\n      initialRecord,\n      (compressedSegmentBytesCount) => {\n        if (!segment.flushReason && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      },\n      (data, rawSegmentBytesCount) => {\n        const payload = buildReplayPayload(data, segment.metadata, rawSegmentBytesCount)\n\n        if (isPageExitReason(segment.flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      }\n    )\n\n    state = {\n      status: SegmentCollectionStatus.SegmentPending,\n      segment,\n      expirationTimeoutId: setTimeout(() => {\n        flushSegment('segment_duration_limit')\n      }, SEGMENT_DURATION_LIMIT),\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      switch (state.status) {\n        case SegmentCollectionStatus.WaitingForInitialRecord:\n          createNewSegment(state.nextSegmentCreationReason, record)\n          break\n\n        case SegmentCollectionStatus.SegmentPending:\n          state.segment.addRecord(record)\n          break\n      }\n    },\n\n    stop: () => {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n", "export const workerString = \"!function(){\\\"use strict\\\";function t(t){for(var e=t.reduce((function(t,e){return t+e.length}),0),a=new Uint8Array(e),n=0,r=0,i=t;r<i.length;r++){var s=i[r];a.set(s,n),n+=s.length}return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=256,n=286,r=30,i=15,s=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),_=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),h=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),l=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=new Array(576);e(o);var d=new Array(60);e(d);var u=new Array(512);e(u);var f=new Array(256);e(f);var c=new Array(29);e(c);var p,g,w,v=new Array(r);function b(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function m(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(v);var y=function(t){return t<256?u[t]:u[256+(t>>>7)]},k=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},z=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,k(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},x=function(t,e,a){z(t,a[2*e],a[2*e+1])},A=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},E=function(t,e,a){var n,r,s=new Array(16),_=0;for(n=1;n<=i;n++)s[n]=_=_+a[n-1]<<1;for(r=0;r<=e;r++){var h=t[2*r+1];0!==h&&(t[2*r]=A(s[h]++,h))}},Z=function(t){var e;for(e=0;e<n;e++)t.dyn_ltree[2*e]=0;for(e=0;e<r;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},U=function(t){t.bi_valid>8?k(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},S=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},R=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&S(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!S(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},L=function(t,e,n){var r,i,h,l,o=0;if(0!==t.last_lit)do{r=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],i=t.pending_buf[t.l_buf+o],o++,0===r?x(t,i,e):(h=f[i],x(t,h+a+1,e),0!==(l=s[h])&&(i-=c[h],z(t,i,l)),r--,h=y(r),x(t,h,n),0!==(l=_[h])&&(r-=v[h],z(t,r,l)))}while(o<t.last_lit);x(t,256,e)},F=function(t,e){var a,n,r,s=e.dyn_tree,_=e.stat_desc.static_tree,h=e.stat_desc.has_stree,l=e.stat_desc.elems,o=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<l;a++)0!==s[2*a]?(t.heap[++t.heap_len]=o=a,t.depth[a]=0):s[2*a+1]=0;for(;t.heap_len<2;)s[2*(r=t.heap[++t.heap_len]=o<2?++o:0)]=1,t.depth[r]=0,t.opt_len--,h&&(t.static_len-=_[2*r+1]);for(e.max_code=o,a=t.heap_len>>1;a>=1;a--)R(t,s,a);r=l;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],R(t,s,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,s[2*r]=s[2*a]+s[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,s[2*a+1]=s[2*n+1]=r,t.heap[1]=r++,R(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,s,_,h,l=e.dyn_tree,o=e.max_code,d=e.stat_desc.static_tree,u=e.stat_desc.has_stree,f=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,g=0;for(s=0;s<=i;s++)t.bl_count[s]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(s=l[2*l[2*(n=t.heap[a])+1]+1]+1)>p&&(s=p,g++),l[2*n+1]=s,n>o||(t.bl_count[s]++,_=0,n>=c&&(_=f[n-c]),h=l[2*n],t.opt_len+=h*(s+_),u&&(t.static_len+=h*(d[2*n+1]+_)));if(0!==g){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,g-=2}while(g>0);for(s=p;0!==s;s--)for(n=t.bl_count[s];0!==n;)(r=t.heap[--a])>o||(l[2*r+1]!==s&&(t.opt_len+=(s-l[2*r+1])*l[2*r],l[2*r+1]=s),n--)}}(t,e),E(s,o,t.bl_count)},T=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++_<h&&r===s||(_<l?t.bl_tree[2*r]+=_:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):_<=10?t.bl_tree[34]++:t.bl_tree[36]++,_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4))},I=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++_<h&&r===s)){if(_<l)do{x(t,r,t.bl_tree)}while(0!=--_);else 0!==r?(r!==i&&(x(t,r,t.bl_tree),_--),x(t,16,t.bl_tree),z(t,_-3,2)):_<=10?(x(t,17,t.bl_tree),z(t,_-3,3)):(x(t,18,t.bl_tree),z(t,_-11,7));_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4)}},N=!1,O=function(t,e,a,n){z(t,0+(n?1:0),3),function(t,e,a,n){U(t),n&&(k(t,a),k(t,~a)),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a,!0)},D=function(t,e,n,r){var i,s,_=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,n=4093624447;for(e=0;e<=31;e++,n>>>=1)if(1&n&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),F(t,t.l_desc),F(t,t.d_desc),_=function(t){var e;for(T(t,t.dyn_ltree,t.l_desc.max_code),T(t,t.dyn_dtree,t.d_desc.max_code),F(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*l[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),i=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=i&&(i=s)):i=s=n+5,n+4<=i&&-1!==e?O(t,e,n,r):4===t.strategy||s===i?(z(t,2+(r?1:0),3),L(t,o,d)):(z(t,4+(r?1:0),3),function(t,e,a,n){var r;for(z(t,e-257,5),z(t,a-1,5),z(t,n-4,4),r=0;r<n;r++)z(t,t.bl_tree[2*l[r]+1],3);I(t,t.dyn_ltree,e-1),I(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,_+1),L(t,t.dyn_ltree,t.dyn_dtree)),Z(t),r&&U(t)},B={_tr_init:function(t){N||(!function(){var t,e,a,l,m,y=new Array(16);for(a=0,l=0;l<28;l++)for(c[l]=a,t=0;t<1<<s[l];t++)f[a++]=l;for(f[a-1]=l,m=0,l=0;l<16;l++)for(v[l]=m,t=0;t<1<<_[l];t++)u[m++]=l;for(m>>=7;l<r;l++)for(v[l]=m<<7,t=0;t<1<<_[l]-7;t++)u[256+m++]=l;for(e=0;e<=i;e++)y[e]=0;for(t=0;t<=143;)o[2*t+1]=8,t++,y[8]++;for(;t<=255;)o[2*t+1]=9,t++,y[9]++;for(;t<=279;)o[2*t+1]=7,t++,y[7]++;for(;t<=287;)o[2*t+1]=8,t++,y[8]++;for(E(o,287,y),t=0;t<r;t++)d[2*t+1]=5,d[2*t]=A(t,5);p=new b(o,s,257,n,i),g=new b(d,_,0,r,i),w=new b(new Array(0),h,0,19,7)}(),N=!0),t.l_desc=new m(t.dyn_ltree,p),t.d_desc=new m(t.dyn_dtree,g),t.bl_desc=new m(t.bl_tree,w),t.bi_buf=0,t.bi_valid=0,Z(t)},_tr_stored_block:O,_tr_flush_block:D,_tr_tally:function(t,e,n){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&n,t.last_lit++,0===e?t.dyn_ltree[2*n]++:(t.matches++,e--,t.dyn_ltree[2*(f[n]+a+1)]++,t.dyn_dtree[2*y(e)]++),t.last_lit===t.lit_bufsize-1},_tr_align:function(t){z(t,2,3),x(t,256,o),function(t){16===t.bi_valid?(k(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},C=function(t,e,a,n){for(var r=65535&t|0,i=t>>>16&65535|0,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16|0},H=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),M=function(t,e,a,n){var r=H,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return-1^t},Y={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},K={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},P=B._tr_init,j=B._tr_stored_block,G=B._tr_flush_block,X=B._tr_tally,W=B._tr_align,q=K.Z_NO_FLUSH,J=K.Z_PARTIAL_FLUSH,Q=K.Z_FULL_FLUSH,V=K.Z_FINISH,$=K.Z_BLOCK,tt=K.Z_OK,et=K.Z_STREAM_END,at=K.Z_STREAM_ERROR,nt=K.Z_DATA_ERROR,rt=K.Z_BUF_ERROR,it=K.Z_DEFAULT_COMPRESSION,st=K.Z_FILTERED,_t=K.Z_HUFFMAN_ONLY,ht=K.Z_RLE,lt=K.Z_FIXED,ot=K.Z_DEFAULT_STRATEGY,dt=K.Z_UNKNOWN,ut=K.Z_DEFLATED,ft=258,ct=262,pt=103,gt=113,wt=666,vt=function(t,e){return t.msg=Y[e],e},bt=function(t){return(t<<1)-(t>4?9:0)},mt=function(t){for(var e=t.length;--e>=0;)t[e]=0},yt=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},kt=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},zt=function(t,e){G(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,kt(t.strm)},xt=function(t,e){t.pending_buf[t.pending++]=e},At=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Et=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,_=t.nice_match,h=t.strstart>t.w_size-ct?t.strstart-(t.w_size-ct):0,l=t.window,o=t.w_mask,d=t.prev,u=t.strstart+ft,f=l[i+s-1],c=l[i+s];t.prev_length>=t.good_match&&(r>>=2),_>t.lookahead&&(_=t.lookahead);do{if(l[(a=e)+s]===c&&l[a+s-1]===f&&l[a]===l[i]&&l[++a]===l[i+1]){i+=2,a++;do{}while(l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&i<u);if(n=ft-(u-i),i=u-ft,n>s){if(t.match_start=e,s=n,n>=_)break;f=l[i+s-1],c=l[i+s]}}}while((e=d[e&o])>h&&0!=--r);return s<=t.lookahead?s:t.lookahead},Zt=function(t){var e,a,n,r,i,s,_,h,l,o,d=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=d+(d-ct)){t.window.set(t.window.subarray(d,d+d),0),t.match_start-=d,t.strstart-=d,t.block_start-=d,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=d?n-d:0}while(--a);e=a=d;do{n=t.prev[--e],t.prev[e]=n>=d?n-d:0}while(--a);r+=d}if(0===t.strm.avail_in)break;if(s=t.strm,_=t.window,h=t.strstart+t.lookahead,l=r,o=void 0,(o=s.avail_in)>l&&(o=l),a=0===o?0:(s.avail_in-=o,_.set(s.input.subarray(s.next_in,s.next_in+o),h),1===s.state.wrap?s.adler=C(s.adler,_,o,h):2===s.state.wrap&&(s.adler=M(s.adler,_,o,h)),s.next_in+=o,s.total_in+=o,o),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=yt(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=yt(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<ct&&0!==t.strm.avail_in)},Ut=function(t,e){for(var a,n;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a)),t.match_length>=3)if(n=X(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=yt(t,t.ins_h,t.window[t.strstart+1]);else n=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2},St=function(t,e){for(var a,n,r;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a),t.match_length<=5&&(t.strategy===st||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=X(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(zt(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=X(t,0,t.window[t.strstart-1]))&&zt(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=X(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2};function Rt(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var Lt=[new Rt(0,0,0,0,(function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Zt(t),0===t.lookahead&&e===q)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,zt(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-ct&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(zt(t,!1),t.strm.avail_out),1)})),new Rt(4,4,8,4,Ut),new Rt(4,5,16,8,Ut),new Rt(4,6,32,32,Ut),new Rt(4,4,16,16,St),new Rt(8,16,32,32,St),new Rt(8,16,128,128,St),new Rt(8,32,128,256,St),new Rt(32,128,258,1024,St),new Rt(32,258,258,4096,St)];function Ft(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ut,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),mt(this.dyn_ltree),mt(this.dyn_dtree),mt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),mt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),mt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var Tt=function(t){if(!t||!t.state)return vt(t,at);t.total_in=t.total_out=0,t.data_type=dt;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:gt,t.adler=2===e.wrap?0:1,e.last_flush=q,P(e),tt},It=function(t){var e,a=Tt(t);return a===tt&&((e=t.state).window_size=2*e.w_size,mt(e.head),e.max_lazy_match=Lt[e.level].max_lazy,e.good_match=Lt[e.level].good_length,e.nice_match=Lt[e.level].nice_length,e.max_chain_length=Lt[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),a},Nt=function(t,e,a,n,r,i){if(!t)return at;var s=1;if(e===it&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||a!==ut||n<8||n>15||e<0||e>9||i<0||i>lt)return vt(t,at);8===n&&(n=9);var _=new Ft;return t.state=_,_.strm=t,_.wrap=s,_.gzhead=null,_.w_bits=n,_.w_size=1<<_.w_bits,_.w_mask=_.w_size-1,_.hash_bits=r+7,_.hash_size=1<<_.hash_bits,_.hash_mask=_.hash_size-1,_.hash_shift=~~((_.hash_bits+3-1)/3),_.window=new Uint8Array(2*_.w_size),_.head=new Uint16Array(_.hash_size),_.prev=new Uint16Array(_.w_size),_.lit_bufsize=1<<r+6,_.pending_buf_size=4*_.lit_bufsize,_.pending_buf=new Uint8Array(_.pending_buf_size),_.d_buf=1*_.lit_bufsize,_.l_buf=3*_.lit_bufsize,_.level=e,_.strategy=i,_.method=a,It(t)},Ot={deflateInit:function(t,e){return Nt(t,e,ut,15,8,ot)},deflateInit2:Nt,deflateReset:It,deflateResetKeep:Tt,deflateSetHeader:function(t,e){return t&&t.state?2!==t.state.wrap?at:(t.state.gzhead=e,tt):at},deflate:function(t,e){var a,n;if(!t||!t.state||e>$||e<0)return t?vt(t,at):at;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===wt&&e!==V)return vt(t,0===t.avail_out?rt:at);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,xt(r,31),xt(r,139),xt(r,8),r.gzhead?(xt(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),xt(r,255&r.gzhead.time),xt(r,r.gzhead.time>>8&255),xt(r,r.gzhead.time>>16&255),xt(r,r.gzhead.time>>24&255),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(xt(r,255&r.gzhead.extra.length),xt(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=M(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,3),r.status=gt);else{var s=ut+(r.w_bits-8<<4)<<8;s|=(r.strategy>=_t||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(s|=32),s+=31-s%31,r.status=gt,At(r,s),0!==r.strstart&&(At(r,t.adler>>>16),At(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending!==r.pending_buf_size));)xt(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=pt)}else r.status=pt;if(r.status===pt&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&kt(t),r.pending+2<=r.pending_buf_size&&(xt(r,255&t.adler),xt(r,t.adler>>8&255),t.adler=0,r.status=gt)):r.status=gt),0!==r.pending){if(kt(t),0===t.avail_out)return r.last_flush=-1,tt}else if(0===t.avail_in&&bt(e)<=bt(i)&&e!==V)return vt(t,rt);if(r.status===wt&&0!==t.avail_in)return vt(t,rt);if(0!==t.avail_in||0!==r.lookahead||e!==q&&r.status!==wt){var _=r.strategy===_t?function(t,e){for(var a;;){if(0===t.lookahead&&(Zt(t),0===t.lookahead)){if(e===q)return 1;break}if(t.match_length=0,a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):r.strategy===ht?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=ft){if(Zt(t),t.lookahead<=ft&&e===q)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+ft;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=ft-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=X(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):Lt[r.level].func(r,e);if(3!==_&&4!==_||(r.status=wt),1===_||3===_)return 0===t.avail_out&&(r.last_flush=-1),tt;if(2===_&&(e===J?W(r):e!==$&&(j(r,0,0,!1),e===Q&&(mt(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),kt(t),0===t.avail_out))return r.last_flush=-1,tt}return e!==V?tt:r.wrap<=0?et:(2===r.wrap?(xt(r,255&t.adler),xt(r,t.adler>>8&255),xt(r,t.adler>>16&255),xt(r,t.adler>>24&255),xt(r,255&t.total_in),xt(r,t.total_in>>8&255),xt(r,t.total_in>>16&255),xt(r,t.total_in>>24&255)):(At(r,t.adler>>>16),At(r,65535&t.adler)),kt(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?tt:et)},deflateEnd:function(t){if(!t||!t.state)return at;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==pt&&e!==gt&&e!==wt?vt(t,at):(t.state=null,e===gt?vt(t,nt):tt)},deflateSetDictionary:function(t,e){var a=e.length;if(!t||!t.state)return at;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return at;if(1===r&&(t.adler=C(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(mt(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,_=t.next_in,h=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Zt(n);n.lookahead>=3;){var l=n.strstart,o=n.lookahead-2;do{n.ins_h=yt(n,n.ins_h,n.window[l+3-1]),n.prev[l&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=l,l++}while(--o);n.strstart=l,n.lookahead=2,Zt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=_,t.input=h,t.avail_in=s,n.wrap=r,tt},deflateInfo:\\\"pako deflate (from Nodeca project)\\\"};for(var Dt=new Uint8Array(256),Bt=0;Bt<256;Bt++)Dt[Bt]=Bt>=252?6:Bt>=248?5:Bt>=240?4:Bt>=224?3:Bt>=192?2:1;Dt[254]=Dt[254]=1;var Ct=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},Ht=Object.prototype.toString,Mt=K.Z_NO_FLUSH,Yt=K.Z_SYNC_FLUSH,Kt=K.Z_FULL_FLUSH,Pt=K.Z_FINISH,jt=K.Z_OK,Gt=K.Z_STREAM_END,Xt=K.Z_DEFAULT_COMPRESSION,Wt=K.Z_DEFAULT_STRATEGY,qt=K.Z_DEFLATED;function Jt(){this.options={level:Xt,method:qt,chunkSize:16384,windowBits:15,memLevel:8,strategy:Wt};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;var e=Ot.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==jt)throw new Error(Y[e]);if(t.header&&Ot.deflateSetHeader(this.strm,t.header),t.dictionary){var a;if(a=\\\"[object ArrayBuffer]\\\"===Ht.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(e=Ot.deflateSetDictionary(this.strm,a))!==jt)throw new Error(Y[e]);this._dict_set=!0}}function Qt(t,e,a){try{t.postMessage({type:\\\"errored\\\",error:e,streamId:a})}catch(n){t.postMessage({type:\\\"errored\\\",error:String(e),streamId:a})}}function Vt(t){var e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}Jt.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Pt:Mt,\\\"[object ArrayBuffer]\\\"===Ht.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(n===Yt||n===Kt)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if((a=Ot.deflate(r,n))===Gt)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=Ot.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===jt;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},Jt.prototype.onData=function(t){this.chunks.push(t)},Jt.prototype.onEnd=function(t){t===jt&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,_=t.length;i<_;i++){var h=t[i];r.set(h,s),s+=h.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e){void 0===e&&(e=self);try{var a=new Map;e.addEventListener(\\\"message\\\",(function(n){try{var r=function(e,a){switch(a.action){case\\\"init\\\":return{type:\\\"initialized\\\",version:\\\"4.46.0\\\"};case\\\"write\\\":var n=e.get(a.streamId);n||(n=new Jt,e.set(a.streamId,n));var r=n.chunks.length,i=function(t){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);var e,a,n,r,i,s=t.length,_=0;for(r=0;r<s;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),_+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(_),i=0,r=0;i<_;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,K.Z_SYNC_FLUSH),{type:\\\"wrote\\\",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:Vt(n),additionalBytesCount:i.length};case\\\"reset\\\":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){Qt(e,t,n.data&&\\\"streamId\\\"in n.data?n.data.streamId:void 0)}}))}catch(t){Qt(e,t)}}()}();\"\n", "import { addTelemetryError, display, includes, addEventListener } from '@datadog/browser-core'\nimport type { DeflateWorkerAction, DeflateWorkerResponse } from '@datadog/browser-worker'\nimport { workerString } from '@datadog/browser-worker/string'\n\n/**\n * In order to be sure that the worker is correctly working, we need a round trip of\n * initialization messages, making the creation asynchronous.\n * These worker lifecycle states handle this case.\n */\nconst enum DeflateWorkerStatus {\n  Nil,\n  Loading,\n  Error,\n  Initialized,\n}\n\ntype DeflateWorkerState =\n  | {\n      status: DeflateWorkerStatus.Nil\n    }\n  | {\n      status: DeflateWorkerStatus.Loading\n      callbacks: Array<(worker?: DeflateWorker) => void>\n    }\n  | {\n      status: DeflateWorkerStatus.Error\n    }\n  | {\n      status: DeflateWorkerStatus.Initialized\n      worker: DeflateWorker\n      version: string\n    }\n\nexport interface DeflateWorker extends Worker {\n  postMessage(message: DeflateWorkerAction): void\n}\n\nlet workerURL: string | undefined\n\nexport function createDeflateWorker(): DeflateWorker {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([workerString]))\n  }\n  return new Worker(workerURL)\n}\n\nlet state: DeflateWorkerState = { status: DeflateWorkerStatus.Nil }\n\nexport function startDeflateWorker(\n  callback: (worker?: DeflateWorker) => void,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  switch (state.status) {\n    case DeflateWorkerStatus.Nil:\n      state = { status: DeflateWorkerStatus.Loading, callbacks: [callback] }\n      doStartDeflateWorker(createDeflateWorkerImpl)\n      break\n    case DeflateWorkerStatus.Loading:\n      state.callbacks.push(callback)\n      break\n    case DeflateWorkerStatus.Error:\n      callback()\n      break\n    case DeflateWorkerStatus.Initialized:\n      callback(state.worker)\n      break\n  }\n}\n\nexport function resetDeflateWorkerState() {\n  state = { status: DeflateWorkerStatus.Nil }\n}\n\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(createDeflateWorkerImpl = createDeflateWorker) {\n  try {\n    const worker = createDeflateWorkerImpl()\n    addEventListener(worker, 'error', onError)\n    addEventListener(worker, 'message', ({ data }: MessageEvent<DeflateWorkerResponse>) => {\n      if (data.type === 'errored') {\n        onError(data.error, data.streamId)\n      } else if (data.type === 'initialized') {\n        onInitialized(worker, data.version)\n      }\n    })\n    worker.postMessage({ action: 'init' })\n    return worker\n  } catch (error) {\n    onError(error)\n  }\n}\n\nfunction onInitialized(worker: DeflateWorker, version: string) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    state.callbacks.forEach((callback) => callback(worker))\n    state = { status: DeflateWorkerStatus.Initialized, worker, version }\n  }\n}\n\nfunction onError(error: unknown, streamId?: number) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error('Session Replay recording failed to start: an error occurred while creating the Worker:', error)\n    if (error instanceof Event || (error instanceof Error && isMessageCspRelated(error.message))) {\n      display.error(\n        'Please make sure CSP is correctly configured ' +\n          'https://docs.datadoghq.com/real_user_monitoring/faq/content_security_policy'\n      )\n    } else {\n      addTelemetryError(error)\n    }\n    state.callbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  } else {\n    addTelemetryError(error, {\n      worker_version: state.status === DeflateWorkerStatus.Initialized && state.version,\n      stream_id: streamId,\n    })\n  }\n}\n\nfunction isMessageCspRelated(message: string) {\n  return (\n    includes(message, 'Content Security Policy') ||\n    // Related to `require-trusted-types-for` CSP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted-types-for\n    includes(message, \"requires 'TrustedScriptURL'\")\n  )\n}\n", "import type { RawError, HttpRequest } from '@datadog/browser-core'\nimport { timeStampNow, createHttpRequest, addTelemetryDebug } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumConfiguration,\n  RumSessionManager,\n  ViewCreatedEvent,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport { record } from '../domain/record'\nimport type { DeflateWorker } from '../domain/segmentCollection'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection'\nimport { RecordType } from '../types'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  worker: DeflateWorker,\n  httpRequest?: HttpRequest\n) {\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n\n  const replayRequest =\n    httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError)\n\n  const { addRecord, stop: stopSegmentCollection } = startSegmentCollection(\n    lifeCycle,\n    configuration.applicationId,\n    sessionManager,\n    viewContexts,\n    replayRequest,\n    worker\n  )\n\n  const {\n    stop: stopRecording,\n    takeSubsequentFullSnapshot,\n    flushMutations,\n  } = record({\n    emit: addRecord,\n    configuration,\n    lifeCycle,\n  })\n\n  const { unsubscribe: unsubscribeViewEnded } = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    flushMutations()\n    addRecord({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(\n    LifeCycleEventType.VIEW_CREATED,\n    (view: ViewCreatedEvent) => {\n      takeSubsequentFullSnapshot(view.startClocks.timeStamp)\n    }\n  )\n\n  return {\n    stop: () => {\n      unsubscribeViewEnded()\n      unsubscribeViewCreated()\n      stopRecording()\n      stopSegmentCollection()\n    },\n  }\n}\n", "/**\n * Test for Browser features used while recording\n */\nexport function isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' &&\n    typeof CSSSupportsRule === 'function' &&\n    typeof URL.createObjectURL === 'function' &&\n    'forEach' in NodeList.prototype\n  )\n}\n", "import type { RumConfiguration, RumSessionManager, ViewContexts, RumSession } from '@datadog/browser-rum-core'\nimport { getSessionReplayUrl } from '@datadog/browser-rum-core'\nimport { isBrowserSupported } from '../boot/isBrowserSupported'\n\nexport function getSessionReplayLink(\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  isRecordingStarted: boolean\n): string | undefined {\n  const session = sessionManager.findTrackedSession()\n  const errorType = getErrorType(session, isRecordingStarted)\n  const viewContext = viewContexts.findView()\n\n  return getSessionReplayUrl(configuration, {\n    viewContext,\n    errorType,\n    session,\n  })\n}\n\nfunction getErrorType(session: RumSession | undefined, isRecordingStarted: boolean) {\n  if (!isBrowserSupported()) {\n    return 'browser-not-supported'\n  }\n  if (!session) {\n    // possibilities:\n    // - rum sampled out\n    // - session expired (edge case)\n    return 'rum-not-tracked'\n  }\n  if (!session.sessionReplayAllowed) {\n    // possibilities\n    // - replay sampled out\n    return 'incorrect-session-plan'\n  }\n  if (!isRecordingStarted) {\n    return 'replay-not-started'\n  }\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, canUseEventBridge, noop, runOnReadyState, relativeNow } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { getReplayStats } from '../domain/replayStats'\nimport { getSessionReplayLink } from '../domain/getSessionReplayLink'\nimport { startDeflateWorker } from '../domain/segmentCollection'\n\nimport { getSerializedNodeId } from '../domain/record'\nimport type { startRecording } from './startRecording'\nimport { isBrowserSupported } from './isBrowserSupported'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  startDeflateWorkerImpl = startDeflateWorker\n): RecorderApi {\n  const recorderStartObservable = new Observable<RelativeTime>()\n\n  if (canUseEventBridge() || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n      getSessionReplayLink: () => undefined,\n      getSerializedNodeId: () => undefined,\n      recorderStartObservable,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.Stopped,\n  }\n\n  let startStrategy = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  return {\n    start: () => startStrategy(),\n    stop: () => stopStrategy(),\n    getReplayStats,\n    getSessionReplayLink: (configuration, sessionManager, viewContexts) =>\n      getSessionReplayLink(configuration, sessionManager, viewContexts, state.status !== RecorderStatus.Stopped),\n    recorderStartObservable,\n    getSerializedNodeId,\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts\n    ) => {\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      startStrategy = () => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || !session.sessionReplayAllowed) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState('interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          startDeflateWorkerImpl((worker) => {\n            if (state.status !== RecorderStatus.Starting) {\n              return\n            }\n\n            if (!worker) {\n              state = {\n                status: RecorderStatus.Stopped,\n              }\n              return\n            }\n\n            const { stop: stopRecording } = startRecordingImpl(\n              lifeCycle,\n              configuration,\n              sessionManager,\n              viewContexts,\n              worker\n            )\n            recorderStartObservable.notify(relativeNow())\n            state = {\n              status: RecorderStatus.Started,\n              stopRecording,\n            }\n          })\n        })\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () => state.status === RecorderStatus.Started,\n  }\n}\n", "// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\n\nimport { startRecording } from '../boot/startRecording'\nimport { makeRecorderApi } from '../boot/recorderApi'\n\nexport {\n  CommonProperties,\n  RumPublicApi as RumGlobal,\n  RumInitConfiguration,\n  // Events\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nconst recorderApi = makeRecorderApi(startRecording)\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi)\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n"],
  "mappings": "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",
  "names": ["_a", "tracingOption", "TraceIdentifier", "_a", "recorderApi", "recorderApi", "_a", "_a", "document", "_a", "_a", "buildCommonContext", "_a", "event", "_a", "_a", "_a", "label", "element", "attributeName", "_a", "_a", "history", "_a", "isRage", "_a", "_a", "stopListeners", "_a", "_a", "window", "endTime", "_a", "location", "locationChangeObservable", "_a", "_b", "name", "location", "recorderApi", "_a", "location", "_a", "location", "_a", "_a", "recorderApi", "_a", "recorderApi", "_a", "_b", "location", "buildCommonContext", "_a", "_a", "_a", "document", "_a", "document", "_a", "record", "target", "_a", "_a", "_a", "mutation", "node", "serializedNodeIds", "nextId", "_a", "_a", "Segment", "_a", "record", "state", "record", "_a", "_a", "addRecord", "state"]
}
