{
  "version": 3,
  "sources": ["../../../../../node_modules/@datadog/browser-logs/src/domain/configuration.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logger.ts", "../../../../../node_modules/@datadog/browser-logs/src/boot/logsPublicApi.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsSessionManager.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsCollection/logger/loggerCollection.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/assembly.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsCollection/console/consoleCollection.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsCollection/report/reportCollection.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsCollection/networkError/networkErrorCollection.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/logsCollection/runtimeError/runtimeErrorCollection.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/lifeCycle.ts", "../../../../../node_modules/@datadog/browser-logs/src/transport/startLogsBatch.ts", "../../../../../node_modules/@datadog/browser-logs/src/transport/startLogsBridge.ts", "../../../../../node_modules/@datadog/browser-logs/src/domain/internalContext.ts", "../../../../../node_modules/@datadog/browser-logs/src/boot/startLogs.ts", "../../../../../node_modules/@datadog/browser-logs/src/entries/main.ts"],
  "sourcesContent": ["import type { Configuration, InitConfiguration, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  ONE_KIBI_BYTE,\n  validateAndBuildConfiguration,\n  display,\n  removeDuplicates,\n  ConsoleApiName,\n  RawReportType,\n  includes,\n  objectValues,\n} from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport interface LogsInitConfiguration extends InitConfiguration {\n  beforeSend?: ((event: LogsEvent) => void | boolean) | undefined\n  forwardErrorsToLogs?: boolean | undefined\n  forwardConsoleLogs?: ConsoleApiName[] | 'all' | undefined\n  forwardReports?: RawReportType[] | 'all' | undefined\n}\n\nexport type HybridInitConfiguration = Omit<LogsInitConfiguration, 'clientToken'>\n\nexport interface LogsConfiguration extends Configuration {\n  forwardErrorsToLogs: boolean\n  forwardConsoleLogs: ConsoleApiName[]\n  forwardReports: RawReportType[]\n  requestErrorResponseLengthLimit: number\n}\n\n/**\n * arbitrary value, byte precision not needed\n */\nexport const DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE\n\nexport function validateAndBuildLogsConfiguration(\n  initConfiguration: LogsInitConfiguration\n): LogsConfiguration | undefined {\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n\n  const forwardConsoleLogs = validateAndBuildForwardOption<ConsoleApiName>(\n    initConfiguration.forwardConsoleLogs,\n    objectValues(ConsoleApiName),\n    'Forward Console Logs'\n  )\n\n  const forwardReports = validateAndBuildForwardOption<RawReportType>(\n    initConfiguration.forwardReports,\n    objectValues(RawReportType),\n    'Forward Reports'\n  )\n\n  if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {\n    return\n  }\n\n  if (initConfiguration.forwardErrorsToLogs && !includes(forwardConsoleLogs, ConsoleApiName.error)) {\n    forwardConsoleLogs.push(ConsoleApiName.error)\n  }\n\n  return assign(\n    {\n      forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,\n      forwardConsoleLogs,\n      forwardReports,\n      requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT,\n    },\n    baseConfiguration\n  )\n}\n\nexport function validateAndBuildForwardOption<T>(\n  option: readonly T[] | 'all' | undefined,\n  allowedValues: T[],\n  label: string\n): T[] | undefined {\n  if (option === undefined) {\n    return []\n  }\n\n  if (!(option === 'all' || (Array.isArray(option) && option.every((api) => includes(allowedValues, api))))) {\n    display.error(`${label} should be \"all\" or an array with allowed values \"${allowedValues.join('\", \"')}\"`)\n    return\n  }\n\n  return option === 'all' ? allowedValues : removeDuplicates<T>(option)\n}\n\nexport function serializeLogsConfiguration(configuration: LogsInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedInitConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      forward_errors_to_logs: configuration.forwardErrorsToLogs,\n      forward_console_logs: configuration.forwardConsoleLogs,\n      forward_reports: configuration.forwardReports,\n    },\n    baseSerializedInitConfiguration\n  )\n}\n", "import type { Context } from '@datadog/browser-core'\nimport {\n  clocksNow,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  CustomerDataType,\n  assign,\n  combine,\n  createContextManager,\n  ErrorSource,\n  monitored,\n  sanitize,\n  NonErrorPrefix,\n} from '@datadog/browser-core'\n\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport interface LogsMessage {\n  message: string\n  status: StatusType\n  context?: Context\n}\n\nexport const StatusType = {\n  debug: 'debug',\n  error: 'error',\n  info: 'info',\n  warn: 'warn',\n} as const\n\nexport type StatusType = (typeof StatusType)[keyof typeof StatusType]\n\nexport const HandlerType = {\n  console: 'console',\n  http: 'http',\n  silent: 'silent',\n} as const\n\nexport type HandlerType = (typeof HandlerType)[keyof typeof HandlerType]\nexport const STATUSES = Object.keys(StatusType) as StatusType[]\n\nexport class Logger {\n  private contextManager = createContextManager(CustomerDataType.LoggerContext)\n\n  constructor(\n    private handleLogStrategy: (logsMessage: LogsMessage, logger: Logger) => void,\n    name?: string,\n    private handlerType: HandlerType | HandlerType[] = HandlerType.http,\n    private level: StatusType = StatusType.debug,\n    loggerContext: object = {}\n  ) {\n    this.contextManager.set(assign({}, loggerContext, name ? { logger: { name } } : undefined))\n  }\n\n  @monitored\n  log(message: string, messageContext?: object, status: StatusType = StatusType.info, error?: Error) {\n    let errorContext: LogsEvent['error']\n\n    if (status === StatusType.error) {\n      // Always add origin if status is error (backward compatibility - Remove in next major)\n      errorContext = { origin: ErrorSource.LOGGER }\n    }\n\n    if (error !== undefined && error !== null) {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        nonErrorPrefix: NonErrorPrefix.PROVIDED,\n        source: ErrorSource.LOGGER,\n        handling: ErrorHandling.HANDLED,\n        startClocks: clocksNow(),\n      })\n\n      errorContext = {\n        origin: ErrorSource.LOGGER, // Remove in next major\n        stack: rawError.stack,\n        kind: rawError.type,\n        message: rawError.message,\n      }\n    }\n\n    const sanitizedMessageContext = sanitize(messageContext) as Context\n\n    const context = errorContext\n      ? (combine({ error: errorContext }, sanitizedMessageContext) as Context)\n      : sanitizedMessageContext\n\n    this.handleLogStrategy(\n      {\n        message: sanitize(message)!,\n        context,\n        status,\n      },\n      this\n    )\n  }\n\n  debug(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.debug, error)\n  }\n\n  info(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.info, error)\n  }\n\n  warn(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.warn, error)\n  }\n\n  error(message: string, messageContext?: object, error?: Error) {\n    this.log(message, messageContext, StatusType.error, error)\n  }\n\n  setContext(context: object) {\n    this.contextManager.set(context)\n  }\n\n  getContext() {\n    return this.contextManager.get()\n  }\n\n  addContext(key: string, value: any) {\n    this.contextManager.add(key, value)\n  }\n\n  removeContext(key: string) {\n    this.contextManager.remove(key)\n  }\n\n  setHandler(handler: HandlerType | HandlerType[]) {\n    this.handlerType = handler\n  }\n\n  getHandler() {\n    return this.handlerType\n  }\n\n  setLevel(level: StatusType) {\n    this.level = level\n  }\n\n  getLevel() {\n    return this.level\n  }\n}\n", "import type { Context, InitConfiguration, User } from '@datadog/browser-core'\nimport {\n  CustomerDataType,\n  assign,\n  BoundedBuffer,\n  createContextManager,\n  makePublicApi,\n  monitor,\n  display,\n  deepClone,\n  canUseEventBridge,\n  timeStampNow,\n  checkUser,\n  sanitizeUser,\n  sanitize,\n} from '@datadog/browser-core'\nimport type { LogsInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildLogsConfiguration } from '../domain/configuration'\nimport type { HandlerType, StatusType, LogsMessage } from '../domain/logger'\nimport { Logger } from '../domain/logger'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { startLogs } from './startLogs'\n\nexport interface LoggerConfiguration {\n  level?: StatusType\n  handler?: HandlerType | HandlerType[]\n  context?: object\n}\n\nexport type LogsPublicApi = ReturnType<typeof makeLogsPublicApi>\n\nexport type StartLogs = typeof startLogs\n\ntype StartLogsResult = ReturnType<typeof startLogs>\n\nexport function makeLogsPublicApi(startLogsImpl: StartLogs) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager(CustomerDataType.GlobalContext)\n  const userContextManager = createContextManager(CustomerDataType.User)\n\n  const customLoggers: { [name: string]: Logger | undefined } = {}\n  let getInternalContextStrategy: StartLogsResult['getInternalContext'] = () => undefined\n\n  const beforeInitLoggerLog = new BoundedBuffer()\n\n  let handleLogStrategy: StartLogsResult['handleLog'] = (\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext = deepClone(buildCommonContext()),\n    date = timeStampNow()\n  ) => {\n    beforeInitLoggerLog.add(() => handleLogStrategy(logsMessage, logger, savedCommonContext, date))\n  }\n\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n  const mainLogger = new Logger((...params) => handleLogStrategy(...params))\n\n  function buildCommonContext(): CommonContext {\n    return {\n      view: {\n        referrer: document.referrer,\n        url: window.location.href,\n      },\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  }\n\n  return makePublicApi({\n    logger: mainLogger,\n\n    init: monitor((initConfiguration: LogsInitConfiguration) => {\n      // This function should be available, regardless of initialization success.\n      getInitConfigurationStrategy = () => deepClone(initConfiguration)\n\n      if (canUseEventBridge()) {\n        initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n      }\n\n      if (!canInitLogs(initConfiguration)) {\n        return\n      }\n\n      const configuration = validateAndBuildLogsConfiguration(initConfiguration)\n      if (!configuration) {\n        return\n      }\n\n      ;({ handleLog: handleLogStrategy, getInternalContext: getInternalContextStrategy } = startLogsImpl(\n        initConfiguration,\n        configuration,\n        buildCommonContext,\n        mainLogger\n      ))\n\n      beforeInitLoggerLog.drain()\n\n      isAlreadyInitialized = true\n    }),\n\n    /** @deprecated: use getGlobalContext instead */\n    getLoggerGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setLoggerGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addLoggerGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeLoggerGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    createLogger: monitor((name: string, conf: LoggerConfiguration = {}) => {\n      customLoggers[name] = new Logger(\n        (...params) => handleLogStrategy(...params),\n        sanitize(name),\n        conf.handler,\n        conf.level,\n        sanitize(conf.context) as object\n      )\n\n      return customLoggers[name]!\n    }),\n\n    getLogger: monitor((name: string) => customLoggers[name]),\n\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    getInternalContext: monitor((startTime?: number | undefined) => getInternalContextStrategy(startTime)),\n\n    setUser: monitor((newUser: User) => {\n      if (checkUser(newUser)) {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(userContextManager.getContext),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor(userContextManager.removeContextProperty),\n\n    clearUser: monitor(userContextManager.clearContext),\n  })\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, { clientToken: 'empty' })\n  }\n\n  function canInitLogs(initConfiguration: LogsInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_LOGS is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport { Observable, performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { LogsConfiguration } from './configuration'\n\nexport const LOGS_SESSION_KEY = 'logs'\n\nexport interface LogsSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => LogsSession | undefined\n  expireObservable: Observable<void>\n}\n\nexport type LogsSession = {\n  id?: string // session can be tracked without id\n}\n\nexport const enum LoggerTrackingType {\n  NOT_TRACKED = '0',\n  TRACKED = '1',\n}\n\nexport function startLogsSessionManager(configuration: LogsConfiguration): LogsSessionManager {\n  const sessionManager = startSessionManager(\n    // TODO - Improve configuration type and remove assertion\n    configuration.sessionStoreStrategyType!,\n    LOGS_SESSION_KEY,\n    (rawTrackingType) => computeSessionState(configuration, rawTrackingType)\n  )\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      return session && session.trackingType === LoggerTrackingType.TRACKED\n        ? {\n            id: session.id,\n          }\n        : undefined\n    },\n    expireObservable: sessionManager.expireObservable,\n  }\n}\n\nexport function startLogsSessionManagerStub(configuration: LogsConfiguration): LogsSessionManager {\n  const isTracked = computeTrackingType(configuration) === LoggerTrackingType.TRACKED\n  const session = isTracked ? {} : undefined\n  return {\n    findTrackedSession: () => session,\n    expireObservable: new Observable(),\n  }\n}\n\nfunction computeTrackingType(configuration: LogsConfiguration) {\n  if (!performDraw(configuration.sessionSampleRate)) {\n    return LoggerTrackingType.NOT_TRACKED\n  }\n  return LoggerTrackingType.TRACKED\n}\n\nfunction computeSessionState(configuration: LogsConfiguration, rawSessionType?: string) {\n  const trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration)\n  return {\n    trackingType,\n    isTracked: trackingType === LoggerTrackingType.TRACKED,\n  }\n}\n\nfunction hasValidLoggerSession(trackingType?: string): trackingType is LoggerTrackingType {\n  return trackingType === LoggerTrackingType.NOT_TRACKED || trackingType === LoggerTrackingType.TRACKED\n}\n", "import type { TimeStamp } from '@datadog/browser-core'\nimport { includes, display, combine, ErrorSource, timeStampNow } from '@datadog/browser-core'\nimport type { CommonContext } from '../../../rawLogsEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { Logger, LogsMessage } from '../../logger'\nimport { StatusType, HandlerType } from '../../logger'\n\nexport const STATUS_PRIORITIES: { [key in StatusType]: number } = {\n  [StatusType.debug]: 0,\n  [StatusType.info]: 1,\n  [StatusType.warn]: 2,\n  [StatusType.error]: 3,\n}\n\nexport function startLoggerCollection(lifeCycle: LifeCycle) {\n  function handleLog(\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext?: CommonContext,\n    savedDate?: TimeStamp\n  ) {\n    const messageContext = logsMessage.context\n\n    if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {\n      display(logsMessage.status, logsMessage.message, combine(logger.getContext(), messageContext))\n    }\n\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: savedDate || timeStampNow(),\n        message: logsMessage.message,\n        status: logsMessage.status,\n        origin: ErrorSource.LOGGER,\n      },\n      messageContext,\n      savedCommonContext,\n      logger,\n    })\n  }\n\n  return {\n    handleLog,\n  }\n}\n\nexport function isAuthorized(status: StatusType, handlerType: HandlerType, logger: Logger) {\n  const loggerHandler = logger.getHandler()\n  const sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler]\n  return (\n    STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && includes(sanitizedHandlerType, handlerType)\n  )\n}\n", "import type { Context, EventRateLimiter, RawError, RelativeTime } from '@datadog/browser-core'\nimport {\n  getSyntheticsResultId,\n  getSyntheticsTestId,\n  addTelemetryDebug,\n  willSyntheticsInjectRum,\n  ErrorSource,\n  combine,\n  createEventRateLimiter,\n  getRelativeTime,\n  isEmptyObject,\n} from '@datadog/browser-core'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { LogsConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { Logger } from './logger'\nimport { STATUSES, HandlerType } from './logger'\nimport { isAuthorized } from './logsCollection/logger/loggerCollection'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport function startLogsAssembly(\n  sessionManager: LogsSessionManager,\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  buildCommonContext: () => CommonContext,\n  mainLogger: Logger, // Todo: [RUMF-1230] Remove this parameter in the next major release\n  reportError: (error: RawError) => void\n) {\n  const statusWithCustom = (STATUSES as string[]).concat(['custom'])\n  const logRateLimiters: { [key: string]: EventRateLimiter } = {}\n  statusWithCustom.forEach((status) => {\n    logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError)\n  })\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_LOG_COLLECTED,\n    ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, logger = mainLogger }) => {\n      const startTime = getRelativeTime(rawLogsEvent.date)\n      const session = sessionManager.findTrackedSession(startTime)\n\n      if (!session) {\n        return\n      }\n\n      const commonContext = savedCommonContext || buildCommonContext()\n      const log = combine(\n        {\n          service: configuration.service,\n          session_id: session.id,\n          // Insert user first to allow overrides from global context\n          usr: !isEmptyObject(commonContext.user) ? commonContext.user : undefined,\n          view: commonContext.view,\n        },\n        commonContext.context,\n        getRUMInternalContext(startTime),\n        rawLogsEvent,\n        logger.getContext(),\n        messageContext\n      )\n\n      if (\n        // Todo: [RUMF-1230] Move this check to the logger collection in the next major release\n        !isAuthorized(rawLogsEvent.status, HandlerType.http, logger) ||\n        configuration.beforeSend?.(log) === false ||\n        (log.error?.origin !== ErrorSource.AGENT &&\n          (logRateLimiters[log.status] ?? logRateLimiters['custom']).isLimitReached())\n      ) {\n        return\n      }\n\n      lifeCycle.notify(LifeCycleEventType.LOG_COLLECTED, log)\n    }\n  )\n}\n\ninterface Rum {\n  getInternalContext?: (startTime?: RelativeTime) => Context | undefined\n}\n\ninterface BrowserWindow {\n  DD_RUM?: Rum\n  DD_RUM_SYNTHETICS?: Rum\n}\n\nlet logsSentBeforeRumInjectionTelemetryAdded = false\n\nexport function getRUMInternalContext(startTime?: RelativeTime): Context | undefined {\n  const browserWindow = window as BrowserWindow\n\n  if (willSyntheticsInjectRum()) {\n    const context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS)\n    if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {\n      logsSentBeforeRumInjectionTelemetryAdded = true\n      addTelemetryDebug('Logs sent before RUM is injected by the synthetics worker', {\n        testId: getSyntheticsTestId(),\n        resultId: getSyntheticsResultId(),\n      })\n    }\n    return context\n  }\n\n  return getInternalContextFromRumGlobal(browserWindow.DD_RUM)\n\n  function getInternalContextFromRumGlobal(rumGlobal?: Rum): Context | undefined {\n    if (rumGlobal && rumGlobal.getInternalContext) {\n      return rumGlobal.getInternalContext(startTime)\n    }\n  }\n}\n\nexport function resetRUMInternalContext() {\n  logsSentBeforeRumInjectionTelemetryAdded = false\n}\n", "import type { Context, ClocksState, ConsoleLog } from '@datadog/browser-core'\nimport { timeStampNow, ConsoleApiName, ErrorSource, initConsoleObservable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForApi = {\n  [ConsoleApiName.log]: StatusType.info,\n  [ConsoleApiName.debug]: StatusType.debug,\n  [ConsoleApiName.info]: StatusType.info,\n  [ConsoleApiName.warn]: StatusType.warn,\n  [ConsoleApiName.error]: StatusType.error,\n}\nexport function startConsoleCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe((log: ConsoleLog) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message: log.message,\n        origin: ErrorSource.CONSOLE,\n        error:\n          log.api === ConsoleApiName.error\n            ? {\n                origin: ErrorSource.CONSOLE, // Todo: Remove in the next major release\n                stack: log.stack,\n                fingerprint: log.fingerprint,\n              }\n            : undefined,\n        status: LogStatusForApi[log.api],\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      consoleSubscription.unsubscribe()\n    },\n  }\n}\n", "import type { Context, ClocksState, RawReport } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  ErrorSource,\n  RawReportType,\n  getFileFromStackTraceString,\n  initReportObservable,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForReport = {\n  [RawReportType.cspViolation]: StatusType.error,\n  [RawReportType.intervention]: StatusType.error,\n  [RawReportType.deprecation]: StatusType.warn,\n}\n\nexport function startReportCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const reportSubscription = initReportObservable(configuration.forwardReports).subscribe((report: RawReport) => {\n    let message = report.message\n    const status = LogStatusForReport[report.type]\n    let error\n    if (status === StatusType.error) {\n      error = {\n        kind: report.subtype,\n        origin: ErrorSource.REPORT, // Todo: Remove in the next major release\n        stack: report.stack,\n      }\n    } else if (report.stack) {\n      message += ` Found in ${getFileFromStackTraceString(report.stack)!}`\n    }\n\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message,\n        origin: ErrorSource.REPORT,\n        error,\n        status,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      reportSubscription.unsubscribe()\n    },\n  }\n}\n", "import type { FetchResolveContext, XhrCompleteContext } from '@datadog/browser-core'\nimport {\n  ErrorSource,\n  initXhrObservable,\n  RequestType,\n  initFetchObservable,\n  computeStackTrace,\n  toStackTraceString,\n  monitor,\n  noop,\n  readBytesFromStream,\n  tryToClone,\n  isServerError,\n} from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport function startNetworkErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const xhrSubscription = initXhrObservable().subscribe((context) => {\n    if (context.state === 'complete') {\n      handleResponse(RequestType.XHR, context)\n    }\n  })\n  const fetchSubscription = initFetchObservable().subscribe((context) => {\n    if (context.state === 'resolve') {\n      handleResponse(RequestType.FETCH, context)\n    }\n  })\n\n  function handleResponse(type: RequestType, request: XhrCompleteContext | FetchResolveContext) {\n    if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || isServerError(request.status))) {\n      if ('xhr' in request) {\n        computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable)\n      } else if (request.response) {\n        computeFetchResponseText(request.response, configuration, onResponseDataAvailable)\n      } else if (request.error) {\n        computeFetchErrorText(request.error, configuration, onResponseDataAvailable)\n      }\n    }\n\n    function onResponseDataAvailable(responseData: unknown) {\n      lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          message: `${format(type)} error ${request.method} ${request.url}`,\n          date: request.startClocks.timeStamp,\n          error: {\n            origin: ErrorSource.NETWORK, // Todo: Remove in the next major release\n            stack: (responseData as string) || 'Failed to load',\n          },\n          http: {\n            method: request.method as any, // Cast resource method because of case mismatch cf issue RUMF-1152\n            status_code: request.status,\n            url: request.url,\n          },\n          status: StatusType.error,\n          origin: ErrorSource.NETWORK,\n        },\n      })\n    }\n  }\n\n  return {\n    stop: () => {\n      xhrSubscription.unsubscribe()\n      fetchSubscription.unsubscribe()\n    },\n  }\n}\n\n// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of\n// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different\n// than \"text\", the response data should be whatever `xhr.response` is. This is a bit confusing as\n// Logs event 'stack' is expected to be a string. This should be changed in a future major version\n// as it could be a breaking change.\nexport function computeXhrResponseData(\n  xhr: XMLHttpRequest,\n  configuration: LogsConfiguration,\n  callback: (responseData: unknown) => void\n) {\n  if (typeof xhr.response === 'string') {\n    callback(truncateResponseText(xhr.response, configuration))\n  } else {\n    callback(xhr.response)\n  }\n}\n\nexport function computeFetchErrorText(\n  error: Error,\n  configuration: LogsConfiguration,\n  callback: (errorText: string) => void\n) {\n  callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration))\n}\n\nexport function computeFetchResponseText(\n  response: Response,\n  configuration: LogsConfiguration,\n  callback: (responseText?: string) => void\n) {\n  const clonedResponse = tryToClone(response)\n  if (!clonedResponse || !clonedResponse.body) {\n    // if the clone failed or if the body is null, let's not try to read it.\n    callback()\n  } else if (!window.TextDecoder) {\n    // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.\n    //\n    // This should only be the case on early versions of Edge (before they migrated to Chromium).\n    // Even if it could be possible to implement a workaround for the missing TextDecoder API (using\n    // a Blob and FileReader), we found another issue preventing us from reading only the first\n    // bytes from the response: contrary to other browsers, when reading from the cloned response,\n    // if the original response gets canceled, the cloned response is also canceled and we can't\n    // know about it.  In the following illustration, the promise returned by `reader.read()` may\n    // never be fulfilled:\n    //\n    // fetch('/').then((response) => {\n    //   const reader = response.clone().body.getReader()\n    //   readMore()\n    //   function readMore() {\n    //     reader.read().then(\n    //       (result) => {\n    //         if (result.done) {\n    //           console.log('done')\n    //         } else {\n    //           readMore()\n    //         }\n    //       },\n    //       () => console.log('error')\n    //     )\n    //   }\n    //   response.body.getReader().cancel()\n    // })\n    clonedResponse.text().then(\n      monitor((text) => callback(truncateResponseText(text, configuration))),\n      monitor((error) => callback(`Unable to retrieve response: ${error as string}`))\n    )\n  } else {\n    truncateResponseStream(\n      clonedResponse.body,\n      configuration.requestErrorResponseLengthLimit,\n      (error, responseText) => {\n        if (error) {\n          callback(`Unable to retrieve response: ${error as unknown as string}`)\n        } else {\n          callback(responseText)\n        }\n      }\n    )\n  }\n}\n\nfunction isRejected(request: { status: number; responseType?: string }) {\n  return request.status === 0 && request.responseType !== 'opaque'\n}\n\nfunction truncateResponseText(responseText: string, configuration: LogsConfiguration) {\n  if (responseText.length > configuration.requestErrorResponseLengthLimit) {\n    return `${responseText.substring(0, configuration.requestErrorResponseLengthLimit)}...`\n  }\n  return responseText\n}\n\nfunction format(type: RequestType) {\n  if (RequestType.XHR === type) {\n    return 'XHR'\n  }\n  return 'Fetch'\n}\n\nfunction truncateResponseStream(\n  stream: ReadableStream<Uint8Array>,\n  bytesLimit: number,\n  callback: (error?: Error, responseText?: string) => void\n) {\n  readBytesFromStream(\n    stream,\n    (error, bytes, limitExceeded) => {\n      if (error) {\n        callback(error)\n      } else {\n        let responseText = new TextDecoder().decode(bytes)\n        if (limitExceeded) {\n          responseText += '...'\n        }\n        callback(undefined, responseText)\n      }\n    },\n    {\n      bytesLimit,\n      collectStreamBody: true,\n    }\n  )\n}\n", "import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport { noop, ErrorSource, trackRuntimeError, Observable } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startRuntimeErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const rawErrorObservable = new Observable<RawError>()\n\n  const { stop: stopRuntimeErrorTracking } = trackRuntimeError(rawErrorObservable)\n\n  const rawErrorSubscription = rawErrorObservable.subscribe((rawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: rawError.message,\n        date: rawError.startClocks.timeStamp,\n        error: {\n          kind: rawError.type,\n          origin: ErrorSource.SOURCE, // Todo: Remove in the next major release\n          stack: rawError.stack,\n        },\n        origin: ErrorSource.SOURCE,\n        status: StatusType.error,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      stopRuntimeErrorTracking()\n      rawErrorSubscription.unsubscribe()\n    },\n  }\n}\n", "import { AbstractLifeCycle } from '@datadog/browser-core'\nimport type { Context } from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { CommonContext, RawLogsEvent } from '../rawLogsEvent.types'\nimport type { Logger } from './logger'\n\nexport const enum LifeCycleEventType {\n  RAW_LOG_COLLECTED,\n  LOG_COLLECTED,\n}\n\ninterface LifeCycleEventMap {\n  [LifeCycleEventType.RAW_LOG_COLLECTED]: RawLogsEventCollectedData\n  [LifeCycleEventType.LOG_COLLECTED]: LogsEvent & Context\n}\n\nexport const LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\nexport type LifeCycle = AbstractLifeCycle<LifeCycleEventMap>\n\nexport interface RawLogsEventCollectedData<E extends RawLogsEvent = RawLogsEvent> {\n  rawLogsEvent: E\n  messageContext?: object\n  savedCommonContext?: CommonContext\n  logger?: Logger\n}\n", "import type { Context, Observable, PageExitEvent, RawError } from '@datadog/browser-core'\nimport { startBatchWithReplica } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBatch(\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const batch = startBatchWithReplica(\n    configuration,\n    configuration.logsEndpointBuilder,\n    reportError,\n    pageExitObservable,\n    sessionExpireObservable,\n    configuration.replica?.logsEndpointBuilder\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    batch.add(serverLogsEvent)\n  })\n}\n", "import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'log', LogsEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    bridge.send('log', serverLogsEvent)\n  })\n}\n", "import type { RelativeTime } from '@datadog/browser-core'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport interface InternalContext {\n  session_id: string | undefined\n}\n\nexport function startInternalContext(sessionManager: LogsSessionManager) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const trackedSession = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (trackedSession) {\n        return {\n          session_id: trackedSession.id,\n        }\n      }\n    },\n  }\n}\n", "import type { Context, TelemetryEvent, RawError, Observable, PageExitEvent } from '@datadog/browser-core'\nimport {\n  sendToExtension,\n  createPageExitObservable,\n  TelemetryService,\n  willSyntheticsInjectRum,\n  canUseEventBridge,\n  getEventBridge,\n  startTelemetry,\n  startBatchWithReplica,\n  isTelemetryReplicationAllowed,\n  ErrorSource,\n  addTelemetryConfiguration,\n  addTelemetryDebug,\n} from '@datadog/browser-core'\nimport { startLogsSessionManager, startLogsSessionManagerStub } from '../domain/logsSessionManager'\nimport type { LogsConfiguration, LogsInitConfiguration } from '../domain/configuration'\nimport { serializeLogsConfiguration } from '../domain/configuration'\nimport { startLogsAssembly, getRUMInternalContext } from '../domain/assembly'\nimport { startConsoleCollection } from '../domain/logsCollection/console/consoleCollection'\nimport { startReportCollection } from '../domain/logsCollection/report/reportCollection'\nimport { startNetworkErrorCollection } from '../domain/logsCollection/networkError/networkErrorCollection'\nimport { startRuntimeErrorCollection } from '../domain/logsCollection/runtimeError/runtimeErrorCollection'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startLoggerCollection } from '../domain/logsCollection/logger/loggerCollection'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport { startLogsBatch } from '../transport/startLogsBatch'\nimport { startLogsBridge } from '../transport/startLogsBridge'\nimport type { Logger } from '../domain/logger'\nimport { StatusType } from '../domain/logger'\nimport { startInternalContext } from '../domain/internalContext'\n\nexport function startLogs(\n  initConfiguration: LogsInitConfiguration,\n  configuration: LogsConfiguration,\n  buildCommonContext: () => CommonContext,\n  mainLogger: Logger\n) {\n  const lifeCycle = new LifeCycle()\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (log) => sendToExtension('logs', log))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: error.message,\n        date: error.startClocks.timeStamp,\n        error: {\n          origin: ErrorSource.AGENT, // Todo: Remove in the next major release\n        },\n        origin: ErrorSource.AGENT,\n        status: StatusType.error,\n      },\n    })\n    addTelemetryDebug('Error reported to customer', { 'error.message': error.message })\n  }\n  const pageExitObservable = createPageExitObservable()\n\n  const session =\n    configuration.sessionStoreStrategyType && !canUseEventBridge() && !willSyntheticsInjectRum()\n      ? startLogsSessionManager(configuration)\n      : startLogsSessionManagerStub(configuration)\n\n  const telemetry = startLogsTelemetry(configuration, reportError, pageExitObservable, session.expireObservable)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: getRUMInternalContext()?.application_id,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: (getRUMInternalContext()?.view as Context)?.id,\n    },\n    action: {\n      id: (getRUMInternalContext()?.user_action as Context)?.id,\n    },\n  }))\n\n  startNetworkErrorCollection(configuration, lifeCycle)\n  startRuntimeErrorCollection(configuration, lifeCycle)\n  startConsoleCollection(configuration, lifeCycle)\n  startReportCollection(configuration, lifeCycle)\n  const { handleLog } = startLoggerCollection(lifeCycle)\n\n  startLogsAssembly(session, configuration, lifeCycle, buildCommonContext, mainLogger, reportError)\n\n  if (!canUseEventBridge()) {\n    startLogsBatch(configuration, lifeCycle, reportError, pageExitObservable, session.expireObservable)\n  } else {\n    startLogsBridge(lifeCycle)\n  }\n\n  addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration))\n  const internalContext = startInternalContext(session)\n\n  return {\n    handleLog,\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startLogsTelemetry(\n  configuration: LogsConfiguration,\n  reportError: (error: RawError) => void,\n  pageExitObservable: Observable<PageExitEvent>,\n  sessionExpireObservable: Observable<void>\n) {\n  const telemetry = startTelemetry(TelemetryService.LOGS, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  } else {\n    const telemetryBatch = startBatchWithReplica(\n      configuration,\n      configuration.rumEndpointBuilder,\n      reportError,\n      pageExitObservable,\n      sessionExpireObservable,\n      configuration.replica?.rumEndpointBuilder\n    )\n    telemetry.observable.subscribe((event) => telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration)))\n  }\n  return telemetry\n}\n", "import { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { LogsPublicApi } from '../boot/logsPublicApi'\nimport { makeLogsPublicApi } from '../boot/logsPublicApi'\nimport { startLogs } from '../boot/startLogs'\n\nexport { Logger, LogsMessage, StatusType, HandlerType } from '../domain/logger'\nexport { LoggerConfiguration, LogsPublicApi as LogsGlobal } from '../boot/logsPublicApi'\nexport { LogsInitConfiguration } from '../domain/configuration'\nexport { LogsEvent } from '../logsEvent.types'\n\nexport const datadogLogs = makeLogsPublicApi(startLogs)\n\ninterface BrowserWindow extends Window {\n  DD_LOGS?: LogsPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_LOGS', datadogLogs)\n"],
  "mappings": "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",
  "names": ["Logger", "_a", "_a", "_a", "_a", "_a", "_a"]
}
